{"version":3,"file":"getWasmBoyTsCore.closure.iife.js","sources":["core.esm.js","../../core/portable/getTsCore.js"],"sourcesContent":["// Banner placed by rollup to mock out some items on our esm build\n// This is useful for things like wasmmemory\n\nconst wasmboyMemorySize = 0x8b0000;\n\n// Simply initialized to the size we need\nconst wasmByteMemory = new Uint8ClampedArray(wasmboyMemorySize);\n\n// Memory mock\nexport const memory = {\n  size: () => {\n    return wasmboyMemorySize;\n  },\n  grow: () => {},\n  wasmByteMemory: wasmByteMemory\n};\n\nconst load = offset => {\n  return wasmByteMemory[offset];\n};\n\nconst store = (offset, value) => {\n  wasmByteMemory[offset] = value;\n};\n\nconst abs = value => {\n  return Math.abs(value);\n};\n\nconst ceil = value => {\n  return Math.ceil(value);\n};\n\n// Constants that will be shared by the wasm core of the emulator\n// And libraries built around the wasm (such as the official JS), or @CryZe wasmboy-rs\n// ----------------------------------\n// Wasmboy Memory Map\n// https://docs.google.com/spreadsheets/d/17xrEzJk5-sCB9J2mMJcVnzhbE-XH_NvczVSQH9OHvRk/edit?usp=sharing\n// ----------------------------------\n// AssemblyScript\nvar ASSEMBLYSCRIPT_MEMORY_LOCATION = 0x000000;\nvar ASSEMBLYSCRIPT_MEMORY_SIZE = 0x000400;\n// WasmBoy States\nvar WASMBOY_STATE_LOCATION = ASSEMBLYSCRIPT_MEMORY_LOCATION + ASSEMBLYSCRIPT_MEMORY_SIZE;\nvar WASMBOY_STATE_SIZE = 0x000400;\n// Gameboy Internal Memory\nvar VIDEO_RAM_LOCATION = WASMBOY_STATE_LOCATION + WASMBOY_STATE_SIZE;\nvar VIDEO_RAM_SIZE = 0x004000;\nvar WORK_RAM_LOCATION = VIDEO_RAM_LOCATION + VIDEO_RAM_SIZE;\nvar WORK_RAM_SIZE = 0x008000;\nvar OTHER_GAMEBOY_INTERNAL_MEMORY_LOCATION = WORK_RAM_LOCATION + WORK_RAM_SIZE;\nvar OTHER_GAMEBOY_INTERNAL_MEMORY_SIZE = 0x004000;\n// General Gameboy Internal Memory\nvar GAMEBOY_INTERNAL_MEMORY_LOCATION = VIDEO_RAM_LOCATION;\nvar GAMEBOY_INTERNAL_MEMORY_SIZE = OTHER_GAMEBOY_INTERNAL_MEMORY_LOCATION - VIDEO_RAM_LOCATION + OTHER_GAMEBOY_INTERNAL_MEMORY_SIZE;\n// Graphics Output\nvar GBC_PALETTE_LOCATION = OTHER_GAMEBOY_INTERNAL_MEMORY_LOCATION + OTHER_GAMEBOY_INTERNAL_MEMORY_SIZE;\nvar GBC_PALETTE_SIZE = 0x000080;\nvar BG_PRIORITY_MAP_LOCATION = GBC_PALETTE_LOCATION + GBC_PALETTE_SIZE;\nvar BG_PRIORITY_MAP_SIZE = 0x005c00;\nvar FRAME_LOCATION = BG_PRIORITY_MAP_LOCATION + BG_PRIORITY_MAP_SIZE;\nvar FRAME_SIZE = 0x016c00;\nvar BACKGROUND_MAP_LOCATION = FRAME_LOCATION + FRAME_SIZE;\nvar BACKGROUND_MAP_SIZE = 0x030000;\nvar TILE_DATA_LOCATION = BACKGROUND_MAP_LOCATION + BACKGROUND_MAP_SIZE;\nvar TILE_DATA_SIZE = 0x024000;\nvar OAM_TILES_LOCATION = TILE_DATA_LOCATION + TILE_DATA_SIZE;\nvar OAM_TILES_SIZE = 0x003c00;\n// General Graphics Output\nvar GRAPHICS_OUTPUT_LOCATION = GBC_PALETTE_LOCATION;\nvar GRAPHICS_OUTPUT_SIZE = OAM_TILES_LOCATION - GBC_PALETTE_LOCATION + OAM_TILES_SIZE;\n// Audio Output\nvar CHANNEL_1_BUFFER_LOCATION = OAM_TILES_LOCATION + OAM_TILES_SIZE;\nvar CHANNEL_1_BUFFER_SIZE = 0x020000;\nvar CHANNEL_2_BUFFER_LOCATION = CHANNEL_1_BUFFER_LOCATION + CHANNEL_1_BUFFER_SIZE;\nvar CHANNEL_2_BUFFER_SIZE = 0x020000;\nvar CHANNEL_3_BUFFER_LOCATION = CHANNEL_2_BUFFER_LOCATION + CHANNEL_2_BUFFER_SIZE;\nvar CHANNEL_3_BUFFER_SIZE = 0x020000;\nvar CHANNEL_4_BUFFER_LOCATION = CHANNEL_3_BUFFER_LOCATION + CHANNEL_3_BUFFER_SIZE;\nvar CHANNEL_4_BUFFER_SIZE = 0x020000;\nvar AUDIO_BUFFER_LOCATION = CHANNEL_4_BUFFER_LOCATION + CHANNEL_4_BUFFER_SIZE;\nvar AUDIO_BUFFER_SIZE = 0x020000;\n// Catridge Ram\nvar CARTRIDGE_RAM_LOCATION = AUDIO_BUFFER_LOCATION + AUDIO_BUFFER_SIZE;\nvar CARTRIDGE_RAM_SIZE = 0x020000;\n// Boot ROM\n// http://gbdev.gg8.se/files/roms/bootroms/\n// Largest Boot rom is GBC, at 2.5KB\nvar BOOT_ROM_LOCATION = CARTRIDGE_RAM_LOCATION + CARTRIDGE_RAM_SIZE;\nvar BOOT_ROM_SIZE = 0x000a00;\n// Cartridge ROM\nvar CARTRIDGE_ROM_LOCATION = BOOT_ROM_LOCATION + BOOT_ROM_SIZE;\nvar CARTRIDGE_ROM_SIZE = 0x7e0400;\n// Debug Memory\nvar DEBUG_GAMEBOY_MEMORY_LOCATION = CARTRIDGE_ROM_LOCATION + CARTRIDGE_ROM_SIZE;\nvar DEBUG_GAMEBOY_MEMORY_SIZE = 0xffff;\n// Final General Size\nvar WASMBOY_MEMORY_LOCATION = 0x000000;\nvar WASMBOY_MEMORY_SIZE = DEBUG_GAMEBOY_MEMORY_LOCATION + DEBUG_GAMEBOY_MEMORY_SIZE + 1;\nvar WASMBOY_WASM_PAGES = ceil(WASMBOY_MEMORY_SIZE / 1024 / 64) + 1;\n\nvar Config = /** @class */ (function () {\n    function Config() {\n    }\n    // Boot Rom\n    Config.enableBootRom = false;\n    // GBC Options\n    Config.useGbcWhenAvailable = true;\n    // Batch Processing\n    Config.audioBatchProcessing = false;\n    Config.graphicsBatchProcessing = false;\n    Config.timersBatchProcessing = false;\n    // Scanline Rendering\n    Config.graphicsDisableScanlineRendering = false;\n    // Acumulate Sound Samples\n    Config.audioAccumulateSamples = false;\n    // Tile Rednering\n    Config.tileRendering = false;\n    Config.tileCaching = false;\n    // Audio Debugging\n    Config.enableAudioDebugging = false;\n    return Config;\n}());\n\n// Portable Code for JS Wasm Benchmarking\n// https://github.com/AssemblyScript/assemblyscript/wiki/Writing-portable-code\n// https://github.com/AssemblyScript/assemblyscript/blob/master/std/portable/index.js\nfunction u8Portable(param) {\n    return param & 0xff;\n}\nfunction u16Portable(param) {\n    return param & 0xffff;\n}\nfunction i8Portable(param) {\n    return (param << 24) >> 24;\n}\nfunction i32Portable(param) {\n    return param | 0;\n}\n\n// Set flag bit on on register F. For instance set zero flag to zero -> (7, 0)\nfunction setFlagBit(flagBit, flagValue) {\n    var bitwiseOperand = u8Portable(1 << flagBit);\n    if (flagValue > 0) {\n        Cpu.registerF = Cpu.registerF | bitwiseOperand;\n    }\n    else {\n        // XOR out the two ones\n        bitwiseOperand = 0xff ^ bitwiseOperand;\n        Cpu.registerF = Cpu.registerF & bitwiseOperand;\n    }\n    return Cpu.registerF;\n}\n// Overload the set flag bit for ease of use\nfunction setZeroFlag$$1(value) {\n    setFlagBit(7, value);\n}\nfunction setSubtractFlag(value) {\n    setFlagBit(6, value);\n}\nfunction setHalfCarryFlag(value) {\n    setFlagBit(5, value);\n}\nfunction setCarryFlag(value) {\n    setFlagBit(4, value);\n}\n// Getters for flags\nfunction getZeroFlag$$1() {\n    return (Cpu.registerF >> 7) & 0x01;\n}\nfunction getSubtractFlag() {\n    return (Cpu.registerF >> 6) & 0x01;\n}\nfunction getHalfCarryFlag() {\n    return (Cpu.registerF >> 5) & 0x01;\n}\nfunction getCarryFlag$$1() {\n    return (Cpu.registerF >> 4) & 0x01;\n}\n// Must be run before the register actually performs the add\n// amountToAdd i16, since max number can be an u8\nfunction checkAndSetEightBitHalfCarryFlag(value, amountToAdd) {\n    if (amountToAdd >= 0) {\n        // https://robdor.com/2016/08/10/gameboy-emulator-half-carry-flag/\n        var result = u8Portable((value & 0x0f) + (amountToAdd & 0x0f)) & 0x10;\n        setHalfCarryFlag((result !== 0x00));\n    }\n    else {\n        // From: https://github.com/djhworld/gomeboycolor/blob/master/src/cpu/index.go\n        // CTRL+F \"subBytes(a, b byte)\"\n        setHalfCarryFlag(((abs(amountToAdd) & 0x0f) > (value & 0x0f)));\n    }\n}\nfunction checkAndSetEightBitCarryFlag(value, amountToAdd) {\n    if (amountToAdd >= 0) {\n        var result = u8Portable(value + amountToAdd);\n        setCarryFlag((value > result));\n    }\n    else {\n        setCarryFlag((abs(amountToAdd) > value));\n    }\n}\n// Function to handle 16 bit addition overflow, and set the carry flags accordingly\n// i32 on valueTwo to support passing signed immedaite values\nfunction checkAndSetSixteenBitFlagsAddOverflow(valueOne, valueTwo, useStackPointerBits) {\n    // need to differentiate between HL and SP\n    // HL carries are at 11 and 15, SP carries are at 3 and 7 :p\n    if (useStackPointerBits) {\n        // Logic from : https://github.com/nakardo/node-gameboy/blob/master/lib/cpu/opcodes.js\n        // CTRL+F add_sp_n\n        // using the stack pointer bits means we can safely assume the value is signed\n        var signedValueOne = valueOne;\n        var result = signedValueOne + valueTwo;\n        var flagXor = signedValueOne ^ valueTwo ^ result;\n        setHalfCarryFlag(((flagXor & 0x10) !== 0));\n        setCarryFlag(((flagXor & 0x100) !== 0));\n    }\n    else {\n        // Logic from: https://github.com/djhworld/gomeboycolor/blob/master/src/cpu/index.go\n        // CTRL+F addWords\n        // Value two is not signed\n        var result = u16Portable(valueOne + valueTwo);\n        // Check the carry flag by allowing the overflow\n        setCarryFlag((result < valueOne));\n        // To check for half carry flag (bit 15), by XOR'ing valyes, and and'ing the bit in question\n        var halfCarryXor = valueOne ^ valueTwo ^ result;\n        var halfCarryAnd = u16Portable(halfCarryXor & 0x1000);\n        setHalfCarryFlag((halfCarryAnd !== 0x00));\n    }\n}\n\n// File for all of the colors for different GB Palletes\n// https://i.imgur.com/HupBY.png\n// https://www.libretro.com/index.php/gambatte-progress-report/\n// https://tcrf.net/Notes:Game_Boy_Color_Bootstrap_ROM\n// Our default wasmboy gb colors\nvar WasmBoyGBColors = /** @class */ (function () {\n    function WasmBoyGBColors() {\n    }\n    //Bg\n    WasmBoyGBColors.bgWhite = 0xf2f2f2;\n    WasmBoyGBColors.bgLightGrey = 0xa0a0a0;\n    WasmBoyGBColors.bgDarkGrey = 0x585858;\n    WasmBoyGBColors.bgBlack = 0x080808;\n    // Obj 0\n    WasmBoyGBColors.obj0White = 0xf2f2f2;\n    WasmBoyGBColors.obj0LightGrey = 0xa0a0a0;\n    WasmBoyGBColors.obj0DarkGrey = 0x585858;\n    WasmBoyGBColors.obj0Black = 0x080808;\n    // Obj1\n    WasmBoyGBColors.obj1White = 0xf2f2f2;\n    WasmBoyGBColors.obj1LightGrey = 0xa0a0a0;\n    WasmBoyGBColors.obj1DarkGrey = 0x585858;\n    WasmBoyGBColors.obj1Black = 0x080808;\n    return WasmBoyGBColors;\n}());\n// Action Button: Right\nvar GreenColors = /** @class */ (function () {\n    function GreenColors() {\n    }\n    //Bg\n    GreenColors.bgWhite = 0xffffff;\n    GreenColors.bgLightGrey = 0x52ff00;\n    GreenColors.bgDarkGrey = 0xff4200;\n    GreenColors.bgBlack = 0x000000;\n    // Obj 0\n    GreenColors.obj0White = 0xffffff;\n    GreenColors.obj0LightGrey = 0x52ff00;\n    GreenColors.obj0DarkGrey = 0xff4200;\n    GreenColors.obj0Black = 0x000000;\n    // Obj1\n    GreenColors.obj1White = 0xffffff;\n    GreenColors.obj1LightGrey = 0x52ff00;\n    GreenColors.obj1DarkGrey = 0xff4200;\n    GreenColors.obj1Black = 0x000000;\n    return GreenColors;\n}());\n// Action Button: A + Down\nvar OrangeColors = /** @class */ (function () {\n    function OrangeColors() {\n    }\n    //Bg\n    OrangeColors.bgWhite = 0xffffff;\n    OrangeColors.bgLightGrey = 0xffff00;\n    OrangeColors.bgDarkGrey = 0xff0000;\n    OrangeColors.bgBlack = 0x000000;\n    // Obj 0\n    OrangeColors.obj0White = 0xffffff;\n    OrangeColors.obj0LightGrey = 0xffff00;\n    OrangeColors.obj0DarkGrey = 0xff0000;\n    OrangeColors.obj0Black = 0x000000;\n    // Obj1\n    OrangeColors.obj1White = 0xffffff;\n    OrangeColors.obj1LightGrey = 0xffff00;\n    OrangeColors.obj1DarkGrey = 0xff0000;\n    OrangeColors.obj1Black = 0x000000;\n    return OrangeColors;\n}());\n// Action Button: Up\nvar BrownColors = /** @class */ (function () {\n    function BrownColors() {\n    }\n    //Bg\n    BrownColors.bgWhite = 0xffffff;\n    BrownColors.bgLightGrey = 0xffad63;\n    BrownColors.bgDarkGrey = 0x843100;\n    BrownColors.bgBlack = 0x000000;\n    // Obj 0\n    BrownColors.obj0White = 0xffffff;\n    BrownColors.obj0LightGrey = 0xffad63;\n    BrownColors.obj0DarkGrey = 0x843100;\n    BrownColors.obj0Black = 0x000000;\n    // Obj1\n    BrownColors.obj1White = 0xffffff;\n    BrownColors.obj1LightGrey = 0xffad63;\n    BrownColors.obj1DarkGrey = 0x843100;\n    BrownColors.obj1Black = 0x000000;\n    return BrownColors;\n}());\n// Action Button: B + Right\nvar InvertedColors = /** @class */ (function () {\n    function InvertedColors() {\n    }\n    //Bg\n    InvertedColors.bgWhite = 0x000000;\n    InvertedColors.bgLightGrey = 0x008484;\n    InvertedColors.bgDarkGrey = 0xffde00;\n    InvertedColors.bgBlack = 0xffffff;\n    // Obj 0\n    InvertedColors.obj0White = 0x000000;\n    InvertedColors.obj0LightGrey = 0x008484;\n    InvertedColors.obj0DarkGrey = 0xffde00;\n    InvertedColors.obj0Black = 0xffffff;\n    // Obj1\n    InvertedColors.obj1White = 0x000000;\n    InvertedColors.obj1LightGrey = 0x008484;\n    InvertedColors.obj1DarkGrey = 0xffde00;\n    InvertedColors.obj1Black = 0xffffff;\n    return InvertedColors;\n}());\n// Action Button: B + Left\nvar GrayscaleColors = /** @class */ (function () {\n    function GrayscaleColors() {\n    }\n    //Bg\n    GrayscaleColors.bgWhite = 0xffffff;\n    GrayscaleColors.bgLightGrey = 0xa5a5a5;\n    GrayscaleColors.bgDarkGrey = 0x525252;\n    GrayscaleColors.bgBlack = 0x000000;\n    // Obj 0\n    GrayscaleColors.obj0White = 0xffffff;\n    GrayscaleColors.obj0LightGrey = 0xa5a5a5;\n    GrayscaleColors.obj0DarkGrey = 0x525252;\n    GrayscaleColors.obj0Black = 0x000000;\n    // Obj1\n    GrayscaleColors.obj1White = 0xffffff;\n    GrayscaleColors.obj1LightGrey = 0xa5a5a5;\n    GrayscaleColors.obj1DarkGrey = 0x525252;\n    GrayscaleColors.obj1Black = 0x000000;\n    return GrayscaleColors;\n}());\n// Action Button: Down\nvar PastelMixColors = /** @class */ (function () {\n    function PastelMixColors() {\n    }\n    //Bg\n    PastelMixColors.bgWhite = 0xffffa5;\n    PastelMixColors.bgLightGrey = 0xff9494;\n    PastelMixColors.bgDarkGrey = 0x9494ff;\n    PastelMixColors.bgBlack = 0x000000;\n    // Obj 0\n    PastelMixColors.obj0White = 0xffffa5;\n    PastelMixColors.obj0LightGrey = 0xff9494;\n    PastelMixColors.obj0DarkGrey = 0x9494ff;\n    PastelMixColors.obj0Black = 0x000000;\n    // Obj1\n    PastelMixColors.obj1White = 0xffffa5;\n    PastelMixColors.obj1LightGrey = 0xff9494;\n    PastelMixColors.obj1DarkGrey = 0x9494ff;\n    PastelMixColors.obj1Black = 0x000000;\n    return PastelMixColors;\n}());\n// Action Button: B + Up\nvar DarkBrownColors = /** @class */ (function () {\n    function DarkBrownColors() {\n    }\n    //Bg\n    DarkBrownColors.bgWhite = 0xffe6c5;\n    DarkBrownColors.bgLightGrey = 0xce9c84;\n    DarkBrownColors.bgDarkGrey = 0x846b29;\n    DarkBrownColors.bgBlack = 0x5a3108;\n    // Obj 0\n    DarkBrownColors.obj0White = 0xffffff;\n    DarkBrownColors.obj0LightGrey = 0xffad63;\n    DarkBrownColors.obj0DarkGrey = 0x843100;\n    DarkBrownColors.obj0Black = 0x000000;\n    // Obj1\n    DarkBrownColors.obj1White = 0xffffff;\n    DarkBrownColors.obj1LightGrey = 0xffad63;\n    DarkBrownColors.obj1DarkGrey = 0x843100;\n    DarkBrownColors.obj1Black = 0x000000;\n    return DarkBrownColors;\n}());\n// Action Button: A + Right\nvar DarkGreenColors = /** @class */ (function () {\n    function DarkGreenColors() {\n    }\n    //Bg\n    DarkGreenColors.bgWhite = 0xffffff;\n    DarkGreenColors.bgLightGrey = 0x7bff31;\n    DarkGreenColors.bgDarkGrey = 0x0063c5;\n    DarkGreenColors.bgBlack = 0x000000;\n    // Obj 0\n    DarkGreenColors.obj0White = 0xffffff;\n    DarkGreenColors.obj0LightGrey = 0xff8484;\n    DarkGreenColors.obj0DarkGrey = 0x943a3a;\n    DarkGreenColors.obj0Black = 0x000000;\n    // Obj1\n    DarkGreenColors.obj1White = 0xffffff;\n    DarkGreenColors.obj1LightGrey = 0xff8484;\n    DarkGreenColors.obj1DarkGrey = 0x943a3a;\n    DarkGreenColors.obj1Black = 0x000000;\n    return DarkGreenColors;\n}());\n// Action Button: A + Left\nvar DarkBlueColors = /** @class */ (function () {\n    function DarkBlueColors() {\n    }\n    //Bg\n    DarkBlueColors.bgWhite = 0xffffff;\n    DarkBlueColors.bgLightGrey = 0x8c8cde;\n    DarkBlueColors.bgDarkGrey = 0x52528c;\n    DarkBlueColors.bgBlack = 0x000000;\n    // Obj 0\n    DarkBlueColors.obj0White = 0xffffff;\n    DarkBlueColors.obj0LightGrey = 0xff8484;\n    DarkBlueColors.obj0DarkGrey = 0x943a3a;\n    DarkBlueColors.obj0Black = 0x000000;\n    // Obj1\n    DarkBlueColors.obj1White = 0xffffff;\n    DarkBlueColors.obj1LightGrey = 0xffad63;\n    DarkBlueColors.obj1DarkGrey = 0x843100;\n    DarkBlueColors.obj1Black = 0x000000;\n    return DarkBlueColors;\n}());\n// Action Button: A + Up\nvar RedColors = /** @class */ (function () {\n    function RedColors() {\n    }\n    //Bg\n    RedColors.bgWhite = 0xffffff;\n    RedColors.bgLightGrey = 0xff8484;\n    RedColors.bgDarkGrey = 0x943a3a;\n    RedColors.bgBlack = 0x000000;\n    // Obj 0\n    RedColors.obj0White = 0xffffff;\n    RedColors.obj0LightGrey = 0x7bff31;\n    RedColors.obj0DarkGrey = 0x008400;\n    RedColors.obj0Black = 0x000000;\n    // Obj1\n    RedColors.obj1White = 0xffffff;\n    RedColors.obj1LightGrey = 0x63a5ff;\n    RedColors.obj1DarkGrey = 0x0000ff;\n    RedColors.obj1Black = 0x000000;\n    return RedColors;\n}());\n// Action Button: Left\nvar BlueColors = /** @class */ (function () {\n    function BlueColors() {\n    }\n    //Bg\n    BlueColors.bgWhite = 0xffffff;\n    BlueColors.bgLightGrey = 0x63a5ff;\n    BlueColors.bgDarkGrey = 0x0000ff;\n    BlueColors.bgBlack = 0x000000;\n    // Obj 0\n    BlueColors.obj0White = 0xffffff;\n    BlueColors.obj0LightGrey = 0xff8484;\n    BlueColors.obj0DarkGrey = 0x943a3a;\n    BlueColors.obj0Black = 0x000000;\n    // Obj1\n    BlueColors.obj1White = 0xffffff;\n    BlueColors.obj1LightGrey = 0x7bff31;\n    BlueColors.obj1DarkGrey = 0x008400;\n    BlueColors.obj1Black = 0x000000;\n    return BlueColors;\n}());\n// Action Button: B + Down\nvar YellowColors = /** @class */ (function () {\n    function YellowColors() {\n    }\n    //Bg\n    YellowColors.bgWhite = 0xffffff;\n    YellowColors.bgLightGrey = 0xffff00;\n    YellowColors.bgDarkGrey = 0x7b4a00;\n    YellowColors.bgBlack = 0x000000;\n    // Obj 0\n    YellowColors.obj0White = 0xffffff;\n    YellowColors.obj0LightGrey = 0x63a5ff;\n    YellowColors.obj0DarkGrey = 0x0000ff;\n    YellowColors.obj0Black = 0x000000;\n    // Obj1\n    YellowColors.obj1White = 0xffffff;\n    YellowColors.obj1LightGrey = 0x7bff31;\n    YellowColors.obj1DarkGrey = 0x008400;\n    YellowColors.obj1Black = 0x000000;\n    return YellowColors;\n}());\n// Assigned Color Palettes\n// Alleyway\nvar Table00Entry08Colors = /** @class */ (function () {\n    function Table00Entry08Colors() {\n    }\n    //Bg\n    Table00Entry08Colors.bgWhite = 0xa59cff;\n    Table00Entry08Colors.bgLightGrey = 0xffff00;\n    Table00Entry08Colors.bgDarkGrey = 0x006300;\n    Table00Entry08Colors.bgBlack = 0x000000;\n    // Obj 0\n    Table00Entry08Colors.obj0White = 0xa59cff;\n    Table00Entry08Colors.obj0LightGrey = 0xffff00;\n    Table00Entry08Colors.obj0DarkGrey = 0x006300;\n    Table00Entry08Colors.obj0Black = 0x000000;\n    // Obj1\n    Table00Entry08Colors.obj1White = 0xa59cff;\n    Table00Entry08Colors.obj1LightGrey = 0xffff00;\n    Table00Entry08Colors.obj1DarkGrey = 0x006300;\n    Table00Entry08Colors.obj1Black = 0x000000;\n    return Table00Entry08Colors;\n}());\n// Pokemon Blue\nvar Table01Entry0BColors = /** @class */ (function () {\n    function Table01Entry0BColors() {\n    }\n    //Bg\n    Table01Entry0BColors.bgWhite = 0xffffff;\n    Table01Entry0BColors.bgLightGrey = 0x63a5ff;\n    Table01Entry0BColors.bgDarkGrey = 0x0000ff;\n    Table01Entry0BColors.bgBlack = 0x000000;\n    // Obj 0\n    Table01Entry0BColors.obj0White = 0xffffff;\n    Table01Entry0BColors.obj0LightGrey = 0xff8484;\n    Table01Entry0BColors.obj0DarkGrey = 0x943a3a;\n    Table01Entry0BColors.obj0Black = 0x000000;\n    // Obj1\n    Table01Entry0BColors.obj1White = 0xffffff;\n    Table01Entry0BColors.obj1LightGrey = 0x63a5ff;\n    Table01Entry0BColors.obj1DarkGrey = 0x0000ff;\n    Table01Entry0BColors.obj1Black = 0x000000;\n    return Table01Entry0BColors;\n}());\n// Pokemon Red\nvar Table01Entry10Colors = /** @class */ (function () {\n    function Table01Entry10Colors() {\n    }\n    //Bg\n    Table01Entry10Colors.bgWhite = 0xffffff;\n    Table01Entry10Colors.bgLightGrey = 0xff8484;\n    Table01Entry10Colors.bgDarkGrey = 0x943a3a;\n    Table01Entry10Colors.bgBlack = 0x000000;\n    // Obj 0\n    Table01Entry10Colors.obj0White = 0xffffff;\n    Table01Entry10Colors.obj0LightGrey = 0x7bff31;\n    Table01Entry10Colors.obj0DarkGrey = 0x008400;\n    Table01Entry10Colors.obj0Black = 0x000000;\n    // Obj1\n    Table01Entry10Colors.obj1White = 0xffffff;\n    Table01Entry10Colors.obj1LightGrey = 0xff8484;\n    Table01Entry10Colors.obj1DarkGrey = 0x943a3a;\n    Table01Entry10Colors.obj1Black = 0x000000;\n    return Table01Entry10Colors;\n}());\n// Super Mario Land\nvar Table03Entry0AColors = /** @class */ (function () {\n    function Table03Entry0AColors() {\n    }\n    //Bg\n    Table03Entry0AColors.bgWhite = 0xb5b5ff;\n    Table03Entry0AColors.bgLightGrey = 0xffff94;\n    Table03Entry0AColors.bgDarkGrey = 0xad5a42;\n    Table03Entry0AColors.bgBlack = 0x000000;\n    // Obj 0\n    Table03Entry0AColors.obj0White = 0x000000;\n    Table03Entry0AColors.obj0LightGrey = 0xffffff;\n    Table03Entry0AColors.obj0DarkGrey = 0xff8484;\n    Table03Entry0AColors.obj0Black = 0x943a3a;\n    // Obj1\n    Table03Entry0AColors.obj1White = 0x000000;\n    Table03Entry0AColors.obj1LightGrey = 0xffffff;\n    Table03Entry0AColors.obj1DarkGrey = 0xff8484;\n    Table03Entry0AColors.obj1Black = 0x943a3a;\n    return Table03Entry0AColors;\n}());\n// Super Mario Land 3 - WarioLand\nvar Table05Entry00Colors = /** @class */ (function () {\n    function Table05Entry00Colors() {\n    }\n    //Bg\n    Table05Entry00Colors.bgWhite = 0xffffff;\n    Table05Entry00Colors.bgLightGrey = 0xadad84;\n    Table05Entry00Colors.bgDarkGrey = 0x42737b;\n    Table05Entry00Colors.bgBlack = 0x000000;\n    // Obj 0\n    Table05Entry00Colors.obj0White = 0xffffff;\n    Table05Entry00Colors.obj0LightGrey = 0xff7300;\n    Table05Entry00Colors.obj0DarkGrey = 0x944200;\n    Table05Entry00Colors.obj0Black = 0x000000;\n    // Obj1\n    Table05Entry00Colors.obj1White = 0xffffff;\n    Table05Entry00Colors.obj1LightGrey = 0x5abdff;\n    Table05Entry00Colors.obj1DarkGrey = 0xff0000;\n    Table05Entry00Colors.obj1Black = 0x0000ff;\n    return Table05Entry00Colors;\n}());\n// Donkey Kong\nvar Table05Entry01Colors = /** @class */ (function () {\n    function Table05Entry01Colors() {\n    }\n    //Bg\n    Table05Entry01Colors.bgWhite = 0xffff9c;\n    Table05Entry01Colors.bgLightGrey = 0x94b5ff;\n    Table05Entry01Colors.bgDarkGrey = 0x639473;\n    Table05Entry01Colors.bgBlack = 0x003a3a;\n    // Obj 0\n    Table05Entry01Colors.obj0White = 0xffc542;\n    Table05Entry01Colors.obj0LightGrey = 0xffd600;\n    Table05Entry01Colors.obj0DarkGrey = 0x943a00;\n    Table05Entry01Colors.obj0Black = 0x4a0000;\n    // Obj1\n    Table05Entry01Colors.obj1White = 0xffffff;\n    Table05Entry01Colors.obj1LightGrey = 0xff8484;\n    Table05Entry01Colors.obj1DarkGrey = 0x943a3a;\n    Table05Entry01Colors.obj1Black = 0x000000;\n    return Table05Entry01Colors;\n}());\n// Tennis\nvar Table05Entry02Colors = /** @class */ (function () {\n    function Table05Entry02Colors() {\n    }\n    //Bg\n    Table05Entry02Colors.bgWhite = 0x6bff00;\n    Table05Entry02Colors.bgLightGrey = 0xffffff;\n    Table05Entry02Colors.bgDarkGrey = 0xff524a;\n    Table05Entry02Colors.bgBlack = 0x000000;\n    // Obj 0\n    Table05Entry02Colors.obj0White = 0xffffff;\n    Table05Entry02Colors.obj0LightGrey = 0xffffff;\n    Table05Entry02Colors.obj0DarkGrey = 0x63a5ff;\n    Table05Entry02Colors.obj0Black = 0x0000ff;\n    // Obj1\n    Table05Entry02Colors.obj1White = 0xffffff;\n    Table05Entry02Colors.obj1LightGrey = 0xffad63;\n    Table05Entry02Colors.obj1DarkGrey = 0x843100;\n    Table05Entry02Colors.obj1Black = 0x000000;\n    return Table05Entry02Colors;\n}());\n// Kirby's Dream Land\nvar Table05Entry08Colors = /** @class */ (function () {\n    function Table05Entry08Colors() {\n    }\n    //Bg\n    Table05Entry08Colors.bgWhite = 0xa59cff;\n    Table05Entry08Colors.bgLightGrey = 0xffff00;\n    Table05Entry08Colors.bgDarkGrey = 0x006300;\n    Table05Entry08Colors.bgBlack = 0x000000;\n    // Obj 0\n    Table05Entry08Colors.obj0White = 0xff6352;\n    Table05Entry08Colors.obj0LightGrey = 0xd60000;\n    Table05Entry08Colors.obj0DarkGrey = 0x630000;\n    Table05Entry08Colors.obj0Black = 0x000000;\n    // Obj1\n    Table05Entry08Colors.obj1White = 0x0000ff;\n    Table05Entry08Colors.obj1LightGrey = 0xffffff;\n    Table05Entry08Colors.obj1DarkGrey = 0xffff7b;\n    Table05Entry08Colors.obj1Black = 0x0084ff;\n    return Table05Entry08Colors;\n}());\n// Super Mario Land 2 BAYYYBEEE\nvar Table05Entry09Colors = /** @class */ (function () {\n    function Table05Entry09Colors() {\n    }\n    //Bg\n    Table05Entry09Colors.bgWhite = 0xffffce;\n    Table05Entry09Colors.bgLightGrey = 0x63efef;\n    Table05Entry09Colors.bgDarkGrey = 0x9c8431;\n    Table05Entry09Colors.bgBlack = 0x5a5a5a;\n    // Obj 0\n    Table05Entry09Colors.obj0White = 0xffffff;\n    Table05Entry09Colors.obj0LightGrey = 0xff7300;\n    Table05Entry09Colors.obj0DarkGrey = 0x944200;\n    Table05Entry09Colors.obj0Black = 0x000000;\n    // Obj1\n    Table05Entry09Colors.obj1White = 0xffffff;\n    Table05Entry09Colors.obj1LightGrey = 0x63a5ff;\n    Table05Entry09Colors.obj1DarkGrey = 0x0000ff;\n    Table05Entry09Colors.obj1Black = 0x000000;\n    return Table05Entry09Colors;\n}());\n// Link's Awakening\nvar Table05Entry11Colors = /** @class */ (function () {\n    function Table05Entry11Colors() {\n    }\n    // Bg\n    Table05Entry11Colors.bgWhite = 0xffffff;\n    Table05Entry11Colors.bgLightGrey = 0xff8484;\n    Table05Entry11Colors.bgDarkGrey = 0x943a3a;\n    Table05Entry11Colors.bgBlack = 0x000000;\n    // Obj 0\n    Table05Entry11Colors.obj0White = 0xffffff;\n    Table05Entry11Colors.obj0LightGrey = 0x00ff00;\n    Table05Entry11Colors.obj0DarkGrey = 0x318400;\n    Table05Entry11Colors.obj0Black = 0x004a00;\n    // Obj1\n    Table05Entry11Colors.obj1White = 0xffffff;\n    Table05Entry11Colors.obj1LightGrey = 0x63a5ff;\n    Table05Entry11Colors.obj1DarkGrey = 0x0000ff;\n    Table05Entry11Colors.obj1Black = 0x000000;\n    return Table05Entry11Colors;\n}());\n// Metroid 2\nvar Table05Entry14Colors = /** @class */ (function () {\n    function Table05Entry14Colors() {\n    }\n    //Bg\n    Table05Entry14Colors.bgWhite = 0xffffff;\n    Table05Entry14Colors.bgLightGrey = 0x63a5ff;\n    Table05Entry14Colors.bgDarkGrey = 0x0000ff;\n    Table05Entry14Colors.bgBlack = 0x000000;\n    // Obj 0\n    Table05Entry14Colors.obj0White = 0xffff00;\n    Table05Entry14Colors.obj0LightGrey = 0xff0000;\n    Table05Entry14Colors.obj0DarkGrey = 0x630000;\n    Table05Entry14Colors.obj0Black = 0x000000;\n    // Obj1\n    Table05Entry14Colors.obj1White = 0xffffff;\n    Table05Entry14Colors.obj1LightGrey = 0x7bff31;\n    Table05Entry14Colors.obj1DarkGrey = 0x008400;\n    Table05Entry14Colors.obj1Black = 0x000000;\n    return Table05Entry14Colors;\n}());\n// WarioLand 2\nvar Table05Entry15Colors = /** @class */ (function () {\n    function Table05Entry15Colors() {\n    }\n    //Bg\n    Table05Entry15Colors.bgWhite = 0xffffff;\n    Table05Entry15Colors.bgLightGrey = 0xadad84;\n    Table05Entry15Colors.bgDarkGrey = 0x42737b;\n    Table05Entry15Colors.bgBlack = 0x000000;\n    // Obj 0\n    Table05Entry15Colors.obj0White = 0xffffff;\n    Table05Entry15Colors.obj0LightGrey = 0xffad63;\n    Table05Entry15Colors.obj0DarkGrey = 0xffad63;\n    Table05Entry15Colors.obj0Black = 0x000000;\n    // Obj1\n    Table05Entry15Colors.obj1White = 0xffffff;\n    Table05Entry15Colors.obj1LightGrey = 0x63a5ff;\n    Table05Entry15Colors.obj1DarkGrey = 0x0000ff;\n    Table05Entry15Colors.obj1Black = 0x000000;\n    return Table05Entry15Colors;\n}());\n\n// File for all of the logic of setting gameboy color plaettes\n// Current / exported color\nvar Colors = /** @class */ (function () {\n    function Colors() {\n    }\n    //Bg\n    Colors.bgWhite = WasmBoyGBColors.bgWhite;\n    Colors.bgLightGrey = WasmBoyGBColors.bgLightGrey;\n    Colors.bgDarkGrey = WasmBoyGBColors.bgDarkGrey;\n    Colors.bgBlack = WasmBoyGBColors.bgBlack;\n    // Obj 0\n    Colors.obj0White = WasmBoyGBColors.obj0White;\n    Colors.obj0LightGrey = WasmBoyGBColors.obj0LightGrey;\n    Colors.obj0DarkGrey = WasmBoyGBColors.obj0DarkGrey;\n    Colors.obj0Black = WasmBoyGBColors.obj0Black;\n    // Obj1\n    Colors.obj1White = WasmBoyGBColors.obj1White;\n    Colors.obj1LightGrey = WasmBoyGBColors.obj1LightGrey;\n    Colors.obj1DarkGrey = WasmBoyGBColors.obj1DarkGrey;\n    Colors.obj1Black = WasmBoyGBColors.obj1Black;\n    return Colors;\n}());\n// Inlined because closure compiler inlines\nfunction initializeColors() {\n    setManualColorizationPalette(0);\n    if (Cpu.GBCEnabled) {\n        // Don't need to continue this if a GBC game\n        return;\n    }\n    if (Cpu.BootROMEnabled) {\n        if (!Cpu.GBCEnabled) {\n            // GB\n            return;\n        }\n    }\n    // Do some automatic color palette swapping if we have a loaded ROM\n    var titleChecksum = 0x00;\n    for (var i = 0x0134; i <= 0x0143; i++) {\n        titleChecksum += eightBitLoadFromGBMemory(i);\n    }\n    // Set the colorization for the game automatically if assigned\n    // https://tcrf.net/Notes:Game_Boy_Color_Bootstrap_ROM\n    var hash = titleChecksum & 0xff;\n    setHashColorizationPalette(hash);\n}\nfunction getRedFromHexColor(color) {\n    return (color & 0xff0000) >> 16;\n}\nfunction getGreenFromHexColor(color) {\n    return (color & 0x00ff00) >> 8;\n}\nfunction getBlueFromHexColor(color) {\n    return color & 0x0000ff;\n}\n// Function to set the colorization\n// By manually pressing buttons\nfunction setManualColorizationPalette(colorizationId) {\n    // Set the colorizationId clockwise according to:\n    // https://en.wikipedia.org/wiki/Game_Boy_Color\n    switch (colorizationId) {\n        case 0:\n            Colors.bgWhite = WasmBoyGBColors.bgWhite;\n            Colors.bgLightGrey = WasmBoyGBColors.bgLightGrey;\n            Colors.bgDarkGrey = WasmBoyGBColors.bgDarkGrey;\n            Colors.bgBlack = WasmBoyGBColors.bgBlack;\n            Colors.obj0White = WasmBoyGBColors.obj0White;\n            Colors.obj0LightGrey = WasmBoyGBColors.obj0LightGrey;\n            Colors.obj0DarkGrey = WasmBoyGBColors.obj0DarkGrey;\n            Colors.obj0Black = WasmBoyGBColors.obj0Black;\n            Colors.obj1White = WasmBoyGBColors.obj1White;\n            Colors.obj1LightGrey = WasmBoyGBColors.obj1LightGrey;\n            Colors.obj1DarkGrey = WasmBoyGBColors.obj1DarkGrey;\n            Colors.obj1Black = WasmBoyGBColors.obj1Black;\n            break;\n        case 1:\n            // Up, Brown\n            Colors.bgWhite = BrownColors.bgWhite;\n            Colors.bgLightGrey = BrownColors.bgLightGrey;\n            Colors.bgDarkGrey = BrownColors.bgDarkGrey;\n            Colors.bgBlack = BrownColors.bgBlack;\n            Colors.obj0White = BrownColors.obj0White;\n            Colors.obj0LightGrey = BrownColors.obj0LightGrey;\n            Colors.obj0DarkGrey = BrownColors.obj0DarkGrey;\n            Colors.obj0Black = BrownColors.obj0Black;\n            Colors.obj1White = BrownColors.obj1White;\n            Colors.obj1LightGrey = BrownColors.obj1LightGrey;\n            Colors.obj1DarkGrey = BrownColors.obj1DarkGrey;\n            Colors.obj1Black = BrownColors.obj1Black;\n            break;\n        case 2:\n            // Up + A, Red\n            Colors.bgWhite = RedColors.bgWhite;\n            Colors.bgLightGrey = RedColors.bgLightGrey;\n            Colors.bgDarkGrey = RedColors.bgDarkGrey;\n            Colors.bgBlack = RedColors.bgBlack;\n            Colors.obj0White = RedColors.obj0White;\n            Colors.obj0LightGrey = RedColors.obj0LightGrey;\n            Colors.obj0DarkGrey = RedColors.obj0DarkGrey;\n            Colors.obj0Black = RedColors.obj0Black;\n            Colors.obj1White = RedColors.obj1White;\n            Colors.obj1LightGrey = RedColors.obj1LightGrey;\n            Colors.obj1DarkGrey = RedColors.obj1DarkGrey;\n            Colors.obj1Black = RedColors.obj1Black;\n            break;\n        case 3:\n            // Up + B, DarkBrown\n            Colors.bgWhite = DarkBrownColors.bgWhite;\n            Colors.bgLightGrey = DarkBrownColors.bgLightGrey;\n            Colors.bgDarkGrey = DarkBrownColors.bgDarkGrey;\n            Colors.bgBlack = DarkBrownColors.bgBlack;\n            Colors.obj0White = DarkBrownColors.obj0White;\n            Colors.obj0LightGrey = DarkBrownColors.obj0LightGrey;\n            Colors.obj0DarkGrey = DarkBrownColors.obj0DarkGrey;\n            Colors.obj0Black = DarkBrownColors.obj0Black;\n            Colors.obj1White = DarkBrownColors.obj1White;\n            Colors.obj1LightGrey = DarkBrownColors.obj1LightGrey;\n            Colors.obj1DarkGrey = DarkBrownColors.obj1DarkGrey;\n            Colors.obj1Black = DarkBrownColors.obj1Black;\n            break;\n        case 4:\n            // Right, Green\n            Colors.bgWhite = GreenColors.bgWhite;\n            Colors.bgLightGrey = GreenColors.bgLightGrey;\n            Colors.bgDarkGrey = GreenColors.bgDarkGrey;\n            Colors.bgBlack = GreenColors.bgBlack;\n            Colors.obj0White = GreenColors.obj0White;\n            Colors.obj0LightGrey = GreenColors.obj0LightGrey;\n            Colors.obj0DarkGrey = GreenColors.obj0DarkGrey;\n            Colors.obj0Black = GreenColors.obj0Black;\n            Colors.obj1White = GreenColors.obj1White;\n            Colors.obj1LightGrey = GreenColors.obj1LightGrey;\n            Colors.obj1DarkGrey = GreenColors.obj1DarkGrey;\n            Colors.obj1Black = GreenColors.obj1Black;\n            break;\n        case 5:\n            // Right + A, DarkGreenColors\n            Colors.bgWhite = DarkGreenColors.bgWhite;\n            Colors.bgLightGrey = DarkGreenColors.bgLightGrey;\n            Colors.bgDarkGrey = DarkGreenColors.bgDarkGrey;\n            Colors.bgBlack = DarkGreenColors.bgBlack;\n            Colors.obj0White = DarkGreenColors.obj0White;\n            Colors.obj0LightGrey = DarkGreenColors.obj0LightGrey;\n            Colors.obj0DarkGrey = DarkGreenColors.obj0DarkGrey;\n            Colors.obj0Black = DarkGreenColors.obj0Black;\n            Colors.obj1White = DarkGreenColors.obj1White;\n            Colors.obj1LightGrey = DarkGreenColors.obj1LightGrey;\n            Colors.obj1DarkGrey = DarkGreenColors.obj1DarkGrey;\n            Colors.obj1Black = DarkGreenColors.obj1Black;\n            break;\n        case 6:\n            // Right + B, InvertedColors\n            Colors.bgWhite = InvertedColors.bgWhite;\n            Colors.bgLightGrey = InvertedColors.bgLightGrey;\n            Colors.bgDarkGrey = InvertedColors.bgDarkGrey;\n            Colors.bgBlack = InvertedColors.bgBlack;\n            Colors.obj0White = InvertedColors.obj0White;\n            Colors.obj0LightGrey = InvertedColors.obj0LightGrey;\n            Colors.obj0DarkGrey = InvertedColors.obj0DarkGrey;\n            Colors.obj0Black = InvertedColors.obj0Black;\n            Colors.obj1White = InvertedColors.obj1White;\n            Colors.obj1LightGrey = InvertedColors.obj1LightGrey;\n            Colors.obj1DarkGrey = InvertedColors.obj1DarkGrey;\n            Colors.obj1Black = InvertedColors.obj1Black;\n            break;\n        case 7:\n            // Down, PastelMixColors\n            Colors.bgWhite = PastelMixColors.bgWhite;\n            Colors.bgLightGrey = PastelMixColors.bgLightGrey;\n            Colors.bgDarkGrey = PastelMixColors.bgDarkGrey;\n            Colors.bgBlack = PastelMixColors.bgBlack;\n            Colors.obj0White = PastelMixColors.obj0White;\n            Colors.obj0LightGrey = PastelMixColors.obj0LightGrey;\n            Colors.obj0DarkGrey = PastelMixColors.obj0DarkGrey;\n            Colors.obj0Black = PastelMixColors.obj0Black;\n            Colors.obj1White = PastelMixColors.obj1White;\n            Colors.obj1LightGrey = PastelMixColors.obj1LightGrey;\n            Colors.obj1DarkGrey = PastelMixColors.obj1DarkGrey;\n            Colors.obj1Black = PastelMixColors.obj1Black;\n            break;\n        case 8:\n            // Down + A, Orange\n            Colors.bgWhite = OrangeColors.bgWhite;\n            Colors.bgLightGrey = OrangeColors.bgLightGrey;\n            Colors.bgDarkGrey = OrangeColors.bgDarkGrey;\n            Colors.bgBlack = OrangeColors.bgBlack;\n            Colors.obj0White = OrangeColors.obj0White;\n            Colors.obj0LightGrey = OrangeColors.obj0LightGrey;\n            Colors.obj0DarkGrey = OrangeColors.obj0DarkGrey;\n            Colors.obj0Black = OrangeColors.obj0Black;\n            Colors.obj1White = OrangeColors.obj1White;\n            Colors.obj1LightGrey = OrangeColors.obj1LightGrey;\n            Colors.obj1DarkGrey = OrangeColors.obj1DarkGrey;\n            Colors.obj1Black = OrangeColors.obj1Black;\n            break;\n        case 9:\n            // Down + B, Yellow\n            Colors.bgWhite = YellowColors.bgWhite;\n            Colors.bgLightGrey = YellowColors.bgLightGrey;\n            Colors.bgDarkGrey = YellowColors.bgDarkGrey;\n            Colors.bgBlack = YellowColors.bgBlack;\n            Colors.obj0White = YellowColors.obj0White;\n            Colors.obj0LightGrey = YellowColors.obj0LightGrey;\n            Colors.obj0DarkGrey = YellowColors.obj0DarkGrey;\n            Colors.obj0Black = YellowColors.obj0Black;\n            Colors.obj1White = YellowColors.obj1White;\n            Colors.obj1LightGrey = YellowColors.obj1LightGrey;\n            Colors.obj1DarkGrey = YellowColors.obj1DarkGrey;\n            Colors.obj1Black = YellowColors.obj1Black;\n            break;\n        case 10:\n            // Left, Blue\n            Colors.bgWhite = BlueColors.bgWhite;\n            Colors.bgLightGrey = BlueColors.bgLightGrey;\n            Colors.bgDarkGrey = BlueColors.bgDarkGrey;\n            Colors.bgBlack = BlueColors.bgBlack;\n            Colors.obj0White = BlueColors.obj0White;\n            Colors.obj0LightGrey = BlueColors.obj0LightGrey;\n            Colors.obj0DarkGrey = BlueColors.obj0DarkGrey;\n            Colors.obj0Black = BlueColors.obj0Black;\n            Colors.obj1White = BlueColors.obj1White;\n            Colors.obj1LightGrey = BlueColors.obj1LightGrey;\n            Colors.obj1DarkGrey = BlueColors.obj1DarkGrey;\n            Colors.obj1Black = BlueColors.obj1Black;\n            break;\n        case 11:\n            // Left + A, Dark Blue\n            Colors.bgWhite = DarkBlueColors.bgWhite;\n            Colors.bgLightGrey = DarkBlueColors.bgLightGrey;\n            Colors.bgDarkGrey = DarkBlueColors.bgDarkGrey;\n            Colors.bgBlack = DarkBlueColors.bgBlack;\n            Colors.obj0White = DarkBlueColors.obj0White;\n            Colors.obj0LightGrey = DarkBlueColors.obj0LightGrey;\n            Colors.obj0DarkGrey = DarkBlueColors.obj0DarkGrey;\n            Colors.obj0Black = DarkBlueColors.obj0Black;\n            Colors.obj1White = DarkBlueColors.obj1White;\n            Colors.obj1LightGrey = DarkBlueColors.obj1LightGrey;\n            Colors.obj1DarkGrey = DarkBlueColors.obj1DarkGrey;\n            Colors.obj1Black = DarkBlueColors.obj1Black;\n            break;\n        case 12:\n            // Left + B, GrayScale\n            Colors.bgWhite = GrayscaleColors.bgWhite;\n            Colors.bgLightGrey = GrayscaleColors.bgLightGrey;\n            Colors.bgDarkGrey = GrayscaleColors.bgDarkGrey;\n            Colors.bgBlack = GrayscaleColors.bgBlack;\n            Colors.obj0White = GrayscaleColors.obj0White;\n            Colors.obj0LightGrey = GrayscaleColors.obj0LightGrey;\n            Colors.obj0DarkGrey = GrayscaleColors.obj0DarkGrey;\n            Colors.obj0Black = GrayscaleColors.obj0Black;\n            Colors.obj1White = GrayscaleColors.obj1White;\n            Colors.obj1LightGrey = GrayscaleColors.obj1LightGrey;\n            Colors.obj1DarkGrey = GrayscaleColors.obj1DarkGrey;\n            Colors.obj1Black = GrayscaleColors.obj1Black;\n            break;\n    }\n}\n// Function to set the colorization\n// By checksum of the title\n// https://forums.nesdev.com/viewtopic.php?f=20&t=10226\n// TODO: torch2424 need to find how to get the \"disambiguation\"\n// Inlined because closure compiler inlines\nfunction setHashColorizationPalette(hash) {\n    switch (hash) {\n        case 0x88:\n            Colors.bgWhite = Table00Entry08Colors.bgWhite;\n            Colors.bgLightGrey = Table00Entry08Colors.bgLightGrey;\n            Colors.bgDarkGrey = Table00Entry08Colors.bgDarkGrey;\n            Colors.bgBlack = Table00Entry08Colors.bgBlack;\n            Colors.obj0White = Table00Entry08Colors.obj0White;\n            Colors.obj0LightGrey = Table00Entry08Colors.obj0LightGrey;\n            Colors.obj0DarkGrey = Table00Entry08Colors.obj0DarkGrey;\n            Colors.obj0Black = Table00Entry08Colors.obj0Black;\n            Colors.obj1White = Table00Entry08Colors.obj1White;\n            Colors.obj1LightGrey = Table00Entry08Colors.obj1LightGrey;\n            Colors.obj1DarkGrey = Table00Entry08Colors.obj1DarkGrey;\n            Colors.obj1Black = Table00Entry08Colors.obj1Black;\n            break;\n        case 0x61:\n            Colors.bgWhite = Table01Entry0BColors.bgWhite;\n            Colors.bgLightGrey = Table01Entry0BColors.bgLightGrey;\n            Colors.bgDarkGrey = Table01Entry0BColors.bgDarkGrey;\n            Colors.bgBlack = Table01Entry0BColors.bgBlack;\n            Colors.obj0White = Table01Entry0BColors.obj0White;\n            Colors.obj0LightGrey = Table01Entry0BColors.obj0LightGrey;\n            Colors.obj0DarkGrey = Table01Entry0BColors.obj0DarkGrey;\n            Colors.obj0Black = Table01Entry0BColors.obj0Black;\n            Colors.obj1White = Table01Entry0BColors.obj1White;\n            Colors.obj1LightGrey = Table01Entry0BColors.obj1LightGrey;\n            Colors.obj1DarkGrey = Table01Entry0BColors.obj1DarkGrey;\n            Colors.obj1Black = Table01Entry0BColors.obj1Black;\n            break;\n        case 0x14:\n            Colors.bgWhite = Table01Entry10Colors.bgWhite;\n            Colors.bgLightGrey = Table01Entry10Colors.bgLightGrey;\n            Colors.bgDarkGrey = Table01Entry10Colors.bgDarkGrey;\n            Colors.bgBlack = Table01Entry10Colors.bgBlack;\n            Colors.obj0White = Table01Entry10Colors.obj0White;\n            Colors.obj0LightGrey = Table01Entry10Colors.obj0LightGrey;\n            Colors.obj0DarkGrey = Table01Entry10Colors.obj0DarkGrey;\n            Colors.obj0Black = Table01Entry10Colors.obj0Black;\n            Colors.obj1White = Table01Entry10Colors.obj1White;\n            Colors.obj1LightGrey = Table01Entry10Colors.obj1LightGrey;\n            Colors.obj1DarkGrey = Table01Entry10Colors.obj1DarkGrey;\n            Colors.obj1Black = Table01Entry10Colors.obj1Black;\n            break;\n        case 0x46:\n            Colors.bgWhite = Table03Entry0AColors.bgWhite;\n            Colors.bgLightGrey = Table03Entry0AColors.bgLightGrey;\n            Colors.bgDarkGrey = Table03Entry0AColors.bgDarkGrey;\n            Colors.bgBlack = Table03Entry0AColors.bgBlack;\n            Colors.obj0White = Table03Entry0AColors.obj0White;\n            Colors.obj0LightGrey = Table03Entry0AColors.obj0LightGrey;\n            Colors.obj0DarkGrey = Table03Entry0AColors.obj0DarkGrey;\n            Colors.obj0Black = Table03Entry0AColors.obj0Black;\n            Colors.obj1White = Table03Entry0AColors.obj1White;\n            Colors.obj1LightGrey = Table03Entry0AColors.obj1LightGrey;\n            Colors.obj1DarkGrey = Table03Entry0AColors.obj1DarkGrey;\n            Colors.obj1Black = Table03Entry0AColors.obj1Black;\n            break;\n        case 0x59:\n        case 0xc6:\n            Colors.bgWhite = Table05Entry00Colors.bgWhite;\n            Colors.bgLightGrey = Table05Entry00Colors.bgLightGrey;\n            Colors.bgDarkGrey = Table05Entry00Colors.bgDarkGrey;\n            Colors.bgBlack = Table05Entry00Colors.bgBlack;\n            Colors.obj0White = Table05Entry00Colors.obj0White;\n            Colors.obj0LightGrey = Table05Entry00Colors.obj0LightGrey;\n            Colors.obj0DarkGrey = Table05Entry00Colors.obj0DarkGrey;\n            Colors.obj0Black = Table05Entry00Colors.obj0Black;\n            Colors.obj1White = Table05Entry00Colors.obj1White;\n            Colors.obj1LightGrey = Table05Entry00Colors.obj1LightGrey;\n            Colors.obj1DarkGrey = Table05Entry00Colors.obj1DarkGrey;\n            Colors.obj1Black = Table05Entry00Colors.obj1Black;\n            break;\n        case 0x86:\n        case 0xa8:\n            Colors.bgWhite = Table05Entry01Colors.bgWhite;\n            Colors.bgLightGrey = Table05Entry01Colors.bgLightGrey;\n            Colors.bgDarkGrey = Table05Entry01Colors.bgDarkGrey;\n            Colors.bgBlack = Table05Entry01Colors.bgBlack;\n            Colors.obj0White = Table05Entry01Colors.obj0White;\n            Colors.obj0LightGrey = Table05Entry01Colors.obj0LightGrey;\n            Colors.obj0DarkGrey = Table05Entry01Colors.obj0DarkGrey;\n            Colors.obj0Black = Table05Entry01Colors.obj0Black;\n            Colors.obj1White = Table05Entry01Colors.obj1White;\n            Colors.obj1LightGrey = Table05Entry01Colors.obj1LightGrey;\n            Colors.obj1DarkGrey = Table05Entry01Colors.obj1DarkGrey;\n            Colors.obj1Black = Table05Entry01Colors.obj1Black;\n            break;\n        case 0xbf:\n        case 0xce:\n        case 0xd1:\n        case 0xf0:\n            Colors.bgWhite = Table05Entry02Colors.bgWhite;\n            Colors.bgLightGrey = Table05Entry02Colors.bgLightGrey;\n            Colors.bgDarkGrey = Table05Entry02Colors.bgDarkGrey;\n            Colors.bgBlack = Table05Entry02Colors.bgBlack;\n            Colors.obj0White = Table05Entry02Colors.obj0White;\n            Colors.obj0LightGrey = Table05Entry02Colors.obj0LightGrey;\n            Colors.obj0DarkGrey = Table05Entry02Colors.obj0DarkGrey;\n            Colors.obj0Black = Table05Entry02Colors.obj0Black;\n            Colors.obj1White = Table05Entry02Colors.obj1White;\n            Colors.obj1LightGrey = Table05Entry02Colors.obj1LightGrey;\n            Colors.obj1DarkGrey = Table05Entry02Colors.obj1DarkGrey;\n            Colors.obj1Black = Table05Entry02Colors.obj1Black;\n            break;\n        case 0x27:\n        case 0x49:\n        case 0x5c:\n        case 0xb3:\n            Colors.bgWhite = Table05Entry08Colors.bgWhite;\n            Colors.bgLightGrey = Table05Entry08Colors.bgLightGrey;\n            Colors.bgDarkGrey = Table05Entry08Colors.bgDarkGrey;\n            Colors.bgBlack = Table05Entry08Colors.bgBlack;\n            Colors.obj0White = Table05Entry08Colors.obj0White;\n            Colors.obj0LightGrey = Table05Entry08Colors.obj0LightGrey;\n            Colors.obj0DarkGrey = Table05Entry08Colors.obj0DarkGrey;\n            Colors.obj0Black = Table05Entry08Colors.obj0Black;\n            Colors.obj1White = Table05Entry08Colors.obj1White;\n            Colors.obj1LightGrey = Table05Entry08Colors.obj1LightGrey;\n            Colors.obj1DarkGrey = Table05Entry08Colors.obj1DarkGrey;\n            Colors.obj1Black = Table05Entry08Colors.obj1Black;\n            break;\n        case 0xc9:\n            Colors.bgWhite = Table05Entry09Colors.bgWhite;\n            Colors.bgLightGrey = Table05Entry09Colors.bgLightGrey;\n            Colors.bgDarkGrey = Table05Entry09Colors.bgDarkGrey;\n            Colors.bgBlack = Table05Entry09Colors.bgBlack;\n            Colors.obj0White = Table05Entry09Colors.obj0White;\n            Colors.obj0LightGrey = Table05Entry09Colors.obj0LightGrey;\n            Colors.obj0DarkGrey = Table05Entry09Colors.obj0DarkGrey;\n            Colors.obj0Black = Table05Entry09Colors.obj0Black;\n            Colors.obj1White = Table05Entry09Colors.obj1White;\n            Colors.obj1LightGrey = Table05Entry09Colors.obj1LightGrey;\n            Colors.obj1DarkGrey = Table05Entry09Colors.obj1DarkGrey;\n            Colors.obj1Black = Table05Entry09Colors.obj1Black;\n            break;\n        case 0x70:\n            Colors.bgWhite = Table05Entry11Colors.bgWhite;\n            Colors.bgLightGrey = Table05Entry11Colors.bgLightGrey;\n            Colors.bgDarkGrey = Table05Entry11Colors.bgDarkGrey;\n            Colors.bgBlack = Table05Entry11Colors.bgBlack;\n            Colors.obj0White = Table05Entry11Colors.obj0White;\n            Colors.obj0LightGrey = Table05Entry11Colors.obj0LightGrey;\n            Colors.obj0DarkGrey = Table05Entry11Colors.obj0DarkGrey;\n            Colors.obj0Black = Table05Entry11Colors.obj0Black;\n            Colors.obj1White = Table05Entry11Colors.obj1White;\n            Colors.obj1LightGrey = Table05Entry11Colors.obj1LightGrey;\n            Colors.obj1DarkGrey = Table05Entry11Colors.obj1DarkGrey;\n            Colors.obj1Black = Table05Entry11Colors.obj1Black;\n            break;\n        case 0x46:\n            Colors.bgWhite = Table05Entry14Colors.bgWhite;\n            Colors.bgLightGrey = Table05Entry14Colors.bgLightGrey;\n            Colors.bgDarkGrey = Table05Entry14Colors.bgDarkGrey;\n            Colors.bgBlack = Table05Entry14Colors.bgBlack;\n            Colors.obj0White = Table05Entry14Colors.obj0White;\n            Colors.obj0LightGrey = Table05Entry14Colors.obj0LightGrey;\n            Colors.obj0DarkGrey = Table05Entry14Colors.obj0DarkGrey;\n            Colors.obj0Black = Table05Entry14Colors.obj0Black;\n            Colors.obj1White = Table05Entry14Colors.obj1White;\n            Colors.obj1LightGrey = Table05Entry14Colors.obj1LightGrey;\n            Colors.obj1DarkGrey = Table05Entry14Colors.obj1DarkGrey;\n            Colors.obj1Black = Table05Entry14Colors.obj1Black;\n            break;\n        case 0xd3:\n            Colors.bgWhite = Table05Entry15Colors.bgWhite;\n            Colors.bgLightGrey = Table05Entry15Colors.bgLightGrey;\n            Colors.bgDarkGrey = Table05Entry15Colors.bgDarkGrey;\n            Colors.bgBlack = Table05Entry15Colors.bgBlack;\n            Colors.obj0White = Table05Entry15Colors.obj0White;\n            Colors.obj0LightGrey = Table05Entry15Colors.obj0LightGrey;\n            Colors.obj0DarkGrey = Table05Entry15Colors.obj0DarkGrey;\n            Colors.obj0Black = Table05Entry15Colors.obj0Black;\n            Colors.obj1White = Table05Entry15Colors.obj1White;\n            Colors.obj1LightGrey = Table05Entry15Colors.obj1LightGrey;\n            Colors.obj1DarkGrey = Table05Entry15Colors.obj1DarkGrey;\n            Colors.obj1Black = Table05Entry15Colors.obj1Black;\n            break;\n    }\n}\n\n// Grouped registers\n// possible overload these later to performace actions\n// AF, BC, DE, HL\nfunction concatenateBytes(highByte, lowByte) {\n    //https://stackoverflow.com/questions/38298412/convert-two-bytes-into-signed-16-bit-integer-in-javascript\n    return ((highByte & 0xff) << 8) | (lowByte & 0xff);\n}\nfunction splitHighByte(groupedByte) {\n    return (groupedByte & 0xff00) >> 8;\n}\nfunction splitLowByte(groupedByte) {\n    return groupedByte & 0x00ff;\n}\nfunction rotateByteLeft(value) {\n    // Rotate left\n    // https://stackoverflow.com/questions/19204750/how-do-i-perform-a-circular-rotation-of-a-byte\n    // 4-bit example:\n    // 1010 -> 0100 | 0001\n    return u8Portable((value << 1) | (value >> 7));\n}\nfunction rotateByteLeftThroughCarry(value) {\n    // Example: https://github.com/nakardo/node-gameboy/blob/master/lib/cpu/opcodes.js\n    // Through carry meaning, instead of raotating the bit that gets dropped off, but the carry there instead\n    return u8Portable((value << 1) | getCarryFlag$$1());\n}\nfunction rotateByteRight(value) {\n    // Rotate right\n    // 4-bit example:\n    // 1010 -> 0101 | 0000\n    return u8Portable((value >> 1) | (value << 7));\n}\nfunction rotateByteRightThroughCarry(value) {\n    // Example: https://github.com/nakardo/node-gameboy/blob/master/lib/cpu/opcodes.js\n    // Through carry meaning, instead of raotating the bit that gets dropped off, put the carry there instead\n    return u8Portable((value >> 1) | (getCarryFlag$$1() << 7));\n}\nfunction setBitOnByte(bitPosition, byte) {\n    return byte | (0x01 << bitPosition);\n}\nfunction resetBitOnByte(bitPosition, byte) {\n    return byte & ~(0x01 << bitPosition);\n}\nfunction checkBitOnByte(bitPosition, byte) {\n    // Perforamnce improvements\n    // https://github.com/AssemblyScript/assemblyscript/issues/40\n    return (byte & (1 << bitPosition)) != 0;\n}\n\n// Class for GBC Color palletes\n// http://gbdev.gg8.se/wiki/articles/Video_Display#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index\nvar Palette = /** @class */ (function () {\n    function Palette() {\n    }\n    Palette.memoryLocationBackgroundPaletteIndex = 0xff68;\n    Palette.memoryLocationBackgroundPaletteData = 0xff69;\n    Palette.memoryLocationSpritePaletteIndex = 0xff6a;\n    Palette.memoryLocationSpritePaletteData = 0xff6b;\n    // Palettes\n    Palette.memoryLocationBackgroundPalette = 0xff47;\n    Palette.memoryLocationSpritePaletteOne = 0xff48;\n    Palette.memoryLocationSpritePaletteTwo = 0xff49;\n    return Palette;\n}());\n// Inlined because closure compiler inlines\nfunction initializePalette() {\n    if (Cpu.GBCEnabled) {\n        // GBC Palettes\n        eightBitStoreIntoGBMemory(0xff68, 0xc0);\n        eightBitStoreIntoGBMemory(0xff69, 0xff);\n        eightBitStoreIntoGBMemory(0xff6a, 0xc1);\n        eightBitStoreIntoGBMemory(0xff6b, 0x0d);\n    }\n    else {\n        // GBC Palettes\n        eightBitStoreIntoGBMemory(0xff68, 0xff);\n        eightBitStoreIntoGBMemory(0xff69, 0xff);\n        eightBitStoreIntoGBMemory(0xff6a, 0xff);\n        eightBitStoreIntoGBMemory(0xff6b, 0xff);\n    }\n    // Override some values if using the bootrom\n    if (Cpu.BootROMEnabled && Cpu.GBCEnabled) {\n        // GBC Palettes\n        eightBitStoreIntoGBMemory(0xff69, 0x20);\n        eightBitStoreIntoGBMemory(0xff6b, 0x8a);\n    }\n}\n// Simple get pallete color or monochrome GB\n// shouldRepresentColorByColorId is good for debugging tile data for GBC games that don't have\n// monochromePalettes\n// Inlined because closure compiler inlines\nfunction getMonochromeColorFromPalette(colorId, paletteMemoryLocation, shouldRepresentColorByColorId) {\n    if (shouldRepresentColorByColorId === void 0) { shouldRepresentColorByColorId = false; }\n    // Shift our paletteByte, 2 times for each color ID\n    // And off any extra bytes\n    // Return our Color (00 - white, 01 - light grey, 10 Dark grey, or 11 - Black)\n    var color = colorId;\n    if (!shouldRepresentColorByColorId) {\n        color = (eightBitLoadFromGBMemory(paletteMemoryLocation) >> (colorId << 1)) & 0x03;\n    }\n    // Since our max is 254, and max is 3.\n    // monochrome color palette is modified from bgb\n    // TODO: Make these colors into a constant\n    var rgbColor = 242;\n    switch (color) {\n        case 0:\n            break;\n        case 1:\n            rgbColor = 160;\n            break;\n        case 2:\n            rgbColor = 88;\n            break;\n        case 3:\n            rgbColor = 8;\n            break;\n    }\n    return rgbColor;\n}\n// Function to returns the Colorized color for a GB games\nfunction getColorizedGbHexColorFromPalette(colorId, paletteMemoryLocation) {\n    // Shift our paletteByte, 2 times for each color ID\n    // And off any extra bytes\n    // Return our Color (00 - white, 01 - light grey, 10 Dark grey, or 11 - Black)\n    var color = (eightBitLoadFromGBMemory(paletteMemoryLocation) >> (colorId * 2)) & 0x03;\n    // Check which palette we got, to apply the right color layer\n    var hexColor = 0;\n    if (paletteMemoryLocation === Palette.memoryLocationSpritePaletteOne) {\n        hexColor = Colors.obj0White;\n        switch (color) {\n            case 0:\n                break;\n            case 1:\n                hexColor = Colors.obj0LightGrey;\n                break;\n            case 2:\n                hexColor = Colors.obj0DarkGrey;\n                break;\n            case 3:\n                hexColor = Colors.obj0Black;\n                break;\n        }\n    }\n    else if (paletteMemoryLocation === Palette.memoryLocationSpritePaletteTwo) {\n        hexColor = Colors.obj1White;\n        switch (color) {\n            case 0:\n                break;\n            case 1:\n                hexColor = Colors.obj1LightGrey;\n                break;\n            case 2:\n                hexColor = Colors.obj1DarkGrey;\n                break;\n            case 3:\n                hexColor = Colors.obj1Black;\n                break;\n        }\n    }\n    else {\n        hexColor = Colors.bgWhite;\n        switch (color) {\n            case 0:\n                break;\n            case 1:\n                hexColor = Colors.bgLightGrey;\n                break;\n            case 2:\n                hexColor = Colors.bgDarkGrey;\n                break;\n            case 3:\n                hexColor = Colors.bgBlack;\n                break;\n        }\n    }\n    return hexColor;\n}\n// Inlined because closure compiler inlines\nfunction writeColorPaletteToMemory(offset, value) {\n    // FF68\n    //  Bit 0-5   Index (00-3F)\n    var memoryLocationSpritePaletteData = Palette.memoryLocationSpritePaletteData;\n    if (offset === Palette.memoryLocationBackgroundPaletteData || offset === memoryLocationSpritePaletteData) {\n        // Get the palette index\n        var paletteIndex = eightBitLoadFromGBMemory(offset - 1);\n        // Clear the 6th bit, as it does nothing\n        paletteIndex = resetBitOnByte(6, paletteIndex);\n        // Check if we are changing the sprite pallete data\n        var isSprite = offset === memoryLocationSpritePaletteData;\n        storePaletteByteInWasmMemory(paletteIndex, value, isSprite);\n        incrementPaletteIndexIfSet(paletteIndex, offset - 1);\n    }\n}\n// Functions to Handle Write to pallete data registers\n// http://gbdev.gg8.se/wiki/articles/Video_Display#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index\n// Function to handle incrementing the pallete index if required\n// Inlined because closure compiler inlines\nfunction incrementPaletteIndexIfSet(paletteIndex, offset) {\n    // Check ther auto increment box\n    if (checkBitOnByte(7, paletteIndex)) {\n        // Increment the index, and return the value before the increment\n        // Ensure we don't ouverflow our auto increment bit\n        paletteIndex += 1;\n        paletteIndex = setBitOnByte(7, paletteIndex);\n        eightBitStoreIntoGBMemory(offset, paletteIndex);\n    }\n}\n// FF68\n// Bit 0-5   Index (00-3F)\n// Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)\n// Index is 00-0x3F because the means 0 - 63 (64),\n// and apparently there are 8 bytes per pallete to describe Color 0-3 (4 colors),\n// and 0-7 (8 palltetes). Therefore, 64!\nfunction getRgbColorFromPalette(paletteId, colorId, isSprite) {\n    // Each Pallete takes 8 bytes, so multiply by 8 to get the pallete\n    // And Each color takes 2 bytes, therefore, multiple by 2 for the correct color bytes in the palette\n    var paletteIndex = paletteId * 8 + colorId * 2;\n    // Load the Color that is seperated into two bytes\n    var paletteHighByte = loadPaletteByteFromWasmMemory(paletteIndex + 1, isSprite);\n    var paletteLowByte = loadPaletteByteFromWasmMemory(paletteIndex, isSprite);\n    // Return the concatenated color byte\n    return concatenateBytes(paletteHighByte, paletteLowByte);\n}\n// Function to return the color from a passed 16 bit color pallette\nfunction getColorComponentFromRgb(colorId, colorRgb) {\n    // Get our bitmask for the color ID\n    // bit mask tested good :)\n    colorId *= 5;\n    var bitMask = 0x1f << colorId;\n    var colorValue = (colorRgb & bitMask) >> colorId;\n    // Goal is to reach 254 for each color, so 255 / 31 (0x1F) ~8 TODO: Make exact\n    // Want 5 bits for each\n    return colorValue * 8;\n}\n// Function to load a byte from our Gbc Palette memory\nfunction loadPaletteByteFromWasmMemory(paletteIndexByte, isSprite) {\n    // Clear the top two bits to just get the bottom palette Index\n    var paletteIndex = paletteIndexByte & 0x3f;\n    // Move over the palette index to not overlap the background has 0x3F, so Zero for Sprites is 0x40)\n    if (isSprite) {\n        paletteIndex += 0x40;\n    }\n    return load(GBC_PALETTE_LOCATION + paletteIndex);\n}\n// Function to store a byte to our Gbc Palette memory\n// Inlined because closure compiler inlines\nfunction storePaletteByteInWasmMemory(paletteIndexByte, value, isSprite) {\n    // Clear the top two bits to just get the bottom palette Index\n    var paletteIndex = paletteIndexByte & 0x3f;\n    // Move over the palette index to not overlap the background (has 0x3F, so Zero for Sprites is 0x40)\n    if (isSprite) {\n        paletteIndex += 0x40;\n    }\n    store(GBC_PALETTE_LOCATION + paletteIndex, value);\n}\n\n// https://github.com/torch2424/wasmBoy/issues/51\nfunction addPriorityforPixel(x, y, colorId, hasGbcBgPriority) {\n    if (colorId === void 0) { colorId = 0; }\n    if (hasGbcBgPriority === void 0) { hasGbcBgPriority = false; }\n    var bgPriorityByte = colorId & 0x03;\n    if (hasGbcBgPriority) {\n        bgPriorityByte = setBitOnByte(2, bgPriorityByte);\n    }\n    store(BG_PRIORITY_MAP_LOCATION + getPixelStart(x, y), bgPriorityByte);\n}\n// Inlined because closure compiler inlines\nfunction getPriorityforPixel(x, y) {\n    return load(BG_PRIORITY_MAP_LOCATION + getPixelStart(x, y));\n}\n// Inlined because closure compiler inlines\nfunction clearPriorityMap() {\n    for (var y = 0; y < 144; ++y) {\n        for (var x = 0; x < 160; ++x) {\n            store(BG_PRIORITY_MAP_LOCATION + getPixelStart(x, y), 0);\n        }\n    }\n}\n// Inlined because closure compiler inlines\nfunction getPixelStart(x, y) {\n    // Get the pixel number\n    return y * 160 + x;\n}\n\n// Functions for performance hacks, and debugging tiles\nvar TileCache = /** @class */ (function () {\n    function TileCache() {\n    }\n    TileCache.tileId = -1;\n    TileCache.horizontalFlip = false;\n    TileCache.nextXIndexToPerformCacheCheck = -1;\n    return TileCache;\n}());\n// Inlined because closure compiler inlines\nfunction resetTileCache() {\n    TileCache.tileId = -1;\n    TileCache.nextXIndexToPerformCacheCheck = -1;\n}\nfunction drawPixelsFromLineOfTile(tileId, tileDataMemoryLocation, vramBankId, tileLineXStart, tileLineXEnd, tileLineY, outputLineX, outputLineY, outputWidth, wasmMemoryStart, shouldRepresentMonochromeColorByColorId, paletteLocation, bgMapAttributes, spriteAttributes) {\n    // Get our number of pixels drawn\n    var pixelsDrawn = 0;\n    // Get our tile data address\n    var tileDataAddress = getTileDataAddress(tileDataMemoryLocation, tileId);\n    // Get the bytes for our tile\n    var byteOneForLineOfTilePixels = loadFromVramBank(tileDataAddress + tileLineY * 2, vramBankId);\n    var byteTwoForLineOfTilePixels = loadFromVramBank(tileDataAddress + tileLineY * 2 + 1, vramBankId);\n    // Loop through our X values to draw\n    for (var x = tileLineXStart; x <= tileLineXEnd; ++x) {\n        // First find where we are going to do our final output x\n        // And don't allow any width overflow\n        var iteratedOutputX = outputLineX + (x - tileLineXStart);\n        if (iteratedOutputX < outputWidth) {\n            // However, We need to reverse our byte (if not horizontally flipped),\n            // As pixel 0 is on byte 7, and pixel 1 is on byte 6, etc...\n            // Therefore, is pixelX was 2, then really is need to be 5\n            // So 2 - 7 = -5, * 1 = 5\n            // Or to simplify, 7 - 2 = 5 haha!\n            var pixelXInTile = x;\n            if (bgMapAttributes < 0 || !checkBitOnByte(5, bgMapAttributes)) {\n                pixelXInTile = 7 - pixelXInTile;\n            }\n            // Get our pallete colors for the tile\n            var paletteColorId = 0;\n            if (checkBitOnByte(pixelXInTile, byteTwoForLineOfTilePixels)) {\n                // Byte one represents the second bit in our color id, so bit shift\n                paletteColorId += 1;\n                paletteColorId = paletteColorId << 1;\n            }\n            if (checkBitOnByte(pixelXInTile, byteOneForLineOfTilePixels)) {\n                paletteColorId += 1;\n            }\n            // Get the pallete\n            var red = 0;\n            var green = 0;\n            var blue = 0;\n            // Check if we should draw color or not\n            if (Cpu.GBCEnabled && (bgMapAttributes >= 0 || spriteAttributes >= 0)) {\n                // Draw C O L O R\n                var isSprite = spriteAttributes >= 0;\n                // Call the helper function to grab the correct color from the palette\n                // Get the palette index byte\n                var bgPalette = bgMapAttributes & 0x07;\n                if (isSprite) {\n                    bgPalette = spriteAttributes & 0x07;\n                }\n                var rgbColorPalette = getRgbColorFromPalette(bgPalette, paletteColorId, isSprite);\n                // Split off into red green and blue\n                red = getColorComponentFromRgb(0, rgbColorPalette);\n                green = getColorComponentFromRgb(1, rgbColorPalette);\n                blue = getColorComponentFromRgb(2, rgbColorPalette);\n            }\n            else {\n                // Draw Monochrome\n                // Get the default palette if none\n                if (paletteLocation <= 0) {\n                    paletteLocation = Graphics.memoryLocationBackgroundPalette;\n                }\n                if (shouldRepresentMonochromeColorByColorId) {\n                    var monochromeColor = getMonochromeColorFromPalette(paletteColorId, paletteLocation, shouldRepresentMonochromeColorByColorId);\n                    red = monochromeColor;\n                    green = monochromeColor;\n                    blue = monochromeColor;\n                }\n                else {\n                    var hexColor = getColorizedGbHexColorFromPalette(paletteColorId, paletteLocation);\n                    red = getRedFromHexColor(hexColor);\n                    green = getGreenFromHexColor(hexColor);\n                    blue = getBlueFromHexColor(hexColor);\n                }\n            }\n            // Finally Lets place a pixel in memory\n            // Find where our tile line would start\n            var pixelStart = getTilePixelStart(iteratedOutputX, outputLineY, outputWidth);\n            // Can not optimize wasmMemoryStart any further, as this is in a loop.\n            store(wasmMemoryStart + pixelStart + 0, red);\n            store(wasmMemoryStart + pixelStart + 1, green);\n            store(wasmMemoryStart + pixelStart + 2, blue);\n            var gbcBgPriority = false;\n            if (bgMapAttributes >= 0) {\n                gbcBgPriority = checkBitOnByte(7, bgMapAttributes);\n            }\n            // Lastly, add the pixel to our background priority map\n            // https://github.com/torch2424/wasmBoy/issues/51\n            // Bits 0 & 1 will represent the color Id drawn by the BG/Window\n            // Bit 2 will represent if the Bg/Window has GBC priority.\n            addPriorityforPixel(iteratedOutputX, outputLineY, paletteColorId, gbcBgPriority);\n            pixelsDrawn++;\n        }\n    }\n    return pixelsDrawn;\n}\n// Inlined because closure compiler inlines\nfunction getTilePixelStart(outputLineX, outputLineY, outputWidth) {\n    // Finally Lets place a pixel in memory\n    var pixelStart = outputLineY * outputWidth + outputLineX;\n    // Each pixel takes 3 slots, therefore, multiply by 3!\n    return pixelStart * 3;\n}\nfunction getTileDataAddress(tileDataMemoryLocation, tileIdFromTileMap) {\n    // Watch this part of The ultimate gameboy talk: https://youtu.be/HyzD8pNlpwI?t=30m50s\n    // A line of 8 pixels on a single tile, is represented by 2 bytes.\n    // since a single tile is 8x8 pixels, 8 * 2 = 16 bytes\n    // Get the tile ID's tile addess from tile data.\n    // For instance, let's say our first line of tile data represents tiles for letters:\n    // a b c d e f g\n    // And we have tileId 0x02. That means we want the tile for the 'c' character\n    // Since each tile is 16 bytes, it would be the starting tileDataAddress + (tileId * tileSize), to skip over tiles we dont want\n    // The whole signed thing is weird, and has something to do how the second set of tile data is stored :p\n    if (tileDataMemoryLocation === Graphics.memoryLocationTileDataSelectZeroStart) {\n        // Treat the tile Id as a signed int, subtract an offset of 128\n        // if the tileId was 0 then the tile would be in memory region 0x9000-0x900F\n        if (checkBitOnByte(7, tileIdFromTileMap)) {\n            tileIdFromTileMap -= 128;\n        }\n        else {\n            tileIdFromTileMap += 128;\n        }\n    }\n    // if the background layout gave us the tileId 0, then the tile data would be between 0x8000-0x800F.\n    return tileDataMemoryLocation + tileIdFromTileMap * 16;\n}\n\n// Functions to help with Handling Duty on Square Channels\n// Since there are no 2d arrays, we will use a byte to represent duty cycles (wave form from percentages)\nfunction isDutyCycleClockPositiveOrNegativeForWaveform(channelDuty, waveFormPositionOnDuty) {\n    // Get our Wave Form According to the Duty\n    // Default to a duty of 1\n    // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Square_Wave\n    switch (channelDuty) {\n        case 0x01:\n            // 1000 0001\n            return checkBitOnByte(waveFormPositionOnDuty, 0x81);\n        case 0x02:\n            // 1000 0111\n            return checkBitOnByte(waveFormPositionOnDuty, 0x87);\n        case 0x03:\n            // 0111 1110\n            return checkBitOnByte(waveFormPositionOnDuty, 0x7e);\n        default:\n            // 0000 0001\n            return checkBitOnByte(waveFormPositionOnDuty, 0x01);\n    }\n}\n\n// NOTE: Tons of Copy-pasta btween channels, because Classes cannot be instantiated yet in assemblyscript\nvar Channel1 = /** @class */ (function () {\n    function Channel1() {\n    }\n    Channel1.updateNRx0 = function (value) {\n        var oldSweepNegate = Channel1.NRx0Negate;\n        Channel1.NRx0SweepPeriod = (value & 0x70) >> 4;\n        Channel1.NRx0Negate = checkBitOnByte(3, value);\n        Channel1.NRx0SweepShift = value & 0x07;\n        // Obscure Behavior\n        // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware\n        // Clearing the sweep negate mode bit in NR10 after at least one sweep calculation has been made,\n        // using the negate mode since the last trigger causes the channel to be immediately disabled.\n        // This prevents you from having the sweep lower the frequency then raise the frequency without a trigger inbetween.\n        if (oldSweepNegate && !Channel1.NRx0Negate && Channel1.sweepNegateShouldDisableChannelOnClear) {\n            Channel1.isEnabled = false;\n        }\n    };\n    Channel1.updateNRx1 = function (value) {\n        Channel1.NRx1Duty = (value >> 6) & 0x03;\n        Channel1.NRx1LengthLoad = value & 0x3f;\n        // Also need to set our length counter. Taken from the old, setChannelLengthCounter\n        // Channel length is determined by 64 (or 256 if channel 3), - the length load\n        // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Registers\n        // Note, this will be different for channel 3\n        Channel1.lengthCounter = Channel1.MAX_LENGTH - Channel1.NRx1LengthLoad;\n    };\n    Channel1.updateNRx2 = function (value) {\n        // Handle \"Zombie Mode\" Obscure behavior\n        // https://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Obscure_Behavior\n        if (Channel1.isEnabled) {\n            // If the old envelope period was zero and the envelope is still doing automatic updates,\n            // volume is incremented by 1, otherwise if the envelope was in subtract mode,\n            // volume is incremented by 2.\n            // NOTE: However, from my testing, it ALWAYS increments by one. This was determined\n            // by my testing for prehistoric man\n            if (Channel1.NRx2EnvelopePeriod === 0 && Channel1.isEnvelopeAutomaticUpdating) {\n                // Volume can't be more than 4 bits\n                Channel1.volume = (Channel1.volume + 1) & 0x0f;\n            }\n            // If the mode was changed (add to subtract or subtract to add),\n            // volume is set to 16-volume. But volume cant be more than 4 bits\n            if (Channel1.NRx2EnvelopeAddMode !== checkBitOnByte(3, value)) {\n                Channel1.volume = (16 - Channel1.volume) & 0x0f;\n            }\n        }\n        // Handle the regular write\n        Channel1.NRx2StartingVolume = (value >> 4) & 0x0f;\n        Channel1.NRx2EnvelopeAddMode = checkBitOnByte(3, value);\n        Channel1.NRx2EnvelopePeriod = value & 0x07;\n        // Also, get our channel is dac enabled\n        var isDacEnabled = (value & 0xf8) > 0;\n        Channel1.isDacEnabled = isDacEnabled;\n        // Blargg length test\n        // Disabling DAC should disable channel immediately\n        if (!isDacEnabled) {\n            Channel1.isEnabled = false;\n        }\n    };\n    Channel1.updateNRx3 = function (value) {\n        Channel1.NRx3FrequencyLSB = value;\n        // Update Channel Frequency\n        Channel1.frequency = (Channel1.NRx4FrequencyMSB << 8) | value;\n    };\n    // NOTE: Order in which these events happen are very particular\n    // And globals can be affected by other functions\n    // Thus, optimizations here should be extremely careful\n    Channel1.updateNRx4 = function (value) {\n        // Handle our Channel frequency first\n        // As this is modified if we trigger for length.\n        var frequencyMSB = value & 0x07;\n        Channel1.NRx4FrequencyMSB = frequencyMSB;\n        Channel1.frequency = (frequencyMSB << 8) | Channel1.NRx3FrequencyLSB;\n        // Obscure behavior\n        // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Obscure_Behavior\n        // Also see blargg's cgb sound test\n        // Extra length clocking occurs when writing to NRx4,\n        // when the frame sequencer's next step is one that,\n        // doesn't clock the length counter.\n        var frameSequencer = Sound.frameSequencer;\n        var doesNextFrameSequencerUpdateLength = (frameSequencer & 1) === 1;\n        var isBeingLengthEnabled = !Channel1.NRx4LengthEnabled && checkBitOnByte(6, value);\n        if (!doesNextFrameSequencerUpdateLength) {\n            // Check lengthEnable\n            if (Channel1.lengthCounter > 0 && isBeingLengthEnabled) {\n                Channel1.lengthCounter -= 1;\n                if (!checkBitOnByte(7, value) && Channel1.lengthCounter === 0) {\n                    Channel1.isEnabled = false;\n                }\n            }\n        }\n        // Set the length enabled from the value\n        Channel1.NRx4LengthEnabled = checkBitOnByte(6, value);\n        // Trigger out channel, unfreeze length if frozen\n        // Triggers should happen after obscure behavior\n        // See test 11 for trigger\n        if (checkBitOnByte(7, value)) {\n            Channel1.trigger();\n            // When we trigger on the obscure behavior, and we reset the length Counter to max\n            // We need to clock\n            if (!doesNextFrameSequencerUpdateLength && Channel1.lengthCounter === Channel1.MAX_LENGTH && Channel1.NRx4LengthEnabled) {\n                Channel1.lengthCounter -= 1;\n            }\n        }\n    };\n    // Function to save the state of the class\n    Channel1.saveState = function () {\n        // Cycle Counter\n        store(getSaveStateMemoryOffset(0x00, Channel1.saveStateSlot), Channel1.cycleCounter);\n        // NRx0\n        store(getSaveStateMemoryOffset(0x04, Channel1.saveStateSlot), Channel1.NRx0SweepPeriod);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x05, Channel1.saveStateSlot), Channel1.NRx0Negate);\n        store(getSaveStateMemoryOffset(0x06, Channel1.saveStateSlot), Channel1.NRx0SweepShift);\n        // NRx1\n        store(getSaveStateMemoryOffset(0x07, Channel1.saveStateSlot), Channel1.NRx1Duty);\n        store(getSaveStateMemoryOffset(0x09, Channel1.saveStateSlot), Channel1.NRx1LengthLoad);\n        // NRx2\n        store(getSaveStateMemoryOffset(0x0a, Channel1.saveStateSlot), Channel1.NRx2StartingVolume);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0b, Channel1.saveStateSlot), Channel1.NRx2EnvelopeAddMode);\n        store(getSaveStateMemoryOffset(0x0c, Channel1.saveStateSlot), Channel1.NRx2EnvelopePeriod);\n        // NRx3\n        store(getSaveStateMemoryOffset(0x0d, Channel1.saveStateSlot), Channel1.NRx3FrequencyLSB);\n        // NRx4\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0e, Channel1.saveStateSlot), Channel1.NRx4LengthEnabled);\n        store(getSaveStateMemoryOffset(0x0f, Channel1.saveStateSlot), Channel1.NRx4FrequencyMSB);\n        // Channel Properties\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x10, Channel1.saveStateSlot), Channel1.isEnabled);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x11, Channel1.saveStateSlot), Channel1.isDacEnabled);\n        store(getSaveStateMemoryOffset(0x12, Channel1.saveStateSlot), Channel1.frequency);\n        store(getSaveStateMemoryOffset(0x16, Channel1.saveStateSlot), Channel1.frequencyTimer);\n        store(getSaveStateMemoryOffset(0x1a, Channel1.saveStateSlot), Channel1.envelopeCounter);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x1e, Channel1.saveStateSlot), Channel1.isEnvelopeAutomaticUpdating);\n        store(getSaveStateMemoryOffset(0x1f, Channel1.saveStateSlot), Channel1.lengthCounter);\n        store(getSaveStateMemoryOffset(0x23, Channel1.saveStateSlot), Channel1.volume);\n        // Square Duty\n        store(getSaveStateMemoryOffset(0x27, Channel1.saveStateSlot), Channel1.dutyCycle);\n        store(getSaveStateMemoryOffset(0x28, Channel1.saveStateSlot), Channel1.waveFormPositionOnDuty);\n        // Square Sweep\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x29, Channel1.saveStateSlot), Channel1.isSweepEnabled);\n        store(getSaveStateMemoryOffset(0x2a, Channel1.saveStateSlot), Channel1.sweepCounter);\n        store(getSaveStateMemoryOffset(0x2e, Channel1.saveStateSlot), Channel1.sweepShadowFrequency);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x31, Channel1.saveStateSlot), Channel1.sweepNegateShouldDisableChannelOnClear);\n    };\n    // Function to load the save state from memory\n    Channel1.loadState = function () {\n        // Cycle Counter\n        Channel1.cycleCounter = load(getSaveStateMemoryOffset(0x00, Channel1.cycleCounter));\n        // NRx0\n        Channel1.NRx0SweepPeriod = load(getSaveStateMemoryOffset(0x04, Channel1.saveStateSlot));\n        Channel1.NRx0Negate = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x05, Channel1.saveStateSlot));\n        Channel1.NRx0SweepShift = load(getSaveStateMemoryOffset(0x06, Channel1.saveStateSlot));\n        // NRx1\n        Channel1.NRx1Duty = load(getSaveStateMemoryOffset(0x07, Channel1.saveStateSlot));\n        Channel1.NRx1LengthLoad = load(getSaveStateMemoryOffset(0x09, Channel1.saveStateSlot));\n        // NRx2\n        Channel1.NRx2StartingVolume = load(getSaveStateMemoryOffset(0x0a, Channel1.saveStateSlot));\n        Channel1.NRx2EnvelopeAddMode = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0b, Channel1.saveStateSlot));\n        Channel1.NRx2EnvelopePeriod = load(getSaveStateMemoryOffset(0x0c, Channel1.saveStateSlot));\n        // NRx3\n        Channel1.NRx3FrequencyLSB = load(getSaveStateMemoryOffset(0x0d, Channel1.saveStateSlot));\n        // NRx4\n        Channel1.NRx4LengthEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0e, Channel1.saveStateSlot));\n        Channel1.NRx4FrequencyMSB = load(getSaveStateMemoryOffset(0x0f, Channel1.saveStateSlot));\n        // Channel Properties\n        Channel1.isEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x10, Channel1.saveStateSlot));\n        Channel1.isDacEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x11, Channel1.saveStateSlot));\n        Channel1.frequency = load(getSaveStateMemoryOffset(0x12, Channel1.saveStateSlot));\n        Channel1.frequencyTimer = load(getSaveStateMemoryOffset(0x16, Channel1.saveStateSlot));\n        Channel1.envelopeCounter = load(getSaveStateMemoryOffset(0x1a, Channel1.saveStateSlot));\n        Channel1.isEnvelopeAutomaticUpdating = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x1e, Channel1.saveStateSlot));\n        Channel1.lengthCounter = load(getSaveStateMemoryOffset(0x1f, Channel1.saveStateSlot));\n        Channel1.volume = load(getSaveStateMemoryOffset(0x23, Channel1.saveStateSlot));\n        // Square Duty\n        Channel1.dutyCycle = load(getSaveStateMemoryOffset(0x27, Channel1.saveStateSlot));\n        Channel1.waveFormPositionOnDuty = load(getSaveStateMemoryOffset(0x28, Channel1.saveStateSlot));\n        // Square Sweep\n        Channel1.isSweepEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x29, Channel1.saveStateSlot));\n        Channel1.sweepCounter = load(getSaveStateMemoryOffset(0x2a, Channel1.saveStateSlot));\n        Channel1.sweepShadowFrequency = load(getSaveStateMemoryOffset(0x2e, Channel1.saveStateSlot));\n        Channel1.sweepNegateShouldDisableChannelOnClear = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x31, Channel1.saveStateSlot));\n    };\n    Channel1.initialize = function () {\n        eightBitStoreIntoGBMemory(Channel1.memoryLocationNRx0, 0x80);\n        eightBitStoreIntoGBMemory(Channel1.memoryLocationNRx1, 0xbf);\n        eightBitStoreIntoGBMemory(Channel1.memoryLocationNRx2, 0xf3);\n        eightBitStoreIntoGBMemory(Channel1.memoryLocationNRx3, 0xc1);\n        eightBitStoreIntoGBMemory(Channel1.memoryLocationNRx4, 0xbf);\n        // Override/reset some variables if the boot ROM is enabled\n        // For GBC and GB\n        if (Cpu.BootROMEnabled) {\n            eightBitStoreIntoGBMemory(Channel1.memoryLocationNRx1, 0x3f);\n            eightBitStoreIntoGBMemory(Channel1.memoryLocationNRx2, 0x00);\n            eightBitStoreIntoGBMemory(Channel1.memoryLocationNRx3, 0x00);\n            eightBitStoreIntoGBMemory(Channel1.memoryLocationNRx4, 0xb8);\n        }\n    };\n    // Function to get a sample using the cycle counter on the channel\n    Channel1.getSampleFromCycleCounter = function () {\n        var accumulatedCycles = Channel1.cycleCounter;\n        Channel1.cycleCounter = 0;\n        return Channel1.getSample(accumulatedCycles);\n    };\n    // Function to reset our timer, useful for GBC double speed mode\n    Channel1.resetTimer = function () {\n        var frequencyTimer = (2048 - Channel1.frequency) << 2;\n        // TODO: Ensure this is correct for GBC Double Speed Mode\n        if (Cpu.GBCDoubleSpeed) {\n            frequencyTimer = frequencyTimer << 2;\n        }\n        Channel1.frequencyTimer = frequencyTimer;\n    };\n    Channel1.getSample = function (numberOfCycles) {\n        // Decrement our channel timer\n        var frequencyTimer = Channel1.frequencyTimer;\n        frequencyTimer -= numberOfCycles;\n        while (frequencyTimer <= 0) {\n            // Get the amount that overflowed so we don't drop cycles\n            var overflowAmount = abs(frequencyTimer);\n            // Reset our timer\n            // A square channel's frequency timer period is set to (2048-frequency)*4.\n            // Four duty cycles are available, each waveform taking 8 frequency timer clocks to cycle through:\n            Channel1.resetTimer();\n            frequencyTimer = Channel1.frequencyTimer;\n            frequencyTimer -= overflowAmount;\n            // Also increment our duty cycle\n            // What is duty? https://en.wikipedia.org/wiki/Duty_cycle\n            // Duty cycle for square wave: http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Square_Wave\n            Channel1.waveFormPositionOnDuty = (Channel1.waveFormPositionOnDuty + 1) & 7;\n        }\n        Channel1.frequencyTimer = frequencyTimer;\n        // Get our ourput volume\n        var outputVolume = 0;\n        // Finally to set our output volume, the channel must be enabled,\n        // Our channel DAC must be enabled, and we must be in an active state\n        // Of our duty cycle\n        if (Channel1.isEnabled && Channel1.isDacEnabled) {\n            // Volume can't be more than 4 bits.\n            // Volume should never be more than 4 bits, but doing a check here\n            outputVolume = Channel1.volume & 0x0f;\n        }\n        else {\n            // Return silence\n            // Since range from -15 - 15, or 0 to 30 for our unsigned\n            return 15;\n        }\n        // Get the current sampleValue\n        var sample = 1;\n        if (!isDutyCycleClockPositiveOrNegativeForWaveform(Channel1.NRx1Duty, Channel1.waveFormPositionOnDuty)) {\n            sample = -sample;\n        }\n        sample *= outputVolume;\n        // Square Waves Can range from -15 - 15. Therefore simply add 15\n        sample += 15;\n        return sample;\n    };\n    // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Trigger_Event\n    Channel1.trigger = function () {\n        Channel1.isEnabled = true;\n        // Set length to maximum done in write\n        if (Channel1.lengthCounter === 0) {\n            Channel1.lengthCounter = Channel1.MAX_LENGTH;\n        }\n        // Reset our timer\n        // A square channel's frequency timer period is set to (2048-frequency)*4.\n        // Four duty cycles are available, each waveform taking 8 frequency timer clocks to cycle through:\n        Channel1.resetTimer();\n        // The volume envelope and sweep timers treat a period of 0 as 8.\n        // Meaning, if the period is zero, set it to the max (8).\n        if (Channel1.NRx2EnvelopePeriod === 0) {\n            Channel1.envelopeCounter = 8;\n        }\n        else {\n            Channel1.envelopeCounter = Channel1.NRx2EnvelopePeriod;\n        }\n        Channel1.isEnvelopeAutomaticUpdating = true;\n        Channel1.volume = Channel1.NRx2StartingVolume;\n        // Handle Channel Sweep\n        // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware\n        Channel1.sweepShadowFrequency = Channel1.frequency;\n        // Reset back to the sweep period\n        // Obscure behavior\n        // Sweep timers treat a period o 0 as 8\n        if (Channel1.NRx0SweepPeriod === 0) {\n            Channel1.sweepCounter = 8;\n        }\n        else {\n            Channel1.sweepCounter = Channel1.NRx0SweepPeriod;\n        }\n        // The internal enabled flag is set if either the sweep period or shift are non-zero, cleared otherwise.\n        Channel1.isSweepEnabled = Channel1.NRx0SweepPeriod > 0 || Channel1.NRx0SweepShift > 0;\n        Channel1.sweepNegateShouldDisableChannelOnClear = false;\n        // If the sweep shift is non-zero, frequency calculation and the overflow check are performed immediately.\n        // NOTE: The double calculation thing for the sweep does not happen here.\n        if (Channel1.NRx0SweepShift > 0 && didCalculatedSweepOverflow(calculateSweep())) {\n            Channel1.isEnabled = false;\n        }\n        // Finally if DAC is off, channel is still disabled\n        if (!Channel1.isDacEnabled) {\n            Channel1.isEnabled = false;\n        }\n    };\n    // Function to determine if the current channel would update when getting the sample\n    // This is used to accumulate samples\n    Channel1.willChannelUpdate = function (numberOfCycles) {\n        //Increment our cycle counter\n        var cycleCounter = Channel1.cycleCounter + numberOfCycles;\n        Channel1.cycleCounter = cycleCounter;\n        // Dac enabled status cached by accumulator\n        return !(Channel1.frequencyTimer - cycleCounter > 0);\n    };\n    Channel1.updateSweep = function () {\n        // Dont update period if not enabled\n        if (!Channel1.isEnabled || !Channel1.isSweepEnabled) {\n            return;\n        }\n        // Decrement the sweep counter\n        var sweepCounter = Channel1.sweepCounter - 1;\n        if (sweepCounter <= 0) {\n            // Reset back to the sweep period\n            // Obscure behavior\n            // Sweep timers treat a period of 0 as 8 (They reset back to the max)\n            if (Channel1.NRx0SweepPeriod === 0) {\n                // Sweep isn't calculated when the period is 0\n                Channel1.sweepCounter = 8;\n            }\n            else {\n                // Reset our sweep counter to its period\n                Channel1.sweepCounter = Channel1.NRx0SweepPeriod;\n                // Calculate our sweep\n                // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware\n                // When it generates a clock and the sweep's internal enabled flag is set and the sweep period is not zero,\n                // a new frequency is calculated and the overflow check is performed. If the new frequency is 2047 or less,\n                // and the sweep shift is not zero, this new frequency is written back to the shadow frequency,\n                // and square 1's frequency in NR13 and NR14, then frequency calculation,\n                // and overflow check are run AGAIN immediately using this new value,\n                // but this second new frequency is not written back.\n                var newFrequency = calculateSweep();\n                if (didCalculatedSweepOverflow(newFrequency)) {\n                    Channel1.isEnabled = false;\n                }\n                if (Channel1.NRx0SweepShift > 0) {\n                    Channel1.setFrequency(newFrequency);\n                    if (didCalculatedSweepOverflow(calculateSweep())) {\n                        Channel1.isEnabled = false;\n                    }\n                }\n            }\n        }\n        else {\n            Channel1.sweepCounter = sweepCounter;\n        }\n    };\n    Channel1.updateLength = function () {\n        var lengthCounter = Channel1.lengthCounter;\n        if (lengthCounter > 0 && Channel1.NRx4LengthEnabled) {\n            lengthCounter -= 1;\n            if (lengthCounter === 0) {\n                Channel1.isEnabled = false;\n            }\n        }\n        Channel1.lengthCounter = lengthCounter;\n    };\n    Channel1.updateEnvelope = function () {\n        var envelopeCounter = Channel1.envelopeCounter - 1;\n        if (envelopeCounter <= 0) {\n            // Reset back to the sweep period\n            // Obscure behavior\n            // Envelopes treat a period of 0 as 8 (They reset back to the max)\n            if (Channel1.NRx2EnvelopePeriod === 0) {\n                envelopeCounter = 8;\n            }\n            else {\n                envelopeCounter = Channel1.NRx2EnvelopePeriod;\n                // When the timer generates a clock and the envelope period is NOT zero, a new volume is calculated\n                // NOTE: There is some weiirrdd obscure behavior where zero can equal 8, so watch out for that\n                // If notes are sustained for too long, this is probably why\n                if (envelopeCounter !== 0 && Channel1.isEnvelopeAutomaticUpdating) {\n                    var volume = Channel1.volume;\n                    // Increment the volume\n                    if (Channel1.NRx2EnvelopeAddMode) {\n                        volume += 1;\n                    }\n                    else {\n                        volume -= 1;\n                    }\n                    // Don't allow the volume to go above 4 bits.\n                    volume = volume & 0x0f;\n                    // Check if we are below the max\n                    if (volume < 15) {\n                        Channel1.volume = volume;\n                    }\n                    else {\n                        Channel1.isEnvelopeAutomaticUpdating = false;\n                    }\n                }\n            }\n        }\n        Channel1.envelopeCounter = envelopeCounter;\n    };\n    Channel1.setFrequency = function (frequency) {\n        // Set our shadowFrequency\n        Channel1.sweepShadowFrequency = frequency;\n        // Get the high and low bits\n        var passedFrequencyHighBits = (frequency >> 8) & 0x07;\n        var passedFrequencyLowBits = frequency & 0xff;\n        // Get the new register 4\n        var register4 = eightBitLoadFromGBMemory(Channel1.memoryLocationNRx4);\n        // Knock off lower 3 bits, and Or on our high bits\n        var newRegister4 = register4 & 0xf8;\n        newRegister4 = newRegister4 | passedFrequencyHighBits;\n        // Set the registers\n        eightBitStoreIntoGBMemory(Channel1.memoryLocationNRx3, passedFrequencyLowBits);\n        eightBitStoreIntoGBMemory(Channel1.memoryLocationNRx4, newRegister4);\n        // Save the frequency for ourselves without triggering memory traps\n        Channel1.NRx3FrequencyLSB = passedFrequencyLowBits;\n        Channel1.NRx4FrequencyMSB = passedFrequencyHighBits;\n        Channel1.frequency = (Channel1.NRx4FrequencyMSB << 8) | Channel1.NRx3FrequencyLSB;\n    };\n    // Cycle Counter for our sound accumulator\n    Channel1.cycleCounter = 0;\n    // Max Length of our Length Load\n    Channel1.MAX_LENGTH = 64;\n    // Squarewave channel with volume envelope and frequency sweep functions.\n    // NR10 -> Sweep Register R/W\n    Channel1.memoryLocationNRx0 = 0xff10;\n    // -PPP NSSS Sweep period, negate, shift\n    Channel1.NRx0SweepPeriod = 0;\n    Channel1.NRx0Negate = false;\n    Channel1.NRx0SweepShift = 0;\n    // NR11 -> Sound length/Wave pattern duty (R/W)\n    Channel1.memoryLocationNRx1 = 0xff11;\n    // DDLL LLLL Duty, Length load (64-L)\n    Channel1.NRx1Duty = 0;\n    Channel1.NRx1LengthLoad = 0;\n    // NR12 -> Volume Envelope (R/W)\n    Channel1.memoryLocationNRx2 = 0xff12;\n    // VVVV APPP Starting volume, Envelope add mode, period\n    Channel1.NRx2StartingVolume = 0;\n    Channel1.NRx2EnvelopeAddMode = false;\n    Channel1.NRx2EnvelopePeriod = 0;\n    // NR13 -> Frequency lo (W)\n    Channel1.memoryLocationNRx3 = 0xff13;\n    // FFFF FFFF Frequency LSB\n    Channel1.NRx3FrequencyLSB = 0;\n    // NR14 -> Frequency hi (R/W)\n    Channel1.memoryLocationNRx4 = 0xff14;\n    // TL-- -FFF Trigger, Length enable, Frequency MSB\n    Channel1.NRx4LengthEnabled = false;\n    Channel1.NRx4FrequencyMSB = 0;\n    // Channel Properties\n    Channel1.channelNumber = 1;\n    Channel1.isEnabled = false;\n    Channel1.isDacEnabled = false;\n    Channel1.frequency = 0;\n    Channel1.frequencyTimer = 0x00;\n    Channel1.envelopeCounter = 0x00;\n    Channel1.isEnvelopeAutomaticUpdating = false;\n    Channel1.lengthCounter = 0x00;\n    Channel1.volume = 0x00;\n    // Square Wave properties\n    Channel1.dutyCycle = 0x00;\n    Channel1.waveFormPositionOnDuty = 0x00;\n    // Channel 1 Sweep\n    Channel1.isSweepEnabled = false;\n    Channel1.sweepCounter = 0x00;\n    Channel1.sweepShadowFrequency = 0x00;\n    Channel1.sweepNegateShouldDisableChannelOnClear = false;\n    // Save States\n    Channel1.saveStateSlot = 7;\n    return Channel1;\n}());\n// Sweep Specific functions\n// Function to determing a new sweep in the current context\nfunction calculateSweep() {\n    // Start our new frequency, by making it equal to the \"shadow frequency\"\n    var oldFrequency = Channel1.sweepShadowFrequency;\n    var newFrequency = oldFrequency >> Channel1.NRx0SweepShift;\n    // Check for sweep negation\n    if (Channel1.NRx0Negate) {\n        Channel1.sweepNegateShouldDisableChannelOnClear = true;\n        newFrequency = oldFrequency - newFrequency;\n    }\n    else {\n        newFrequency = oldFrequency + newFrequency;\n    }\n    return newFrequency;\n}\n// Function to check if a calculated sweep overflowed\nfunction didCalculatedSweepOverflow(calculatedSweep) {\n    // 7FF is the highest value of the frequency: 111 1111 1111\n    // if it overflows, should disable the channel (handled by the caller)\n    if (calculatedSweep > 0x7ff) {\n        return true;\n    }\n    return false;\n}\n\n// NOTE: Tons of Copy-pasta btween channels, because Classes cannot be instantiated yet in assemblyscript\nvar Channel2 = /** @class */ (function () {\n    function Channel2() {\n    }\n    Channel2.updateNRx1 = function (value) {\n        Channel2.NRx1Duty = (value >> 6) & 0x03;\n        Channel2.NRx1LengthLoad = value & 0x3f;\n        // Also need to set our length counter. Taken from the old, setChannelLengthCounter\n        // Channel length is determined by 64 (or 256 if channel 3), - the length load\n        // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Registers\n        // Note, this will be different for channel 3\n        Channel2.lengthCounter = Channel2.MAX_LENGTH - Channel2.NRx1LengthLoad;\n    };\n    Channel2.updateNRx2 = function (value) {\n        // Handle \"Zombie Mode\" Obscure behavior\n        // https://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Obscure_Behavior\n        if (Channel2.isEnabled) {\n            // If the old envelope period was zero and the envelope is still doing automatic updates,\n            // volume is incremented by 1, otherwise if the envelope was in subtract mode,\n            // volume is incremented by 2.\n            // NOTE: However, from my testing, it ALWAYS increments by one. This was determined\n            // by my testing for prehistoric man\n            if (Channel2.NRx2EnvelopePeriod === 0 && Channel2.isEnvelopeAutomaticUpdating) {\n                // Volume can't be more than 4 bits\n                Channel2.volume = (Channel2.volume + 1) & 0x0f;\n            }\n            // If the mode was changed (add to subtract or subtract to add),\n            // volume is set to 16-volume. But volume cant be more than 4 bits\n            if (Channel2.NRx2EnvelopeAddMode !== checkBitOnByte(3, value)) {\n                Channel2.volume = (16 - Channel2.volume) & 0x0f;\n            }\n        }\n        Channel2.NRx2StartingVolume = (value >> 4) & 0x0f;\n        Channel2.NRx2EnvelopeAddMode = checkBitOnByte(3, value);\n        Channel2.NRx2EnvelopePeriod = value & 0x07;\n        // Also, get our channel is dac enabled\n        var isDacEnabled = (value & 0xf8) > 0;\n        Channel2.isDacEnabled = isDacEnabled;\n        // Blargg length test\n        // Disabling DAC should disable channel immediately\n        if (!isDacEnabled) {\n            Channel2.isEnabled = isDacEnabled;\n        }\n    };\n    Channel2.updateNRx3 = function (value) {\n        Channel2.NRx3FrequencyLSB = value;\n        // Update Channel Frequency\n        Channel2.frequency = (Channel2.NRx4FrequencyMSB << 8) | value;\n    };\n    Channel2.updateNRx4 = function (value) {\n        // Handle our Channel frequency first\n        // As this is modified if we trigger for length.\n        var frequencyMSB = value & 0x07;\n        Channel2.NRx4FrequencyMSB = frequencyMSB;\n        Channel2.frequency = (frequencyMSB << 8) | Channel2.NRx3FrequencyLSB;\n        // Obscure behavior\n        // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Obscure_Behavior\n        // Also see blargg's cgb sound test\n        // Extra length clocking occurs when writing to NRx4,\n        // when the frame sequencer's next step is one that,\n        // doesn't clock the length counter.\n        var frameSequencer = Sound.frameSequencer;\n        var doesNextFrameSequencerUpdateLength = (frameSequencer & 1) === 1;\n        var isBeingLengthEnabled = !Channel2.NRx4LengthEnabled && checkBitOnByte(6, value);\n        if (!doesNextFrameSequencerUpdateLength) {\n            if (Channel2.lengthCounter > 0 && isBeingLengthEnabled) {\n                Channel2.lengthCounter -= 1;\n                if (!checkBitOnByte(7, value) && Channel2.lengthCounter === 0) {\n                    Channel2.isEnabled = false;\n                }\n            }\n        }\n        // Set the length enabled from the value\n        Channel2.NRx4LengthEnabled = checkBitOnByte(6, value);\n        // Trigger out channel, unfreeze length if frozen\n        // Triggers should happen after obscure behavior\n        // See test 11 for trigger\n        if (checkBitOnByte(7, value)) {\n            Channel2.trigger();\n            // When we trigger on the obscure behavior, and we reset the length Counter to max\n            // We need to clock\n            if (!doesNextFrameSequencerUpdateLength && Channel2.lengthCounter === Channel2.MAX_LENGTH && Channel2.NRx4LengthEnabled) {\n                Channel2.lengthCounter -= 1;\n            }\n        }\n    };\n    // Function to save the state of the class\n    Channel2.saveState = function () {\n        // Cycle Counter\n        store(getSaveStateMemoryOffset(0x00, Channel2.saveStateSlot), Channel2.cycleCounter);\n        // NRx0\n        // No NRx0 Properties\n        // NRx1\n        store(getSaveStateMemoryOffset(0x07, Channel2.saveStateSlot), Channel2.NRx1Duty);\n        store(getSaveStateMemoryOffset(0x08, Channel2.saveStateSlot), Channel2.NRx1LengthLoad);\n        // NRx2\n        store(getSaveStateMemoryOffset(0x0a, Channel2.saveStateSlot), Channel2.NRx2StartingVolume);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0b, Channel2.saveStateSlot), Channel2.NRx2EnvelopeAddMode);\n        store(getSaveStateMemoryOffset(0x0c, Channel2.saveStateSlot), Channel2.NRx2EnvelopePeriod);\n        // NRx3\n        store(getSaveStateMemoryOffset(0x0d, Channel2.saveStateSlot), Channel2.NRx3FrequencyLSB);\n        // NRx4\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0e, Channel2.saveStateSlot), Channel2.NRx4LengthEnabled);\n        store(getSaveStateMemoryOffset(0x0f, Channel2.saveStateSlot), Channel2.NRx4FrequencyMSB);\n        // Channel Properties\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x10, Channel2.saveStateSlot), Channel2.isEnabled);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x11, Channel2.saveStateSlot), Channel2.isDacEnabled);\n        store(getSaveStateMemoryOffset(0x12, Channel2.saveStateSlot), Channel2.frequency);\n        store(getSaveStateMemoryOffset(0x16, Channel2.saveStateSlot), Channel2.frequencyTimer);\n        store(getSaveStateMemoryOffset(0x1a, Channel2.saveStateSlot), Channel2.envelopeCounter);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x1e, Channel2.saveStateSlot), Channel2.isEnvelopeAutomaticUpdating);\n        store(getSaveStateMemoryOffset(0x1f, Channel2.saveStateSlot), Channel2.lengthCounter);\n        store(getSaveStateMemoryOffset(0x23, Channel2.saveStateSlot), Channel2.volume);\n        // Square Duty\n        store(getSaveStateMemoryOffset(0x27, Channel2.saveStateSlot), Channel2.dutyCycle);\n        store(getSaveStateMemoryOffset(0x28, Channel2.saveStateSlot), Channel2.waveFormPositionOnDuty);\n    };\n    // Function to load the save state from memory\n    Channel2.loadState = function () {\n        // Cycle Counter\n        Channel2.cycleCounter = load(getSaveStateMemoryOffset(0x00, Channel2.cycleCounter));\n        // NRx0\n        // No NRx0\n        // NRx1\n        Channel2.NRx1Duty = load(getSaveStateMemoryOffset(0x07, Channel2.saveStateSlot));\n        Channel2.NRx1LengthLoad = load(getSaveStateMemoryOffset(0x08, Channel2.saveStateSlot));\n        // NRx2\n        Channel2.NRx2StartingVolume = load(getSaveStateMemoryOffset(0xa, Channel2.saveStateSlot));\n        Channel2.NRx2EnvelopeAddMode = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0b, Channel2.saveStateSlot));\n        Channel2.NRx2EnvelopePeriod = load(getSaveStateMemoryOffset(0x0c, Channel2.saveStateSlot));\n        // NRx3\n        Channel2.NRx3FrequencyLSB = load(getSaveStateMemoryOffset(0x0d, Channel2.saveStateSlot));\n        // NRx4\n        Channel2.NRx4LengthEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0e, Channel2.saveStateSlot));\n        Channel2.NRx4FrequencyMSB = load(getSaveStateMemoryOffset(0x0f, Channel2.saveStateSlot));\n        // Channel Properties\n        Channel2.isEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x10, Channel2.saveStateSlot));\n        Channel2.isDacEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x11, Channel2.saveStateSlot));\n        Channel2.frequency = load(getSaveStateMemoryOffset(0x12, Channel2.saveStateSlot));\n        Channel2.frequencyTimer = load(getSaveStateMemoryOffset(0x16, Channel2.saveStateSlot));\n        Channel2.envelopeCounter = load(getSaveStateMemoryOffset(0x1a, Channel2.saveStateSlot));\n        Channel2.isEnvelopeAutomaticUpdating = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x1e, Channel2.saveStateSlot));\n        Channel2.lengthCounter = load(getSaveStateMemoryOffset(0x1f, Channel2.saveStateSlot));\n        Channel2.volume = load(getSaveStateMemoryOffset(0x23, Channel2.saveStateSlot));\n        // Square Duty\n        Channel2.dutyCycle = load(getSaveStateMemoryOffset(0x27, Channel2.saveStateSlot));\n        Channel2.waveFormPositionOnDuty = load(getSaveStateMemoryOffset(0x28, Channel2.saveStateSlot));\n    };\n    Channel2.initialize = function () {\n        eightBitStoreIntoGBMemory(Channel2.memoryLocationNRx1 - 1, 0xff);\n        eightBitStoreIntoGBMemory(Channel2.memoryLocationNRx1, 0x3f);\n        eightBitStoreIntoGBMemory(Channel2.memoryLocationNRx2, 0x00);\n        eightBitStoreIntoGBMemory(Channel2.memoryLocationNRx3, 0x00);\n        eightBitStoreIntoGBMemory(Channel2.memoryLocationNRx4, 0xb8);\n    };\n    // Function to get a sample using the cycle counter on the channel\n    Channel2.getSampleFromCycleCounter = function () {\n        var accumulatedCycles = Channel2.cycleCounter;\n        Channel2.cycleCounter = 0;\n        return Channel2.getSample(accumulatedCycles);\n    };\n    // Function to reset our timer, useful for GBC double speed mode\n    Channel2.resetTimer = function () {\n        var frequencyTimer = (2048 - Channel2.frequency) << 2;\n        // TODO: Ensure this is correct for GBC Double Speed Mode\n        Channel2.frequencyTimer = frequencyTimer << Cpu.GBCDoubleSpeed;\n    };\n    Channel2.getSample = function (numberOfCycles) {\n        // Decrement our channel timer\n        var frequencyTimer = Channel2.frequencyTimer;\n        frequencyTimer -= numberOfCycles;\n        while (frequencyTimer <= 0) {\n            // Get the amount that overflowed so we don't drop cycles\n            var overflowAmount = abs(frequencyTimer);\n            // Reset our timer\n            // A square channel's frequency timer period is set to (2048-frequency)*4.\n            // Four duty cycles are available, each waveform taking 8 frequency timer clocks to cycle through:\n            Channel2.resetTimer();\n            frequencyTimer = Channel2.frequencyTimer;\n            frequencyTimer -= overflowAmount;\n            // Also increment our duty cycle\n            // What is duty? https://en.wikipedia.org/wiki/Duty_cycle\n            // Duty cycle for square wave: http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Square_Wave\n            Channel2.waveFormPositionOnDuty = (Channel2.waveFormPositionOnDuty + 1) & 7;\n        }\n        Channel2.frequencyTimer = frequencyTimer;\n        // Get our ourput volume\n        var outputVolume = 0;\n        // Finally to set our output volume, the channel must be enabled,\n        // Our channel DAC must be enabled, and we must be in an active state\n        // Of our duty cycle\n        if (Channel2.isEnabled && Channel2.isDacEnabled) {\n            // Volume can't be more than 4 bits.\n            // Volume should never be more than 4 bits, but doing a check here\n            outputVolume = Channel2.volume & 0x0f;\n        }\n        else {\n            // Return silence\n            // Since range from -15 - 15, or 0 to 30 for our unsigned\n            return 15;\n        }\n        // Get the current sampleValue\n        var sample = 1;\n        if (!isDutyCycleClockPositiveOrNegativeForWaveform(Channel2.NRx1Duty, Channel2.waveFormPositionOnDuty)) {\n            sample = -sample;\n        }\n        sample = sample * outputVolume;\n        // Square Waves Can range from -15 - 15. Therefore simply add 15\n        sample += 15;\n        return sample;\n    };\n    //http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Trigger_Event\n    Channel2.trigger = function () {\n        Channel2.isEnabled = true;\n        // Set length to maximum done in write\n        if (Channel2.lengthCounter === 0) {\n            Channel2.lengthCounter = Channel2.MAX_LENGTH;\n        }\n        // Reset our timer\n        // A square channel's frequency timer period is set to (2048-frequency)*4.\n        // Four duty cycles are available, each waveform taking 8 frequency timer clocks to cycle through:\n        Channel2.resetTimer();\n        // The volume envelope and sweep timers treat a period of 0 as 8.\n        // Meaning, if the period is zero, set it to the max (8).\n        if (Channel2.NRx2EnvelopePeriod === 0) {\n            Channel2.envelopeCounter = 8;\n        }\n        else {\n            Channel2.envelopeCounter = Channel2.NRx2EnvelopePeriod;\n        }\n        Channel2.isEnvelopeAutomaticUpdating = true;\n        Channel2.volume = Channel2.NRx2StartingVolume;\n        // Finally if DAC is off, channel is still disabled\n        if (!Channel2.isDacEnabled) {\n            Channel2.isEnabled = false;\n        }\n    };\n    // Function to determine if the current channel would update when getting the sample\n    // This is used to accumulate samples\n    Channel2.willChannelUpdate = function (numberOfCycles) {\n        //Increment our cycle counter\n        var cycleCounter = Channel2.cycleCounter + numberOfCycles;\n        Channel2.cycleCounter = cycleCounter;\n        // Dac enabled status cached by accumulator\n        return !(Channel2.frequencyTimer - cycleCounter > 0);\n    };\n    Channel2.updateLength = function () {\n        var lengthCounter = Channel2.lengthCounter;\n        if (lengthCounter > 0 && Channel2.NRx4LengthEnabled) {\n            lengthCounter -= 1;\n        }\n        if (lengthCounter === 0) {\n            Channel2.isEnabled = false;\n        }\n        Channel2.lengthCounter = lengthCounter;\n    };\n    Channel2.updateEnvelope = function () {\n        var envelopeCounter = Channel2.envelopeCounter - 1;\n        if (envelopeCounter <= 0) {\n            // Reset back to the sweep period\n            // Obscure behavior\n            // Envelopes treat a period of 0 as 8 (They reset back to the max)\n            if (Channel2.NRx2EnvelopePeriod === 0) {\n                envelopeCounter = 8;\n            }\n            else {\n                envelopeCounter = Channel2.NRx2EnvelopePeriod;\n                // When the timer generates a clock and the envelope period is NOT zero, a new volume is calculated\n                // NOTE: There is some weiirrdd obscure behavior where zero can equal 8, so watch out for that\n                if (envelopeCounter !== 0 && Channel2.isEnvelopeAutomaticUpdating) {\n                    var volume = Channel2.volume;\n                    // Increment the volume\n                    if (Channel2.NRx2EnvelopeAddMode) {\n                        volume += 1;\n                    }\n                    else {\n                        volume -= 1;\n                    }\n                    // Don't allow the volume to go above 4 bits.\n                    volume = volume & 0x0f;\n                    // Check if we are below the max\n                    if (volume < 15) {\n                        Channel2.volume = volume;\n                    }\n                    else {\n                        Channel2.isEnvelopeAutomaticUpdating = false;\n                    }\n                }\n            }\n        }\n        Channel2.envelopeCounter = envelopeCounter;\n    };\n    Channel2.setFrequency = function (frequency) {\n        // Get the high and low bits\n        var passedFrequencyHighBits = frequency >> 8;\n        var passedFrequencyLowBits = frequency & 0xff;\n        // Get the new register 4\n        var register4 = eightBitLoadFromGBMemory(Channel2.memoryLocationNRx4);\n        // Knock off lower 3 bits, and Or on our high bits\n        var newRegister4 = register4 & 0xf8;\n        newRegister4 = newRegister4 | passedFrequencyHighBits;\n        // Set the registers\n        eightBitStoreIntoGBMemory(Channel2.memoryLocationNRx3, passedFrequencyLowBits);\n        eightBitStoreIntoGBMemory(Channel2.memoryLocationNRx4, newRegister4);\n        // Save the frequency for ourselves without triggering memory traps\n        Channel2.NRx3FrequencyLSB = passedFrequencyLowBits;\n        Channel2.NRx4FrequencyMSB = passedFrequencyHighBits;\n        Channel2.frequency = (passedFrequencyHighBits << 8) | passedFrequencyLowBits;\n    };\n    // Cycle Counter for our sound accumulator\n    Channel2.cycleCounter = 0;\n    // Max Length of our Length Load\n    Channel2.MAX_LENGTH = 64;\n    // Squarewave channel with volume envelope functions only.\n    // Only used by register reading\n    Channel2.memoryLocationNRx0 = 0xff15;\n    // NR21 -> Sound length/Wave pattern duty (R/W)\n    Channel2.memoryLocationNRx1 = 0xff16;\n    // DDLL LLLL Duty, Length load (64-L)\n    Channel2.NRx1Duty = 0;\n    Channel2.NRx1LengthLoad = 0;\n    // NR22 -> Volume Envelope (R/W)\n    Channel2.memoryLocationNRx2 = 0xff17;\n    // VVVV APPP Starting volume, Envelope add mode, period\n    Channel2.NRx2StartingVolume = 0;\n    Channel2.NRx2EnvelopeAddMode = false;\n    Channel2.NRx2EnvelopePeriod = 0;\n    // NR23 -> Frequency lo (W)\n    Channel2.memoryLocationNRx3 = 0xff18;\n    // FFFF FFFF Frequency LSB\n    Channel2.NRx3FrequencyLSB = 0;\n    // NR24 -> Frequency hi (R/W)\n    Channel2.memoryLocationNRx4 = 0xff19;\n    // TL-- -FFF Trigger, Length enable, Frequency MSB\n    Channel2.NRx4LengthEnabled = false;\n    Channel2.NRx4FrequencyMSB = 0;\n    // Channel Properties\n    Channel2.channelNumber = 2;\n    Channel2.isEnabled = false;\n    Channel2.isDacEnabled = false;\n    Channel2.frequency = 0;\n    Channel2.frequencyTimer = 0x00;\n    Channel2.envelopeCounter = 0x00;\n    Channel2.isEnvelopeAutomaticUpdating = false;\n    Channel2.lengthCounter = 0x00;\n    Channel2.volume = 0x00;\n    // Square Wave properties\n    Channel2.dutyCycle = 0x00;\n    Channel2.waveFormPositionOnDuty = 0x00;\n    // Save States\n    Channel2.saveStateSlot = 8;\n    return Channel2;\n}());\n\n// NOTE: Tons of Copy-pasta btween channels, because Classes cannot be instantiated yet in assemblyscript\nvar Channel3 = /** @class */ (function () {\n    function Channel3() {\n    }\n    // E--- ---- DAC power\n    Channel3.updateNRx0 = function (value) {\n        var isDacEnabled = checkBitOnByte(7, value);\n        // Sample buffer reset to zero when powered on\n        if (!Channel3.isDacEnabled && isDacEnabled) {\n            Channel3.sampleBuffer = 0x00;\n        }\n        Channel3.isDacEnabled = isDacEnabled;\n        // Blargg length test\n        // Disabling DAC should disable channel immediately\n        if (!isDacEnabled) {\n            Channel3.isEnabled = isDacEnabled;\n        }\n    };\n    Channel3.updateNRx1 = function (value) {\n        Channel3.NRx1LengthLoad = value;\n        // Also need to set our length counter. Taken from the old, setChannelLengthCounter\n        // Channel length is determined by 64 (or 256 if channel 3), - the length load\n        // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Registers\n        // Note, this will be different for channel 3\n        // Supposed to be 256, so subtracting 255 and then adding 1 if that makes sense\n        Channel3.lengthCounter = Channel3.MAX_LENGTH - Channel3.NRx1LengthLoad;\n    };\n    Channel3.updateNRx2 = function (value) {\n        Channel3.NRx2VolumeCode = (value >> 5) & 0x0f;\n    };\n    Channel3.updateNRx3 = function (value) {\n        Channel3.NRx3FrequencyLSB = value;\n        // Update Channel Frequency\n        Channel3.frequency = (Channel3.NRx4FrequencyMSB << 8) | value;\n    };\n    Channel3.updateNRx4 = function (value) {\n        // Handle our frequency\n        // Must be done first for our upcoming trigger\n        // To correctly reset timing\n        var frequencyMSB = value & 0x07;\n        Channel3.NRx4FrequencyMSB = frequencyMSB;\n        Channel3.frequency = (frequencyMSB << 8) | Channel3.NRx3FrequencyLSB;\n        // Obscure behavior\n        // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Obscure_Behavior\n        // Also see blargg's cgb sound test\n        // Extra length clocking occurs when writing to NRx4,\n        // when the frame sequencer's next step is one that,\n        // doesn't clock the length counter.\n        var frameSequencer = Sound.frameSequencer;\n        var doesNextFrameSequencerUpdateLength = (frameSequencer & 1) === 1;\n        var isBeingLengthEnabled = false;\n        if (!doesNextFrameSequencerUpdateLength) {\n            // Check lengthEnable\n            isBeingLengthEnabled = !Channel3.NRx4LengthEnabled && checkBitOnByte(6, value);\n            if (Channel3.lengthCounter > 0 && isBeingLengthEnabled) {\n                Channel3.lengthCounter -= 1;\n                if (!checkBitOnByte(7, value) && Channel3.lengthCounter === 0) {\n                    Channel3.isEnabled = false;\n                }\n            }\n        }\n        // Set the length enabled from the value\n        Channel3.NRx4LengthEnabled = checkBitOnByte(6, value);\n        // Trigger our channel, unfreeze length if frozen\n        // Triggers should happen after obscure behavior\n        // See test 11 for trigger\n        if (checkBitOnByte(7, value)) {\n            Channel3.trigger();\n            // When we trigger on the obscure behavior, and we reset the length Counter to max\n            // We need to clock\n            if (!doesNextFrameSequencerUpdateLength && Channel3.lengthCounter === Channel3.MAX_LENGTH && Channel3.NRx4LengthEnabled) {\n                Channel3.lengthCounter -= 1;\n            }\n        }\n    };\n    // Function to save the state of the class\n    Channel3.saveState = function () {\n        // Cycle Counter\n        store(getSaveStateMemoryOffset(0x00, Channel3.saveStateSlot), Channel3.cycleCounter);\n        // NRx0\n        // No NRx0 Properties\n        // NRx1\n        store(getSaveStateMemoryOffset(0x08, Channel3.saveStateSlot), Channel3.NRx1LengthLoad);\n        // NRx2\n        store(getSaveStateMemoryOffset(0x0a, Channel3.saveStateSlot), Channel3.NRx2VolumeCode);\n        // NRx3\n        store(getSaveStateMemoryOffset(0x0c, Channel3.saveStateSlot), Channel3.NRx3FrequencyLSB);\n        // NRx4\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0d, Channel3.saveStateSlot), Channel3.NRx4LengthEnabled);\n        store(getSaveStateMemoryOffset(0x0e, Channel3.saveStateSlot), Channel3.NRx4FrequencyMSB);\n        // Channel Properties\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0f, Channel3.saveStateSlot), Channel3.isEnabled);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x10, Channel3.saveStateSlot), Channel3.isDacEnabled);\n        store(getSaveStateMemoryOffset(0x11, Channel3.saveStateSlot), Channel3.frequency);\n        store(getSaveStateMemoryOffset(0x15, Channel3.saveStateSlot), Channel3.frequencyTimer);\n        // No Envelope\n        store(getSaveStateMemoryOffset(0x19, Channel3.saveStateSlot), Channel3.lengthCounter);\n        // WaveTable Properties\n        store(getSaveStateMemoryOffset(0x21, Channel3.saveStateSlot), Channel3.waveTablePosition);\n        store(getSaveStateMemoryOffset(0x25, Channel3.saveStateSlot), Channel3.volumeCode);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x26, Channel3.saveStateSlot), Channel3.volumeCodeChanged);\n        store(getSaveStateMemoryOffset(0x27, Channel3.saveStateSlot), Channel3.sampleBuffer);\n    };\n    // Function to load the save state from memory\n    Channel3.loadState = function () {\n        // Cycle Counter\n        Channel3.cycleCounter = load(getSaveStateMemoryOffset(0x00, Channel3.cycleCounter));\n        // NRx0\n        // No NRx0\n        // NRx1\n        Channel3.NRx1LengthLoad = load(getSaveStateMemoryOffset(0x08, Channel3.saveStateSlot));\n        // NRx2\n        Channel3.NRx2VolumeCode = load(getSaveStateMemoryOffset(0x0a, Channel3.saveStateSlot));\n        // NRx3\n        Channel3.NRx3FrequencyLSB = load(getSaveStateMemoryOffset(0x0c, Channel3.saveStateSlot));\n        // NRx4\n        Channel3.NRx4LengthEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0d, Channel3.saveStateSlot));\n        Channel3.NRx4FrequencyMSB = load(getSaveStateMemoryOffset(0x0e, Channel3.saveStateSlot));\n        // Channel Properties\n        Channel3.isEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0f, Channel3.saveStateSlot));\n        Channel3.isDacEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x10, Channel3.saveStateSlot));\n        Channel3.frequency = load(getSaveStateMemoryOffset(0x11, Channel3.saveStateSlot));\n        Channel3.frequencyTimer = load(getSaveStateMemoryOffset(0x15, Channel3.saveStateSlot));\n        // No Envelope\n        Channel3.lengthCounter = load(getSaveStateMemoryOffset(0x19, Channel3.saveStateSlot));\n        // Wave Table Properties\n        Channel3.waveTablePosition = load(getSaveStateMemoryOffset(0x21, Channel3.saveStateSlot));\n        Channel3.volumeCode = load(getSaveStateMemoryOffset(0x25, Channel3.saveStateSlot));\n        Channel3.volumeCodeChanged = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x26, Channel3.saveStateSlot));\n        Channel3.sampleBuffer = load(getSaveStateMemoryOffset(0x27, Channel3.saveStateSlot));\n    };\n    // Memory Read Trap\n    Channel3.handleWaveRamRead = function () {\n        // Obscure behavior\n        // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware\n        // If the wave channel is enabled, accessing any byte from $FF30-$FF3F is equivalent to,\n        // accessing the current byte selected by the waveform position. Further, on the DMG accesses will only work in this manner,\n        // if made within a couple of clocks of the wave channel accessing wave RAM;\n        // if made at any other time, reads return $FF and writes have no effect.\n        // TODO: Handle DMG case\n        return readCurrentSampleByteFromWaveRam();\n    };\n    // Memory Write Trap\n    Channel3.handleWaveRamWrite = function (value) {\n        // Obscure behavior\n        // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware\n        // If the wave channel is enabled, accessing any byte from $FF30-$FF3F is equivalent to,\n        // accessing the current byte selected by the waveform position. Further, on the DMG accesses will only work in this manner,\n        // if made within a couple of clocks of the wave channel accessing wave RAM;\n        // if made at any other time, reads return $FF and writes have no effect.\n        // Thus we want to write the value to the current sample position\n        // Will Find the position, and knock off any remainder\n        var positionIndexToAdd = i32Portable(Channel3.waveTablePosition >> 1);\n        var memoryLocationWaveSample = Channel3.memoryLocationWaveTable + positionIndexToAdd;\n        eightBitStoreIntoGBMemory(memoryLocationWaveSample, value);\n    };\n    Channel3.initialize = function () {\n        eightBitStoreIntoGBMemory(Channel3.memoryLocationNRx0, 0x7f);\n        eightBitStoreIntoGBMemory(Channel3.memoryLocationNRx1, 0xff);\n        eightBitStoreIntoGBMemory(Channel3.memoryLocationNRx2, 0x9f);\n        eightBitStoreIntoGBMemory(Channel3.memoryLocationNRx3, 0x00);\n        eightBitStoreIntoGBMemory(Channel3.memoryLocationNRx4, 0xb8);\n        // The volume code changed\n        Channel3.volumeCodeChanged = true;\n    };\n    // Function to get a sample using the cycle counter on the channel\n    Channel3.getSampleFromCycleCounter = function () {\n        var accumulatedCycles = Channel3.cycleCounter;\n        Channel3.cycleCounter = 0;\n        return Channel3.getSample(accumulatedCycles);\n    };\n    // Function to reset our timer, useful for GBC double speed mode\n    Channel3.resetTimer = function () {\n        var frequencyTimer = (2048 - Channel3.frequency) << 1;\n        // TODO: Ensure this is correct for GBC Double Speed Mode\n        Channel3.frequencyTimer = frequencyTimer << Cpu.GBCDoubleSpeed;\n    };\n    Channel3.getSample = function (numberOfCycles) {\n        // Check if we are enabled\n        if (!Channel3.isEnabled || !Channel3.isDacEnabled) {\n            // Return silence\n            // Since range from -15 - 15, or 0 to 30 for our unsigned\n            return 15;\n        }\n        // Get our volume code\n        // Need this to compute the sample\n        var volumeCode = Channel3.volumeCode;\n        if (Channel3.volumeCodeChanged) {\n            volumeCode = eightBitLoadFromGBMemory(Channel3.memoryLocationNRx2);\n            volumeCode = volumeCode >> 5;\n            volumeCode = volumeCode & 0x0f;\n            Channel3.volumeCode = volumeCode;\n            Channel3.volumeCodeChanged = false;\n        }\n        // Get the current sample\n        var sample = getSampleFromSampleBufferForWaveTablePosition();\n        // Shift our sample and set our volume depending on the volume code\n        // Since we can't multiply by float, simply divide by 4, 2, 1\n        // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Wave_Channel\n        var outputVolume = 0;\n        switch (volumeCode) {\n            case 0:\n                sample >>= 4;\n                break;\n            case 1:\n                // Dont Shift sample\n                outputVolume = 1;\n                break;\n            case 2:\n                sample >>= 1;\n                outputVolume = 2;\n                break;\n            default:\n                sample >>= 2;\n                outputVolume = 4;\n                break;\n        }\n        // Apply out output volume\n        sample = outputVolume > 0 ? sample / outputVolume : 0;\n        // Square Waves Can range from -15 - 15. Therefore simply add 15\n        sample += 15;\n        // Update the sample based on our timer\n        var frequencyTimer = Channel3.frequencyTimer;\n        frequencyTimer -= numberOfCycles;\n        while (frequencyTimer <= 0) {\n            // Get the amount that overflowed so we don't drop cycles\n            var overflowAmount = abs(frequencyTimer);\n            // Reset our timer\n            // A wave channel's frequency timer period is set to (2048-frequency) * 2.\n            // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Wave_Channel\n            Channel3.resetTimer();\n            frequencyTimer = Channel3.frequencyTimer;\n            frequencyTimer -= overflowAmount;\n            // Update our sample buffer\n            advanceWavePositionAndSampleBuffer();\n        }\n        Channel3.frequencyTimer = frequencyTimer;\n        // Finally return the sample\n        return sample;\n    };\n    //http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Trigger_Event\n    Channel3.trigger = function () {\n        Channel3.isEnabled = true;\n        // Length counter maximum handled by write\n        if (Channel3.lengthCounter === 0) {\n            Channel3.lengthCounter = Channel3.MAX_LENGTH;\n        }\n        // Reset our timer\n        // A wave channel's frequency timer period is set to (2048-frequency)*2.\n        Channel3.resetTimer();\n        // Add some delay to our frequency timer\n        // So Honestly, lifted this from binjgb\n        // https://github.com/binji/binjgb/blob/68eb4b2f6d5d7a98d270e12c4b8ff065c07f5e94/src/emulator.c#L2625\n        // I have no clue why this is, but it passes 09-wave read while on.s\n        // blargg test.\n        // I think this has to do with obscure behavior?\n        // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware\n        // When triggering the wave channel,\n        // the first sample to play is the previous one still in the high nibble of the sample buffer,\n        // and the next sample is the second nibble from the wave table.\n        // This is because it doesn't load the first byte on trigger like it \"should\".\n        // The first nibble from the wave table is thus not played until the waveform loops.\n        Channel3.frequencyTimer += 6;\n        // Reset our wave table position\n        Channel3.waveTablePosition = 0;\n        // Finally if DAC is off, channel is still disabled\n        if (!Channel3.isDacEnabled) {\n            Channel3.isEnabled = false;\n        }\n    };\n    // Function to determine if the current channel would update when getting the sample\n    // This is used to accumulate samples\n    Channel3.willChannelUpdate = function (numberOfCycles) {\n        //Increment our cycle counter\n        Channel3.cycleCounter += numberOfCycles;\n        // Dac enabled status cached by accumulator\n        return !(!Channel3.volumeCodeChanged && Channel3.frequencyTimer - Channel3.cycleCounter > 0);\n    };\n    Channel3.updateLength = function () {\n        var lengthCounter = Channel3.lengthCounter;\n        if (lengthCounter > 0 && Channel3.NRx4LengthEnabled) {\n            lengthCounter -= 1;\n        }\n        if (lengthCounter === 0) {\n            Channel3.isEnabled = false;\n        }\n        Channel3.lengthCounter = lengthCounter;\n    };\n    // Cycle Counter for our sound accumulator\n    Channel3.cycleCounter = 0;\n    // Max Length of our Length Load\n    Channel3.MAX_LENGTH = 256;\n    // Voluntary Wave channel with 32 4-bit programmable samples, played in sequence.\n    // NR30 -> Sound on/off (R/W)\n    Channel3.memoryLocationNRx0 = 0xff1a;\n    // NR31 -> Sound length (R/W)\n    Channel3.memoryLocationNRx1 = 0xff1b;\n    // LLLL LLLL Length load (256-L)\n    Channel3.NRx1LengthLoad = 0;\n    // NR32 -> Select ouput level (R/W)\n    Channel3.memoryLocationNRx2 = 0xff1c;\n    // -VV- ---- Volume code (00=0%, 01=100%, 10=50%, 11=25%)\n    Channel3.NRx2VolumeCode = 0;\n    // NR33 -> Frequency lower data (W)\n    Channel3.memoryLocationNRx3 = 0xff1d;\n    // FFFF FFFF Frequency LSB\n    Channel3.NRx3FrequencyLSB = 0;\n    // NR34 -> Frequency higher data (R/W)\n    Channel3.memoryLocationNRx4 = 0xff1e;\n    // TL-- -FFF Trigger, Length enable, Frequency MSB\n    Channel3.NRx4LengthEnabled = false;\n    Channel3.NRx4FrequencyMSB = 0;\n    // Our wave table location\n    Channel3.memoryLocationWaveTable = 0xff30;\n    // Channel Properties\n    Channel3.channelNumber = 3;\n    Channel3.isEnabled = false;\n    Channel3.isDacEnabled = false;\n    Channel3.frequency = 0;\n    Channel3.frequencyTimer = 0x00;\n    Channel3.lengthCounter = 0x00;\n    // WaveTable Properties\n    Channel3.waveTablePosition = 0x00;\n    Channel3.volumeCode = 0x00;\n    Channel3.volumeCodeChanged = false;\n    Channel3.sampleBuffer = 0x00;\n    // Save States\n    Channel3.saveStateSlot = 9;\n    return Channel3;\n}());\n// Functions specific to wave memory\nfunction advanceWavePositionAndSampleBuffer() {\n    // Advance the wave table position, and loop back if needed\n    var waveTablePosition = Channel3.waveTablePosition;\n    waveTablePosition += 1;\n    while (waveTablePosition >= 32) {\n        waveTablePosition -= 32;\n    }\n    Channel3.waveTablePosition = waveTablePosition;\n    // Load the next sample byte from wave ram,\n    // into the sample buffer\n    Channel3.sampleBuffer = readCurrentSampleByteFromWaveRam();\n}\nfunction readCurrentSampleByteFromWaveRam() {\n    // Will Find the position, and knock off any remainder\n    var positionIndexToAdd = i32Portable(Channel3.waveTablePosition >> 1);\n    var memoryLocationWaveSample = Channel3.memoryLocationWaveTable + positionIndexToAdd;\n    return eightBitLoadFromGBMemory(memoryLocationWaveSample);\n}\nfunction getSampleFromSampleBufferForWaveTablePosition() {\n    var sample = Channel3.sampleBuffer;\n    // Need to grab the top or lower half for the correct sample\n    sample >>= ((Channel3.waveTablePosition & 1) === 0) << 2;\n    sample &= 0x0f;\n    return sample;\n}\n\n// NOTE: Tons of Copy-pasta btween channels, because Classes cannot be instantiated yet in assemblyscript\nvar Channel4 = /** @class */ (function () {\n    function Channel4() {\n    }\n    Channel4.updateNRx1 = function (value) {\n        Channel4.NRx1LengthLoad = value & 0x3f;\n        // Also need to set our length counter. Taken from the old, setChannelLengthCounter\n        // Channel length is determined by 64 (or 256 if channel 3), - the length load\n        // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Registers\n        // Note, this will be different for channel 3\n        Channel4.lengthCounter = Channel4.MAX_LENGTH - Channel4.NRx1LengthLoad;\n    };\n    Channel4.updateNRx2 = function (value) {\n        // Handle \"Zombie Mode\" Obscure behavior\n        // https://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Obscure_Behavior\n        if (Channel4.isEnabled) {\n            // If the old envelope period was zero and the envelope is still doing automatic updates,\n            // volume is incremented by 1, otherwise if the envelope was in subtract mode,\n            // volume is incremented by 2.\n            // NOTE: However, from my testing, it ALWAYS increments by one. This was determined\n            // by my testing for prehistoric man\n            if (Channel4.NRx2EnvelopePeriod === 0 && Channel4.isEnvelopeAutomaticUpdating) {\n                // Volume can't be more than 4 bits\n                Channel4.volume = (Channel4.volume + 1) & 0x0f;\n            }\n            // If the mode was changed (add to subtract or subtract to add),\n            // volume is set to 16-volume. But volume cant be more than 4 bits\n            if (Channel4.NRx2EnvelopeAddMode !== checkBitOnByte(3, value)) {\n                Channel4.volume = (16 - Channel4.volume) & 0x0f;\n            }\n        }\n        Channel4.NRx2StartingVolume = (value >> 4) & 0x0f;\n        Channel4.NRx2EnvelopeAddMode = checkBitOnByte(3, value);\n        Channel4.NRx2EnvelopePeriod = value & 0x07;\n        // Also, get our channel is dac enabled\n        var isDacEnabled = (value & 0xf8) > 0;\n        Channel4.isDacEnabled = isDacEnabled;\n        // Blargg length test\n        // Disabling DAC should disable channel immediately\n        if (!isDacEnabled) {\n            Channel4.isEnabled = isDacEnabled;\n        }\n    };\n    Channel4.updateNRx3 = function (value) {\n        var divisorCode = value & 0x07;\n        Channel4.NRx3ClockShift = value >> 4;\n        Channel4.NRx3WidthMode = checkBitOnByte(3, value);\n        Channel4.NRx3DivisorCode = divisorCode;\n        // Also, get our divisor\n        divisorCode <<= 1;\n        if (divisorCode < 1)\n            divisorCode = 1;\n        Channel4.divisor = divisorCode << 3;\n    };\n    Channel4.updateNRx4 = function (value) {\n        // Obscure behavior\n        // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Obscure_Behavior\n        // Also see blargg's cgb sound test\n        // Extra length clocking occurs when writing to NRx4,\n        // when the frame sequencer's next step is one that,\n        // doesn't clock the length counter.\n        var frameSequencer = Sound.frameSequencer;\n        var doesNextFrameSequencerUpdateLength = (frameSequencer & 1) === 1;\n        var isBeingLengthEnabled = !Channel4.NRx4LengthEnabled && checkBitOnByte(6, value);\n        if (!doesNextFrameSequencerUpdateLength) {\n            if (Channel4.lengthCounter > 0 && isBeingLengthEnabled) {\n                Channel4.lengthCounter -= 1;\n                if (!checkBitOnByte(7, value) && Channel4.lengthCounter === 0) {\n                    Channel4.isEnabled = false;\n                }\n            }\n        }\n        // Set the length enabled from the value\n        Channel4.NRx4LengthEnabled = checkBitOnByte(6, value);\n        // Trigger out channel, unfreeze length if frozen\n        // Triggers should happen after obscure behavior\n        // See test 11 for trigger\n        if (checkBitOnByte(7, value)) {\n            Channel4.trigger();\n            // When we trigger on the obscure behavior, and we reset the length Counter to max\n            // We need to clock\n            if (!doesNextFrameSequencerUpdateLength && Channel4.lengthCounter === Channel4.MAX_LENGTH && Channel4.NRx4LengthEnabled) {\n                Channel4.lengthCounter -= 1;\n            }\n        }\n    };\n    // Function to save the state of the class\n    Channel4.saveState = function () {\n        // Cycle Counter\n        store(getSaveStateMemoryOffset(0x00, Channel4.saveStateSlot), Channel4.cycleCounter);\n        // NRx0\n        // No NRx0 Properties\n        // NRx1\n        store(getSaveStateMemoryOffset(0x04, Channel4.saveStateSlot), Channel4.NRx1LengthLoad);\n        // NRx2\n        store(getSaveStateMemoryOffset(0x06, Channel4.saveStateSlot), Channel4.NRx2StartingVolume);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x07, Channel4.saveStateSlot), Channel4.NRx2EnvelopeAddMode);\n        store(getSaveStateMemoryOffset(0x08, Channel4.saveStateSlot), Channel4.NRx2EnvelopePeriod);\n        // NRx3\n        store(getSaveStateMemoryOffset(0x09, Channel4.saveStateSlot), Channel4.NRx3ClockShift);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0a, Channel4.saveStateSlot), Channel4.NRx3WidthMode);\n        store(getSaveStateMemoryOffset(0x0b, Channel4.saveStateSlot), Channel4.NRx3DivisorCode);\n        // NRx4\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0d, Channel4.saveStateSlot), Channel4.NRx4LengthEnabled);\n        // Channel Properties\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0f, Channel4.saveStateSlot), Channel4.isEnabled);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x10, Channel4.saveStateSlot), Channel4.isDacEnabled);\n        store(getSaveStateMemoryOffset(0x15, Channel4.saveStateSlot), Channel4.frequencyTimer);\n        store(getSaveStateMemoryOffset(0x19, Channel4.saveStateSlot), Channel4.envelopeCounter);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x1d, Channel4.saveStateSlot), Channel4.isEnvelopeAutomaticUpdating);\n        store(getSaveStateMemoryOffset(0x1e, Channel4.saveStateSlot), Channel4.lengthCounter);\n        store(getSaveStateMemoryOffset(0x22, Channel4.saveStateSlot), Channel4.volume);\n        // LSFR\n        store(getSaveStateMemoryOffset(0x26, Channel4.saveStateSlot), Channel4.linearFeedbackShiftRegister);\n    };\n    // Function to load the save state from memory\n    Channel4.loadState = function () {\n        // Cycle Counter\n        Channel4.cycleCounter = load(getSaveStateMemoryOffset(0x00, Channel4.cycleCounter));\n        // NRx0\n        // No NRx0\n        // NRx1\n        Channel4.NRx1LengthLoad = load(getSaveStateMemoryOffset(0x04, Channel4.saveStateSlot));\n        // NRx2\n        Channel4.NRx2StartingVolume = load(getSaveStateMemoryOffset(0x06, Channel4.saveStateSlot));\n        Channel4.NRx2EnvelopeAddMode = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x07, Channel4.saveStateSlot));\n        Channel4.NRx2EnvelopePeriod = load(getSaveStateMemoryOffset(0x08, Channel4.saveStateSlot));\n        // NRx3\n        Channel4.NRx3ClockShift = load(getSaveStateMemoryOffset(0x09, Channel4.saveStateSlot));\n        Channel4.NRx3WidthMode = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0a, Channel4.saveStateSlot));\n        Channel4.NRx3DivisorCode = load(getSaveStateMemoryOffset(0x0b, Channel4.saveStateSlot));\n        // NRx4\n        Channel4.NRx4LengthEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0d, Channel4.saveStateSlot));\n        // Channel Properties\n        Channel4.isEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0f, Channel4.saveStateSlot));\n        Channel4.isDacEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x10, Channel4.saveStateSlot));\n        Channel4.frequencyTimer = load(getSaveStateMemoryOffset(0x15, Channel4.saveStateSlot));\n        Channel4.envelopeCounter = load(getSaveStateMemoryOffset(0x19, Channel4.saveStateSlot));\n        Channel4.isEnvelopeAutomaticUpdating = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x1d, Channel4.saveStateSlot));\n        Channel4.lengthCounter = load(getSaveStateMemoryOffset(0x1e, Channel4.saveStateSlot));\n        Channel4.volume = load(getSaveStateMemoryOffset(0x22, Channel4.saveStateSlot));\n        // LSFR\n        Channel4.linearFeedbackShiftRegister = load(getSaveStateMemoryOffset(0x26, Channel4.saveStateSlot));\n    };\n    Channel4.initialize = function () {\n        eightBitStoreIntoGBMemory(Channel4.memoryLocationNRx1 - 1, 0xff);\n        eightBitStoreIntoGBMemory(Channel4.memoryLocationNRx1, 0xff);\n        eightBitStoreIntoGBMemory(Channel4.memoryLocationNRx2, 0x00);\n        eightBitStoreIntoGBMemory(Channel4.memoryLocationNRx3, 0x00);\n        eightBitStoreIntoGBMemory(Channel4.memoryLocationNRx4, 0xbf);\n    };\n    // Function to get a sample using the cycle counter on the channel\n    Channel4.getSampleFromCycleCounter = function () {\n        var accumulatedCycles = Channel4.cycleCounter;\n        Channel4.cycleCounter = 0;\n        return Channel4.getSample(accumulatedCycles);\n    };\n    Channel4.getSample = function (numberOfCycles) {\n        // Decrement our channel timer\n        var frequencyTimer = Channel4.frequencyTimer;\n        frequencyTimer -= numberOfCycles;\n        // TODO: This can't be a while loop to use up all the cycles,\n        // Since noise is psuedo random and the period can be anything\n        if (frequencyTimer <= 0) {\n            // Get the amount that overflowed so we don't drop cycles\n            var overflowAmount = abs(frequencyTimer);\n            // Reset our timer\n            frequencyTimer = Channel4.getNoiseChannelFrequencyPeriod();\n            frequencyTimer -= overflowAmount;\n            // Do some cool stuff with lfsr\n            // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Noise_Channel\n            // First XOR bit zero and one\n            var linearFeedbackShiftRegister = Channel4.linearFeedbackShiftRegister;\n            var lfsrBitZero = linearFeedbackShiftRegister & 0x01;\n            var lfsrBitOne = linearFeedbackShiftRegister >> 1;\n            lfsrBitOne = lfsrBitOne & 0x01;\n            var xorLfsrBitZeroOne = lfsrBitZero ^ lfsrBitOne;\n            // Shift all lsfr bits by one\n            linearFeedbackShiftRegister = linearFeedbackShiftRegister >> 1;\n            // Place the XOR result on bit 15\n            linearFeedbackShiftRegister = linearFeedbackShiftRegister | (xorLfsrBitZeroOne << 14);\n            // If the width mode is set, set xor on bit 6, and make lfsr 7 bit\n            if (Channel4.NRx3WidthMode) {\n                // Make 7 bit, by knocking off lower bits. Want to keeps bits 8 - 16, and then or on 7\n                linearFeedbackShiftRegister = linearFeedbackShiftRegister & ~0x40;\n                linearFeedbackShiftRegister = linearFeedbackShiftRegister | (xorLfsrBitZeroOne << 6);\n            }\n            Channel4.linearFeedbackShiftRegister = linearFeedbackShiftRegister;\n        }\n        // Make sure period never becomes negative\n        if (frequencyTimer < 0) {\n            frequencyTimer = 0;\n        }\n        Channel4.frequencyTimer = frequencyTimer;\n        // Get our ourput volume, set to zero for silence\n        var outputVolume = 0;\n        // Finally to set our output volume, the channel must be enabled,\n        // Our channel DAC must be enabled, and we must be in an active state\n        // Of our duty cycle\n        if (Channel4.isEnabled && Channel4.isDacEnabled) {\n            // Volume can't be more than 4 bits.\n            // Volume should never be more than 4 bits, but doing a check here\n            outputVolume = Channel4.volume & 0x0f;\n        }\n        else {\n            // Return silence\n            // Since range from -15 - 15, or 0 to 30 for our unsigned\n            return 15;\n        }\n        // Declare our sample\n        var sample = 0;\n        // Wave form output is bit zero of lfsr, INVERTED\n        sample = !checkBitOnByte(0, Channel4.linearFeedbackShiftRegister) ? 1 : -1;\n        sample = sample * outputVolume;\n        // Noise Can range from -15 - 15. Therefore simply add 15\n        sample = sample + 15;\n        return sample;\n    };\n    //http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Trigger_Event\n    Channel4.trigger = function () {\n        Channel4.isEnabled = true;\n        // Length counter maximum handled by write\n        if (Channel4.lengthCounter === 0) {\n            Channel4.lengthCounter = Channel4.MAX_LENGTH;\n        }\n        // Reset our timers\n        Channel4.frequencyTimer = Channel4.getNoiseChannelFrequencyPeriod();\n        // The volume envelope and sweep timers treat a period of 0 as 8.\n        // Meaning, if the period is zero, set it to the max (8).\n        if (Channel4.NRx2EnvelopePeriod === 0) {\n            Channel4.envelopeCounter = 8;\n        }\n        else {\n            Channel4.envelopeCounter = Channel4.NRx2EnvelopePeriod;\n        }\n        Channel4.isEnvelopeAutomaticUpdating = true;\n        Channel4.volume = Channel4.NRx2StartingVolume;\n        // Noise channel's LFSR bits are all set to 1.\n        Channel4.linearFeedbackShiftRegister = 0x7fff;\n        // Finally if DAC is off, channel is still disabled\n        if (!Channel4.isDacEnabled) {\n            Channel4.isEnabled = false;\n        }\n    };\n    // Function to determine if the current channel would update when getting the sample\n    // This is used to accumulate samples\n    Channel4.willChannelUpdate = function (numberOfCycles) {\n        //Increment our cycle counter\n        Channel4.cycleCounter += numberOfCycles;\n        // Dac enabled status cached by accumulator\n        return !(Channel4.frequencyTimer - Channel4.cycleCounter > 0);\n    };\n    Channel4.getNoiseChannelFrequencyPeriod = function () {\n        // Get our divisor from the divisor code, and shift by the clock shift\n        var response = Channel4.divisor << Channel4.NRx3ClockShift;\n        return response << Cpu.GBCDoubleSpeed;\n    };\n    Channel4.updateLength = function () {\n        var lengthCounter = Channel4.lengthCounter;\n        if (lengthCounter > 0 && Channel4.NRx4LengthEnabled) {\n            lengthCounter -= 1;\n        }\n        if (lengthCounter === 0) {\n            Channel4.isEnabled = false;\n        }\n        Channel4.lengthCounter = lengthCounter;\n    };\n    Channel4.updateEnvelope = function () {\n        var envelopeCounter = Channel4.envelopeCounter - 1;\n        if (envelopeCounter <= 0) {\n            // Reset back to the sweep period\n            // Obscure behavior\n            // Envelopes treat a period of 0 as 8 (They reset back to the max)\n            if (Channel4.NRx2EnvelopePeriod === 0) {\n                envelopeCounter = 8;\n            }\n            else {\n                envelopeCounter = Channel4.NRx2EnvelopePeriod;\n                // When the timer generates a clock and the envelope period is NOT zero, a new volume is calculated\n                // NOTE: There is some weiirrdd obscure behavior where zero can equal 8, so watch out for that\n                if (envelopeCounter !== 0 && Channel4.isEnvelopeAutomaticUpdating) {\n                    var volume = Channel4.volume;\n                    // Increment the volume\n                    if (Channel4.NRx2EnvelopeAddMode) {\n                        volume += 1;\n                    }\n                    else {\n                        volume -= 1;\n                    }\n                    // Don't allow the volume to go above 4 bits.\n                    volume = volume & 0x0f;\n                    // Check if we are below the max\n                    if (volume < 15) {\n                        Channel4.volume = volume;\n                    }\n                    else {\n                        Channel4.isEnvelopeAutomaticUpdating = false;\n                    }\n                }\n            }\n        }\n        Channel4.envelopeCounter = envelopeCounter;\n    };\n    // Cycle Counter for our sound accumulator\n    Channel4.cycleCounter = 0;\n    // Max Length of our Length Load\n    Channel4.MAX_LENGTH = 64;\n    // Channel 4\n    // 'white noise' channel with volume envelope functions.\n    // Only used by register reading\n    Channel4.memoryLocationNRx0 = 0xff1f;\n    // NR41 -> Sound length (R/W)\n    Channel4.memoryLocationNRx1 = 0xff20;\n    // --LL LLLL Length load (64-L)\n    Channel4.NRx1LengthLoad = 0;\n    // NR42 -> Volume Envelope (R/W)\n    Channel4.memoryLocationNRx2 = 0xff21;\n    // VVVV APPP Starting volume, Envelope add mode, period\n    Channel4.NRx2StartingVolume = 0;\n    Channel4.NRx2EnvelopeAddMode = false;\n    Channel4.NRx2EnvelopePeriod = 0;\n    // NR43 -> Polynomial Counter (R/W)\n    Channel4.memoryLocationNRx3 = 0xff22;\n    // SSSS WDDD Clock shift, Width mode of LFSR, Divisor code\n    Channel4.NRx3ClockShift = 0;\n    Channel4.NRx3WidthMode = false;\n    Channel4.NRx3DivisorCode = 0;\n    // NR44 -> Trigger, Length Enable\n    Channel4.memoryLocationNRx4 = 0xff23;\n    // TL-- ---- Trigger, Length enable\n    Channel4.NRx4LengthEnabled = false;\n    // Channel Properties\n    Channel4.channelNumber = 4;\n    Channel4.isEnabled = false;\n    Channel4.isDacEnabled = false;\n    Channel4.frequencyTimer = 0x00;\n    Channel4.envelopeCounter = 0x00;\n    Channel4.isEnvelopeAutomaticUpdating = false;\n    Channel4.lengthCounter = 0x00;\n    Channel4.volume = 0x00;\n    Channel4.divisor = 0;\n    // Noise properties\n    // NOTE: Is only 15 bits\n    Channel4.linearFeedbackShiftRegister = 0x00;\n    // Save States\n    Channel4.saveStateSlot = 10;\n    return Channel4;\n}());\n\n// Another class simply for accumulating samples\n// Default everything to silence\nvar SoundAccumulator = /** @class */ (function () {\n    function SoundAccumulator() {\n    }\n    SoundAccumulator.channel1Sample = 15;\n    SoundAccumulator.channel2Sample = 15;\n    SoundAccumulator.channel3Sample = 15;\n    SoundAccumulator.channel4Sample = 15;\n    SoundAccumulator.channel1DacEnabled = false;\n    SoundAccumulator.channel2DacEnabled = false;\n    SoundAccumulator.channel3DacEnabled = false;\n    SoundAccumulator.channel4DacEnabled = false;\n    SoundAccumulator.leftChannelSampleUnsignedByte = 127;\n    SoundAccumulator.rightChannelSampleUnsignedByte = 127;\n    SoundAccumulator.mixerVolumeChanged = false;\n    SoundAccumulator.mixerEnabledChanged = false;\n    // If a channel was updated, need to also track if we need to need to mix them again\n    SoundAccumulator.needToRemixSamples = false;\n    return SoundAccumulator;\n}());\n// Inlined because closure compiler inlines\nfunction initializeSoundAccumulator() {\n    SoundAccumulator.channel1Sample = 15;\n    SoundAccumulator.channel2Sample = 15;\n    SoundAccumulator.channel3Sample = 15;\n    SoundAccumulator.channel4Sample = 15;\n    SoundAccumulator.channel1DacEnabled = false;\n    SoundAccumulator.channel2DacEnabled = false;\n    SoundAccumulator.channel3DacEnabled = false;\n    SoundAccumulator.channel4DacEnabled = false;\n    SoundAccumulator.leftChannelSampleUnsignedByte = 127;\n    SoundAccumulator.rightChannelSampleUnsignedByte = 127;\n    SoundAccumulator.mixerVolumeChanged = true;\n    SoundAccumulator.mixerEnabledChanged = true;\n    SoundAccumulator.needToRemixSamples = false;\n}\n// Inlined because closure compiler inlines\nfunction accumulateSound(numberOfCycles) {\n    // Check if any of the individual channels will update\n    var channel1WillUpdate = Channel1.willChannelUpdate(numberOfCycles) || didChannelDacChange(Channel1.channelNumber);\n    var channel2WillUpdate = Channel2.willChannelUpdate(numberOfCycles) || didChannelDacChange(Channel2.channelNumber);\n    var channel3WillUpdate = Channel3.willChannelUpdate(numberOfCycles) || didChannelDacChange(Channel3.channelNumber);\n    var channel4WillUpdate = Channel4.willChannelUpdate(numberOfCycles) || didChannelDacChange(Channel4.channelNumber);\n    if (channel1WillUpdate) {\n        SoundAccumulator.channel1Sample = Channel1.getSampleFromCycleCounter();\n    }\n    if (channel2WillUpdate) {\n        SoundAccumulator.channel2Sample = Channel2.getSampleFromCycleCounter();\n    }\n    if (channel3WillUpdate) {\n        SoundAccumulator.channel3Sample = Channel3.getSampleFromCycleCounter();\n    }\n    if (channel4WillUpdate) {\n        SoundAccumulator.channel4Sample = Channel4.getSampleFromCycleCounter();\n    }\n    // If any channel updated, we need to re-mix our samples\n    if (channel1WillUpdate || channel2WillUpdate || channel3WillUpdate || channel4WillUpdate) {\n        SoundAccumulator.needToRemixSamples = true;\n    }\n    // Do Some downsampling magic\n    var downSampleCycleCounter = Sound.downSampleCycleCounter;\n    downSampleCycleCounter += numberOfCycles;\n    var maxDownSampleCycles = Sound.maxDownSampleCycles();\n    if (downSampleCycleCounter >= maxDownSampleCycles) {\n        // Reset the downsample counter\n        // Don't set to zero to catch overflowed cycles\n        downSampleCycleCounter -= maxDownSampleCycles;\n        if (SoundAccumulator.needToRemixSamples || SoundAccumulator.mixerVolumeChanged || SoundAccumulator.mixerEnabledChanged) {\n            mixChannelSamples(SoundAccumulator.channel1Sample, SoundAccumulator.channel2Sample, SoundAccumulator.channel3Sample, SoundAccumulator.channel4Sample);\n        }\n        else {\n            Sound.downSampleCycleCounter = downSampleCycleCounter;\n        }\n        // Finally Simply place the accumulated sample in memory\n        // Set our volumes in memory\n        // +1 so it can not be zero\n        setLeftAndRightOutputForAudioQueue(SoundAccumulator.leftChannelSampleUnsignedByte + 1, SoundAccumulator.rightChannelSampleUnsignedByte + 1, AUDIO_BUFFER_LOCATION);\n        var audioQueueIndex = Sound.audioQueueIndex + 1;\n        // Don't allow our audioQueueIndex to overflow into other parts of the wasmBoy memory map\n        // https://docs.google.com/spreadsheets/d/17xrEzJk5-sCB9J2mMJcVnzhbE-XH_NvczVSQH9OHvRk/edit#gid=0\n        // Not 0xFFFF because we need half of 64kb since we store left and right channel\n        var maxIndex = i32Portable(Sound.wasmBoyMemoryMaxBufferSize >> 1) - 1;\n        if (audioQueueIndex >= maxIndex) {\n            audioQueueIndex -= 1;\n        }\n        Sound.audioQueueIndex = audioQueueIndex;\n    }\n    Sound.downSampleCycleCounter = downSampleCycleCounter;\n}\n// Function used by SoundAccumulator to find out if a channel Dac Changed\nfunction didChannelDacChange(channelNumber) {\n    switch (channelNumber) {\n        case Channel1.channelNumber: {\n            var isDacEnabled = Channel1.isDacEnabled;\n            var channel1EnabledChanged = SoundAccumulator.channel1DacEnabled !== isDacEnabled;\n            SoundAccumulator.channel1DacEnabled = isDacEnabled;\n            return channel1EnabledChanged;\n        }\n        case Channel2.channelNumber: {\n            var isDacEnabled = Channel2.isDacEnabled;\n            var channel2EnabledChanged = SoundAccumulator.channel2DacEnabled !== isDacEnabled;\n            SoundAccumulator.channel2DacEnabled = isDacEnabled;\n            return channel2EnabledChanged;\n        }\n        case Channel3.channelNumber: {\n            var isDacEnabled = Channel3.isDacEnabled;\n            var channel3EnabledChanged = SoundAccumulator.channel3DacEnabled !== isDacEnabled;\n            SoundAccumulator.channel3DacEnabled = isDacEnabled;\n            return channel3EnabledChanged;\n        }\n        case Channel4.channelNumber: {\n            var isDacEnabled = Channel4.isDacEnabled;\n            var channel4EnabledChanged = SoundAccumulator.channel4DacEnabled !== isDacEnabled;\n            SoundAccumulator.channel4DacEnabled = isDacEnabled;\n            return channel4EnabledChanged;\n        }\n    }\n    return false;\n}\n\n// https://emu-docs.org/Game%20Boy/gb_sound.txt\nvar Sound = /** @class */ (function () {\n    function Sound() {\n    }\n    // Number of cycles to run in each batch process\n    // This number should be in sync so that sound doesn't run too many cyles at once\n    // and does not exceed the minimum number of cyles for either down sampling, or\n    // How often we change the frame, or a channel's update process\n    // Number of cycles is 87, because:\n    // Number of cycles before downsampling a single sample\n    // TODO: Find out how to make this number bigger\n    // Or, don't call this in syncCycles, and make the lib responsible.\n    Sound.batchProcessCycles = function () {\n        // return Cpu.GBCDoubleSpeed ? 174 : 87;\n        return 87 << Cpu.GBCDoubleSpeed;\n    };\n    Sound.updateNR50 = function (value) {\n        Sound.NR50LeftMixerVolume = (value >> 4) & 0x07;\n        Sound.NR50RightMixerVolume = value & 0x07;\n    };\n    Sound.updateNR51 = function (value) {\n        Sound.NR51IsChannel4EnabledOnLeftOutput = checkBitOnByte(7, value);\n        Sound.NR51IsChannel3EnabledOnLeftOutput = checkBitOnByte(6, value);\n        Sound.NR51IsChannel2EnabledOnLeftOutput = checkBitOnByte(5, value);\n        Sound.NR51IsChannel1EnabledOnLeftOutput = checkBitOnByte(4, value);\n        Sound.NR51IsChannel4EnabledOnRightOutput = checkBitOnByte(3, value);\n        Sound.NR51IsChannel3EnabledOnRightOutput = checkBitOnByte(2, value);\n        Sound.NR51IsChannel2EnabledOnRightOutput = checkBitOnByte(1, value);\n        Sound.NR51IsChannel1EnabledOnRightOutput = checkBitOnByte(0, value);\n    };\n    Sound.updateNR52 = function (value) {\n        Sound.NR52IsSoundEnabled = checkBitOnByte(7, value);\n    };\n    Sound.maxFrameSequenceCycles = function () {\n        // return Cpu.GBCDoubleSpeed ? 16384 : 8192;\n        return 8192 << Cpu.GBCDoubleSpeed;\n    };\n    Sound.maxDownSampleCycles = function () {\n        return Cpu.CLOCK_SPEED() / Sound.sampleRate;\n    };\n    // Function to save the state of the class\n    Sound.saveState = function () {\n        // NR50\n        store(getSaveStateMemoryOffset(0x00, Sound.saveStateSlot), Sound.NR50LeftMixerVolume);\n        store(getSaveStateMemoryOffset(0x04, Sound.saveStateSlot), Sound.NR50RightMixerVolume);\n        // NR51\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x08, Sound.saveStateSlot), Sound.NR51IsChannel1EnabledOnLeftOutput);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x09, Sound.saveStateSlot), Sound.NR51IsChannel2EnabledOnLeftOutput);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0a, Sound.saveStateSlot), Sound.NR51IsChannel3EnabledOnLeftOutput);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0b, Sound.saveStateSlot), Sound.NR51IsChannel4EnabledOnLeftOutput);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0c, Sound.saveStateSlot), Sound.NR51IsChannel1EnabledOnRightOutput);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0d, Sound.saveStateSlot), Sound.NR51IsChannel2EnabledOnRightOutput);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0e, Sound.saveStateSlot), Sound.NR51IsChannel3EnabledOnRightOutput);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0f, Sound.saveStateSlot), Sound.NR51IsChannel4EnabledOnRightOutput);\n        // NR52\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x10, Sound.saveStateSlot), Sound.NR52IsSoundEnabled);\n        // Frame Sequencer\n        store(getSaveStateMemoryOffset(0x11, Sound.saveStateSlot), Sound.frameSequenceCycleCounter);\n        store(getSaveStateMemoryOffset(0x16, Sound.saveStateSlot), Sound.frameSequencer);\n        // Down Sampler\n        store(getSaveStateMemoryOffset(0x17, Sound.saveStateSlot), Sound.downSampleCycleCounter);\n        // Sound Accumulator\n        store(getSaveStateMemoryOffset(0x18, Sound.saveStateSlot), SoundAccumulator.channel1Sample);\n        store(getSaveStateMemoryOffset(0x19, Sound.saveStateSlot), SoundAccumulator.channel2Sample);\n        store(getSaveStateMemoryOffset(0x1a, Sound.saveStateSlot), SoundAccumulator.channel3Sample);\n        store(getSaveStateMemoryOffset(0x1b, Sound.saveStateSlot), SoundAccumulator.channel4Sample);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x1c, Sound.saveStateSlot), SoundAccumulator.channel1DacEnabled);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x1d, Sound.saveStateSlot), SoundAccumulator.channel2DacEnabled);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x1e, Sound.saveStateSlot), SoundAccumulator.channel3DacEnabled);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x1f, Sound.saveStateSlot), SoundAccumulator.channel4DacEnabled);\n        store(getSaveStateMemoryOffset(0x20, Sound.saveStateSlot), SoundAccumulator.leftChannelSampleUnsignedByte);\n        store(getSaveStateMemoryOffset(0x21, Sound.saveStateSlot), SoundAccumulator.rightChannelSampleUnsignedByte);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x22, Sound.saveStateSlot), SoundAccumulator.mixerVolumeChanged);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x23, Sound.saveStateSlot), SoundAccumulator.mixerEnabledChanged);\n    };\n    // Function to load the save state from memory\n    Sound.loadState = function () {\n        // NR50\n        Sound.NR50LeftMixerVolume = load(getSaveStateMemoryOffset(0x00, Sound.saveStateSlot));\n        Sound.NR50RightMixerVolume = load(getSaveStateMemoryOffset(0x04, Sound.saveStateSlot));\n        // NR51\n        Sound.NR51IsChannel1EnabledOnLeftOutput = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x08, Sound.saveStateSlot));\n        Sound.NR51IsChannel2EnabledOnLeftOutput = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x09, Sound.saveStateSlot));\n        Sound.NR51IsChannel3EnabledOnLeftOutput = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0a, Sound.saveStateSlot));\n        Sound.NR51IsChannel4EnabledOnLeftOutput = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0b, Sound.saveStateSlot));\n        Sound.NR51IsChannel1EnabledOnRightOutput = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0c, Sound.saveStateSlot));\n        Sound.NR51IsChannel2EnabledOnRightOutput = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0d, Sound.saveStateSlot));\n        Sound.NR51IsChannel3EnabledOnRightOutput = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0e, Sound.saveStateSlot));\n        Sound.NR51IsChannel4EnabledOnRightOutput = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0f, Sound.saveStateSlot));\n        // NR52\n        Sound.NR52IsSoundEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x10, Sound.saveStateSlot));\n        // Frame Sequencer\n        Sound.frameSequenceCycleCounter = load(getSaveStateMemoryOffset(0x11, Sound.saveStateSlot));\n        Sound.frameSequencer = load(getSaveStateMemoryOffset(0x16, Sound.saveStateSlot));\n        // DownSampler\n        Sound.downSampleCycleCounter = load(getSaveStateMemoryOffset(0x17, Sound.saveStateSlot));\n        // Sound Accumulator\n        SoundAccumulator.channel1Sample = load(getSaveStateMemoryOffset(0x18, Sound.saveStateSlot));\n        SoundAccumulator.channel2Sample = load(getSaveStateMemoryOffset(0x19, Sound.saveStateSlot));\n        SoundAccumulator.channel3Sample = load(getSaveStateMemoryOffset(0x1a, Sound.saveStateSlot));\n        SoundAccumulator.channel4Sample = load(getSaveStateMemoryOffset(0x1b, Sound.saveStateSlot));\n        SoundAccumulator.channel1DacEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x1c, Sound.saveStateSlot));\n        SoundAccumulator.channel2DacEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x1d, Sound.saveStateSlot));\n        SoundAccumulator.channel3DacEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x1e, Sound.saveStateSlot));\n        SoundAccumulator.channel4DacEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x1f, Sound.saveStateSlot));\n        SoundAccumulator.leftChannelSampleUnsignedByte = load(getSaveStateMemoryOffset(0x20, Sound.saveStateSlot));\n        SoundAccumulator.rightChannelSampleUnsignedByte = load(getSaveStateMemoryOffset(0x21, Sound.saveStateSlot));\n        SoundAccumulator.mixerVolumeChanged = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x22, Sound.saveStateSlot));\n        SoundAccumulator.mixerEnabledChanged = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x23, Sound.saveStateSlot));\n        // Finally clear the audio buffer\n        clearAudioBuffer();\n    };\n    // Current cycles\n    // This will be used for batch processing\n    // https://github.com/binji/binjgb/commit/e028f45e805bc0b0aa4697224a209f9ae514c954\n    // TODO: May Also need to do this for Reads\n    Sound.currentCycles = 0;\n    // Channel control / On-OFF / Volume (RW)\n    Sound.memoryLocationNR50 = 0xff24;\n    Sound.NR50LeftMixerVolume = 0;\n    Sound.NR50RightMixerVolume = 0;\n    // 0xFF25 selects which output each channel goes to, Referred to as NR51\n    Sound.memoryLocationNR51 = 0xff25;\n    Sound.NR51IsChannel1EnabledOnLeftOutput = true;\n    Sound.NR51IsChannel2EnabledOnLeftOutput = true;\n    Sound.NR51IsChannel3EnabledOnLeftOutput = true;\n    Sound.NR51IsChannel4EnabledOnLeftOutput = true;\n    Sound.NR51IsChannel1EnabledOnRightOutput = true;\n    Sound.NR51IsChannel2EnabledOnRightOutput = true;\n    Sound.NR51IsChannel3EnabledOnRightOutput = true;\n    Sound.NR51IsChannel4EnabledOnRightOutput = true;\n    // Sound on/off\n    Sound.memoryLocationNR52 = 0xff26;\n    Sound.NR52IsSoundEnabled = true;\n    // $FF30 -- $FF3F is the load register space for the 4-bit samples for channel 3\n    Sound.memoryLocationChannel3LoadRegisterStart = 0xff30;\n    // Need to count how often we need to increment our frame sequencer\n    // Which you can read about below\n    Sound.frameSequenceCycleCounter = 0x0000;\n    // Frame sequencer controls what should be updated and and ticked\n    // Every time the sound is updated :) It is updated everytime the\n    // Cycle counter reaches the max cycle\n    Sound.frameSequencer = 0x00;\n    // Also need to downsample our audio to average audio qualty\n    // https://www.reddit.com/r/EmuDev/comments/5gkwi5/gb_apu_sound_emulation/\n    // Want to do 44100hz, so CpuRate / Sound Rate, 4194304 / 44100 ~ 91 cycles\n    Sound.downSampleCycleCounter = 0x00;\n    Sound.sampleRate = 44100;\n    // Our current sample number we are passing back to the wasmboy memory map\n    // Found that a static number of samples doesn't work well on mobile\n    // Will just update the queue index, grab as much as we can whenever we need more audio, then reset\n    // NOTE: Giving a really large sample rate gives more latency, but less pops!\n    //static readonly MAX_NUMBER_OF_SAMPLES: i32 = 4096;\n    Sound.audioQueueIndex = 0x0000;\n    Sound.wasmBoyMemoryMaxBufferSize = 0x20000;\n    // Save States\n    Sound.saveStateSlot = 6;\n    return Sound;\n}());\n// Initialize sound registers\n// From: https://emu-docs.org/Game%20Boy/gb_sound.txt\n// Inlined because closure compiler inlines\nfunction initializeSound() {\n    // Reset Stateful variables\n    Sound.currentCycles = 0;\n    Sound.NR50LeftMixerVolume = 0;\n    Sound.NR50RightMixerVolume = 0;\n    Sound.NR51IsChannel1EnabledOnLeftOutput = true;\n    Sound.NR51IsChannel2EnabledOnLeftOutput = true;\n    Sound.NR51IsChannel3EnabledOnLeftOutput = true;\n    Sound.NR51IsChannel4EnabledOnLeftOutput = true;\n    Sound.NR51IsChannel1EnabledOnRightOutput = true;\n    Sound.NR51IsChannel2EnabledOnRightOutput = true;\n    Sound.NR51IsChannel3EnabledOnRightOutput = true;\n    Sound.NR51IsChannel4EnabledOnRightOutput = true;\n    Sound.NR52IsSoundEnabled = true;\n    Sound.frameSequenceCycleCounter = 0x0000;\n    Sound.downSampleCycleCounter = 0x00;\n    Sound.frameSequencer = 0x00;\n    Sound.audioQueueIndex = 0x0000;\n    // intiialize our channels\n    Channel1.initialize();\n    Channel2.initialize();\n    Channel3.initialize();\n    Channel4.initialize();\n    // Other Sound Registers\n    eightBitStoreIntoGBMemory(Sound.memoryLocationNR50, 0x77);\n    Sound.updateNR50(0x77);\n    eightBitStoreIntoGBMemory(Sound.memoryLocationNR51, 0xf3);\n    Sound.updateNR51(0xf3);\n    eightBitStoreIntoGBMemory(Sound.memoryLocationNR52, 0xf1);\n    Sound.updateNR52(0xf1);\n    // Override/reset some variables if the boot ROM is enabled\n    // For both GB and GBC\n    if (Cpu.BootROMEnabled) {\n        eightBitStoreIntoGBMemory(Sound.memoryLocationNR50, 0x00);\n        Sound.updateNR50(0x00);\n        eightBitStoreIntoGBMemory(Sound.memoryLocationNR51, 0x00);\n        Sound.updateNR51(0x00);\n        eightBitStoreIntoGBMemory(Sound.memoryLocationNR52, 0x70);\n        Sound.updateNR52(0x70);\n    }\n    initializeSoundAccumulator();\n}\n// Function to batch process our audio after we skipped so many cycles\nfunction batchProcessAudio() {\n    var batchProcessCycles = Sound.batchProcessCycles();\n    var currentCycles = Sound.currentCycles;\n    while (currentCycles >= batchProcessCycles) {\n        updateSound(batchProcessCycles);\n        currentCycles -= batchProcessCycles;\n    }\n    Sound.currentCycles = currentCycles;\n}\n// Function for updating sound\nfunction updateSound(numberOfCycles) {\n    // Check if our frameSequencer updated\n    var frameSequencerUpdated = updateFrameSequencer(numberOfCycles);\n    if (Config.audioAccumulateSamples && !frameSequencerUpdated) {\n        accumulateSound(numberOfCycles);\n    }\n    else {\n        calculateSound(numberOfCycles);\n    }\n}\n// Funciton to get the current Audio Queue index\nfunction getNumberOfSamplesInAudioBuffer() {\n    return Sound.audioQueueIndex;\n}\n// Function to reset the audio queue\nfunction clearAudioBuffer() {\n    Sound.audioQueueIndex = 0;\n}\n// Inlined because closure compiler inlines\nfunction calculateSound(numberOfCycles) {\n    // Update all of our channels\n    // All samples will be returned as 0 to 30\n    // 0 being -1.0, and 30 being 1.0\n    // (see blurb at top)\n    var channel1Sample = i32Portable(Channel1.getSample(numberOfCycles));\n    var channel2Sample = i32Portable(Channel2.getSample(numberOfCycles));\n    var channel3Sample = i32Portable(Channel3.getSample(numberOfCycles));\n    var channel4Sample = i32Portable(Channel4.getSample(numberOfCycles));\n    // TODO: Allow individual channels to be muted\n    // let channel1Sample: i32 = 15;\n    // let channel2Sample: i32 = 15;\n    // let channel3Sample: i32 = 15;\n    // let channel4Sample: i32 = 15;\n    // Save the samples in the accumulator\n    SoundAccumulator.channel1Sample = channel1Sample;\n    SoundAccumulator.channel2Sample = channel2Sample;\n    SoundAccumulator.channel3Sample = channel3Sample;\n    SoundAccumulator.channel4Sample = channel4Sample;\n    // Do Some downsampling magic\n    var downSampleCycleCounter = Sound.downSampleCycleCounter + numberOfCycles;\n    if (downSampleCycleCounter >= Sound.maxDownSampleCycles()) {\n        // Reset the downsample counter\n        // Don't set to zero to catch overflowed cycles\n        downSampleCycleCounter -= Sound.maxDownSampleCycles();\n        // Mix our samples\n        var mixedSample = mixChannelSamples(channel1Sample, channel2Sample, channel3Sample, channel4Sample);\n        var leftChannelSampleUnsignedByte = splitHighByte(mixedSample);\n        var rightChannelSampleUnsignedByte = splitLowByte(mixedSample);\n        // Set our volumes in memory\n        // +1 so it can not be zero\n        setLeftAndRightOutputForAudioQueue(leftChannelSampleUnsignedByte + 1, rightChannelSampleUnsignedByte + 1, AUDIO_BUFFER_LOCATION);\n        if (Config.enableAudioDebugging) {\n            // Channel 1\n            mixedSample = mixChannelSamples(channel1Sample, 15, 15, 15);\n            leftChannelSampleUnsignedByte = splitHighByte(mixedSample);\n            rightChannelSampleUnsignedByte = splitLowByte(mixedSample);\n            setLeftAndRightOutputForAudioQueue(leftChannelSampleUnsignedByte + 1, rightChannelSampleUnsignedByte + 1, CHANNEL_1_BUFFER_LOCATION);\n            // Channel 2\n            mixedSample = mixChannelSamples(15, channel2Sample, 15, 15);\n            leftChannelSampleUnsignedByte = splitHighByte(mixedSample);\n            rightChannelSampleUnsignedByte = splitLowByte(mixedSample);\n            setLeftAndRightOutputForAudioQueue(leftChannelSampleUnsignedByte + 1, rightChannelSampleUnsignedByte + 1, CHANNEL_2_BUFFER_LOCATION);\n            // Channel 3\n            mixedSample = mixChannelSamples(15, 15, channel3Sample, 15);\n            leftChannelSampleUnsignedByte = splitHighByte(mixedSample);\n            rightChannelSampleUnsignedByte = splitLowByte(mixedSample);\n            setLeftAndRightOutputForAudioQueue(leftChannelSampleUnsignedByte + 1, rightChannelSampleUnsignedByte + 1, CHANNEL_3_BUFFER_LOCATION);\n            // Channel 4\n            mixedSample = mixChannelSamples(15, 15, 15, channel4Sample);\n            leftChannelSampleUnsignedByte = splitHighByte(mixedSample);\n            rightChannelSampleUnsignedByte = splitLowByte(mixedSample);\n            setLeftAndRightOutputForAudioQueue(leftChannelSampleUnsignedByte + 1, rightChannelSampleUnsignedByte + 1, CHANNEL_4_BUFFER_LOCATION);\n        }\n        var audioQueueIndex = Sound.audioQueueIndex + 1;\n        // Don't allow our audioQueueIndex to overflow into other parts of the wasmBoy memory map\n        // https://docs.google.com/spreadsheets/d/17xrEzJk5-sCB9J2mMJcVnzhbE-XH_NvczVSQH9OHvRk/edit#gid=0\n        // Not 0xFFFF because we need half of 64kb since we store left and right channel\n        var maxIndex = i32Portable(Sound.wasmBoyMemoryMaxBufferSize >> 1) - 1;\n        if (audioQueueIndex >= maxIndex) {\n            audioQueueIndex -= 1;\n        }\n        Sound.audioQueueIndex = audioQueueIndex;\n    }\n    Sound.downSampleCycleCounter = downSampleCycleCounter;\n}\n// Inlined because closure compiler inlines\nfunction updateFrameSequencer(numberOfCycles) {\n    // APU runs at 4194304 / 512\n    // Or Cpu.clockSpeed / 512\n    // Which means, we need to update once every 8192 cycles :)\n    var maxFrameSequenceCycles = Sound.maxFrameSequenceCycles();\n    var frameSequenceCycleCounter = Sound.frameSequenceCycleCounter + numberOfCycles;\n    if (frameSequenceCycleCounter >= maxFrameSequenceCycles) {\n        // Reset the frameSequenceCycleCounter\n        // Not setting to zero as we do not want to drop cycles\n        frameSequenceCycleCounter -= maxFrameSequenceCycles;\n        Sound.frameSequenceCycleCounter = frameSequenceCycleCounter;\n        // Update our frame sequencer\n        // https://gist.github.com/drhelius/3652407\n        var frameSequencer = (Sound.frameSequencer + 1) & 7;\n        switch (frameSequencer) {\n            case 0:\n                // Update Length on Channels\n                Channel1.updateLength();\n                Channel2.updateLength();\n                Channel3.updateLength();\n                Channel4.updateLength();\n                break;\n            /* Do Nothing on one */\n            case 2:\n                // Update Sweep and Length on Channels\n                Channel1.updateLength();\n                Channel2.updateLength();\n                Channel3.updateLength();\n                Channel4.updateLength();\n                Channel1.updateSweep();\n                break;\n            /* Do Nothing on three */\n            case 4:\n                // Update Length on Channels\n                Channel1.updateLength();\n                Channel2.updateLength();\n                Channel3.updateLength();\n                Channel4.updateLength();\n                break;\n            /* Do Nothing on five */\n            case 6:\n                // Update Sweep and Length on Channels\n                Channel1.updateLength();\n                Channel2.updateLength();\n                Channel3.updateLength();\n                Channel4.updateLength();\n                Channel1.updateSweep();\n                break;\n            case 7:\n                // Update Envelope on channels\n                Channel1.updateEnvelope();\n                Channel2.updateEnvelope();\n                Channel4.updateEnvelope();\n                break;\n        }\n        // Save our frame sequencer\n        Sound.frameSequencer = frameSequencer;\n        return true;\n    }\n    else {\n        Sound.frameSequenceCycleCounter = frameSequenceCycleCounter;\n    }\n    return false;\n}\nfunction mixChannelSamples(channel1Sample, channel2Sample, channel3Sample, channel4Sample) {\n    // Do Some Cool mixing\n    // NR50 FF24 ALLL BRRR Vin L enable, Left vol, Vin R enable, Right vol\n    // NR51 FF25 NW21 NW21 Left enables, Right enables\n    // NR52 FF26 P--- NW21 Power control/status, Channel length statuses\n    // NW21 = 4 bits on byte\n    // 3 -> Channel 4, 2 -> Channel 3, 1 -> Channel 2, 0 -> Channel 1\n    if (channel1Sample === void 0) { channel1Sample = 15; }\n    if (channel2Sample === void 0) { channel2Sample = 15; }\n    if (channel3Sample === void 0) { channel3Sample = 15; }\n    if (channel4Sample === void 0) { channel4Sample = 15; }\n    // Matt's Proccess\n    // I push out 1024 samples at a time and use 96000 hz sampling rate, so I guess i'm a bit less than one frame,\n    // but I let the queue fill up with 4 x 1024 samples before I start waiting for the audio\n    // TODO: Vin Mixing\n    SoundAccumulator.mixerVolumeChanged = false;\n    // Get our channel volume for left/right\n    var leftChannelSample = 0;\n    var rightChannelSample = 0;\n    // Find the sample for the left if enabled\n    // other wise add silence (15) for the channel\n    leftChannelSample += Sound.NR51IsChannel1EnabledOnLeftOutput ? channel1Sample : 15;\n    leftChannelSample += Sound.NR51IsChannel2EnabledOnLeftOutput ? channel2Sample : 15;\n    leftChannelSample += Sound.NR51IsChannel3EnabledOnLeftOutput ? channel3Sample : 15;\n    leftChannelSample += Sound.NR51IsChannel4EnabledOnLeftOutput ? channel4Sample : 15;\n    // Find the sample for the right if enabled\n    // other wise add silence (15) for the channel\n    rightChannelSample += Sound.NR51IsChannel1EnabledOnRightOutput ? channel1Sample : 15;\n    rightChannelSample += Sound.NR51IsChannel2EnabledOnRightOutput ? channel2Sample : 15;\n    rightChannelSample += Sound.NR51IsChannel3EnabledOnRightOutput ? channel3Sample : 15;\n    rightChannelSample += Sound.NR51IsChannel4EnabledOnRightOutput ? channel4Sample : 15;\n    // Update our accumulator\n    SoundAccumulator.mixerEnabledChanged = false;\n    SoundAccumulator.needToRemixSamples = false;\n    // Finally multiply our volumes by the mixer volume\n    // Mixer volume can be at most 7 + 1\n    // Can be at most 7, because we only have 3 bits, 111 = 7\n    // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Mixer\n    // Done in the getSampleAsUnsignedByte(), since we are doing some weirdness there :)\n    // Convert our samples from unsigned 32 to unsigned byte\n    // Reason being, We want to be able to pass in wasm memory as usigned byte. Javascript will handle the conversion back\n    var leftChannelSampleUnsignedByte = getSampleAsUnsignedByte(leftChannelSample, Sound.NR50LeftMixerVolume + 1);\n    var rightChannelSampleUnsignedByte = getSampleAsUnsignedByte(rightChannelSample, Sound.NR50RightMixerVolume + 1);\n    // Save these samples in the accumulator\n    SoundAccumulator.leftChannelSampleUnsignedByte = leftChannelSampleUnsignedByte;\n    SoundAccumulator.rightChannelSampleUnsignedByte = rightChannelSampleUnsignedByte;\n    return concatenateBytes(leftChannelSampleUnsignedByte, rightChannelSampleUnsignedByte);\n}\nfunction getSampleAsUnsignedByte(sample, mixerVolume) {\n    // If the sample is silence, return silence as unsigned byte\n    // Silence is common, and should be checked for performance\n    if (sample === 60) {\n        return 127;\n    }\n    // convert to a signed, precise scale of -6000 to 6000 (cheap way of -1.0 to 1.0)\n    // Multiply by the mixer volume fraction (to find the actual volume)\n    var precision = 100000;\n    var convertedSample = sample - 60;\n    convertedSample = convertedSample * precision;\n    // Multiply by the mixer volume fraction (to find the actual volume)\n    convertedSample = (convertedSample * mixerVolume) >> 3;\n    // Convert back to scale of 0 to 120\n    convertedSample = i32Portable(convertedSample / precision) + 60;\n    // Finally, convert to an unsigned byte scale\n    // With Four Channels (0 to 30) and no global volume. Max is 120\n    // max unsigned byte goal is 254 (see blurb at top).\n    // 120 / 254 should give the correct conversion\n    // For example, 120 / 254 = 0.47244094488188976\n    // Multiply by 1000 to increase the float into an int\n    // so, 120 * 1000 / (0.47244094488188976 * 1000) should give approximate answer for max mixer volume\n    var maxDivider = i32Portable((120 * precision) / 254);\n    convertedSample = i32Portable((convertedSample * precision) / maxDivider);\n    // Ensure we have an i32 and not a float for JS builds\n    convertedSample = i32Portable(convertedSample);\n    return convertedSample;\n}\n// Function to set our left and right channels at the correct queue index\nfunction setLeftAndRightOutputForAudioQueue(leftVolume, rightVolume, bufferLocation) {\n    // Get our stereo index\n    var audioQueueOffset = bufferLocation + (Sound.audioQueueIndex << 1);\n    // Store our volumes\n    // +1 that way we don't have empty data to ensure that the value is set\n    store(audioQueueOffset + 0, (leftVolume + 1));\n    store(audioQueueOffset + 1, (rightVolume + 1));\n}\n\n// Functions involved in R/W of sound registers\n// Function to check and handle writes to sound registers\n// Inlined because closure compiler inlines\n// NOTE: For write traps, return false = don't write to memory,\n// return true = allow the write to memory\nfunction SoundRegisterWriteTraps(offset, value) {\n    if (offset !== Sound.memoryLocationNR52 && !Sound.NR52IsSoundEnabled) {\n        // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Power_Control\n        // When sound is turned off / enabled\n        // Block all writes to any sound register EXCEPT NR52!\n        // This is under the assumption that the check for\n        // offset >= 0xFF10 && offset <= 0xFF26\n        // is done in writeTraps.ts (which it is)\n        // NOTE: Except on DMG, length can still be written (whatever that means)\n        return false;\n    }\n    switch (offset) {\n        // Handle NRx0 on Channels\n        case Channel1.memoryLocationNRx0:\n            Channel1.updateNRx0(value);\n            return true;\n        case Channel3.memoryLocationNRx0:\n            Channel3.updateNRx0(value);\n            return true;\n        // Handle NRx1 (Length Counter) on Channels\n        case Channel1.memoryLocationNRx1:\n            Channel1.updateNRx1(value);\n            return true;\n        case Channel2.memoryLocationNRx1:\n            Channel2.updateNRx1(value);\n            return true;\n        case Channel3.memoryLocationNRx1:\n            Channel3.updateNRx1(value);\n            return true;\n        case Channel4.memoryLocationNRx1:\n            Channel4.updateNRx1(value);\n            return true;\n        // Handle NRx2 (Envelope / Volume) on Channels\n        case Channel1.memoryLocationNRx2:\n            Channel1.updateNRx2(value);\n            return true;\n        case Channel2.memoryLocationNRx2:\n            Channel2.updateNRx2(value);\n            return true;\n        case Channel3.memoryLocationNRx2:\n            // Check if channel 3's volume code was written too\n            // This is handcy to know for accumulation of samples\n            Channel3.volumeCodeChanged = true;\n            Channel3.updateNRx2(value);\n            return true;\n        case Channel4.memoryLocationNRx2:\n            Channel4.updateNRx2(value);\n            return true;\n        // Handle NRx3 (Frequency / Noise Properties) on Channels\n        case Channel1.memoryLocationNRx3:\n            Channel1.updateNRx3(value);\n            return true;\n        case Channel2.memoryLocationNRx3:\n            Channel2.updateNRx3(value);\n            return true;\n        case Channel3.memoryLocationNRx3:\n            Channel3.updateNRx3(value);\n            return true;\n        case Channel4.memoryLocationNRx3:\n            Channel4.updateNRx3(value);\n            return true;\n        // Check our NRx4 registers to trap our trigger bits\n        case Channel1.memoryLocationNRx4:\n            Channel1.updateNRx4(value);\n            return true;\n        case Channel2.memoryLocationNRx4:\n            Channel2.updateNRx4(value);\n            return true;\n        case Channel3.memoryLocationNRx4:\n            Channel3.updateNRx4(value);\n            return true;\n        case Channel4.memoryLocationNRx4:\n            Channel4.updateNRx4(value);\n            return true;\n        // Tell the sound accumulator if volumes changes\n        case Sound.memoryLocationNR50:\n            Sound.updateNR50(value);\n            SoundAccumulator.mixerVolumeChanged = true;\n            return true;\n        // Tell the sound accumulator if volumes changes\n        case Sound.memoryLocationNR51:\n            Sound.updateNR51(value);\n            SoundAccumulator.mixerEnabledChanged = true;\n            return true;\n        case Sound.memoryLocationNR52:\n            // Reset all registers except NR52\n            // See if we were enabled, then update the register.\n            var wasNR52Enabled = Sound.NR52IsSoundEnabled;\n            // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Power_Control\n            // When powered on, the frame sequencer is reset so that the next step will be 0,\n            // the square duty units are reset to the first step of the waveform,\n            // and the wave channel's sample buffer is reset to 0.\n            if (!wasNR52Enabled && checkBitOnByte(7, value)) {\n                Sound.frameSequencer = 0x07;\n                Channel1.waveFormPositionOnDuty = 0x00;\n                Channel2.waveFormPositionOnDuty = 0x00;\n                // TODO: Wave Channel Sample Buffer?\n                // I don't think we clear wave RAM here...\n            }\n            // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Power_Control\n            // When powered off, all registers (NR10-NR51) are instantly written with zero\n            // and any writes to those registers are ignored while power remains off\n            if (wasNR52Enabled && !checkBitOnByte(7, value)) {\n                for (var i = 0xff10; i < 0xff26; ++i) {\n                    eightBitStoreIntoGBMemoryWithTraps(i, 0x00);\n                }\n            }\n            // Need to update our new value here, that way writes go through :p\n            Sound.updateNR52(value);\n            return true;\n    }\n    // We did not handle the write, Allow the write\n    return true;\n}\n// http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Registers\n// Inlined because closure compiler inlines\nfunction SoundRegisterReadTraps(offset) {\n    // Registers must be OR'd with values when being read\n    // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Registers\n    switch (offset) {\n        // Handle NRx0 on Channels\n        case Channel1.memoryLocationNRx0: {\n            var register = eightBitLoadFromGBMemory(Channel1.memoryLocationNRx0);\n            return register | 0x80;\n        }\n        case Channel2.memoryLocationNRx0: {\n            var register = eightBitLoadFromGBMemory(Channel2.memoryLocationNRx0);\n            return register | 0xff;\n        }\n        case Channel3.memoryLocationNRx0: {\n            var register = eightBitLoadFromGBMemory(Channel3.memoryLocationNRx0);\n            return register | 0x7f;\n        }\n        case Channel4.memoryLocationNRx0: {\n            var register = eightBitLoadFromGBMemory(Channel4.memoryLocationNRx0);\n            return register | 0xff;\n        }\n        case Sound.memoryLocationNR50: {\n            var register = eightBitLoadFromGBMemory(Sound.memoryLocationNR50);\n            return register | 0x00;\n        }\n        // Handle NRx1 on Channels\n        case Channel1.memoryLocationNRx1: {\n            var register = eightBitLoadFromGBMemory(Channel1.memoryLocationNRx1);\n            return register | 0x3f;\n        }\n        case Channel2.memoryLocationNRx1: {\n            var register = eightBitLoadFromGBMemory(Channel2.memoryLocationNRx1);\n            return register | 0x3f;\n        }\n        case Channel3.memoryLocationNRx1: {\n            var register = eightBitLoadFromGBMemory(Channel3.memoryLocationNRx1);\n            return register | 0xff;\n        }\n        case Channel4.memoryLocationNRx1: {\n            var register = eightBitLoadFromGBMemory(Channel4.memoryLocationNRx1);\n            return register | 0xff;\n        }\n        case Sound.memoryLocationNR51: {\n            var register = eightBitLoadFromGBMemory(Sound.memoryLocationNR51);\n            return register | 0x00;\n        }\n        // Handle NRx2 on Channels\n        case Channel1.memoryLocationNRx2: {\n            var register = eightBitLoadFromGBMemory(Channel1.memoryLocationNRx2);\n            return register | 0x00;\n        }\n        case Channel2.memoryLocationNRx2: {\n            var register = eightBitLoadFromGBMemory(Channel2.memoryLocationNRx2);\n            return register | 0x00;\n        }\n        case Channel3.memoryLocationNRx2: {\n            var register = eightBitLoadFromGBMemory(Channel3.memoryLocationNRx2);\n            return register | 0x9f;\n        }\n        case Channel4.memoryLocationNRx2: {\n            var register = eightBitLoadFromGBMemory(Channel4.memoryLocationNRx2);\n            return register | 0x00;\n        }\n        case Sound.memoryLocationNR52: {\n            // This will fix bugs in orcale of ages :)\n            // Start our registerNR52\n            var registerNR52 = 0x00;\n            // Set the first bit to the sound paower status\n            if (Sound.NR52IsSoundEnabled) {\n                registerNR52 = setBitOnByte(7, registerNR52);\n            }\n            else {\n                registerNR52 = resetBitOnByte(7, registerNR52);\n            }\n            // Set our lower 4 bits to our channel length statuses\n            if (Channel1.isEnabled) {\n                registerNR52 = setBitOnByte(0, registerNR52);\n            }\n            else {\n                registerNR52 = resetBitOnByte(0, registerNR52);\n            }\n            if (Channel2.isEnabled) {\n                registerNR52 = setBitOnByte(1, registerNR52);\n            }\n            else {\n                registerNR52 = resetBitOnByte(1, registerNR52);\n            }\n            if (Channel3.isEnabled) {\n                registerNR52 = setBitOnByte(2, registerNR52);\n            }\n            else {\n                registerNR52 = resetBitOnByte(2, registerNR52);\n            }\n            if (Channel4.isEnabled) {\n                registerNR52 = setBitOnByte(3, registerNR52);\n            }\n            else {\n                registerNR52 = resetBitOnByte(3, registerNR52);\n            }\n            // Or from the table\n            registerNR52 |= 0x70;\n            return registerNR52;\n        }\n        // Handle NRx3 on Channels\n        case Channel1.memoryLocationNRx3: {\n            var register = eightBitLoadFromGBMemory(Channel1.memoryLocationNRx3);\n            return register | 0xff;\n        }\n        case Channel2.memoryLocationNRx3: {\n            var register = eightBitLoadFromGBMemory(Channel2.memoryLocationNRx3);\n            return register | 0xff;\n        }\n        case Channel3.memoryLocationNRx3: {\n            var register = eightBitLoadFromGBMemory(Channel3.memoryLocationNRx3);\n            return register | 0xff;\n        }\n        case Channel4.memoryLocationNRx3: {\n            var register = eightBitLoadFromGBMemory(Channel4.memoryLocationNRx3);\n            return register | 0x00;\n        }\n        // Handle NRx4 on Channels\n        case Channel1.memoryLocationNRx4: {\n            var register = eightBitLoadFromGBMemory(Channel1.memoryLocationNRx4);\n            return register | 0xbf;\n        }\n        case Channel2.memoryLocationNRx4: {\n            var register = eightBitLoadFromGBMemory(Channel2.memoryLocationNRx4);\n            return register | 0xbf;\n        }\n        case Channel3.memoryLocationNRx4: {\n            var register = eightBitLoadFromGBMemory(Channel3.memoryLocationNRx4);\n            return register | 0xbf;\n        }\n        case Channel4.memoryLocationNRx4: {\n            var register = eightBitLoadFromGBMemory(Channel4.memoryLocationNRx4);\n            return register | 0xbf;\n        }\n    }\n    return -1;\n}\n\nvar Interrupts = /** @class */ (function () {\n    function Interrupts() {\n    }\n    Interrupts.updateInterruptEnabled = function (value) {\n        Interrupts.isVBlankInterruptEnabled = checkBitOnByte(Interrupts.bitPositionVBlankInterrupt, value);\n        Interrupts.isLcdInterruptEnabled = checkBitOnByte(Interrupts.bitPositionLcdInterrupt, value);\n        Interrupts.isTimerInterruptEnabled = checkBitOnByte(Interrupts.bitPositionTimerInterrupt, value);\n        Interrupts.isSerialInterruptEnabled = checkBitOnByte(Interrupts.bitPositionSerialInterrupt, value);\n        Interrupts.isJoypadInterruptEnabled = checkBitOnByte(Interrupts.bitPositionJoypadInterrupt, value);\n        Interrupts.interruptsEnabledValue = value;\n    };\n    Interrupts.updateInterruptRequested = function (value) {\n        Interrupts.isVBlankInterruptRequested = checkBitOnByte(Interrupts.bitPositionVBlankInterrupt, value);\n        Interrupts.isLcdInterruptRequested = checkBitOnByte(Interrupts.bitPositionLcdInterrupt, value);\n        Interrupts.isTimerInterruptRequested = checkBitOnByte(Interrupts.bitPositionTimerInterrupt, value);\n        Interrupts.isSerialInterruptRequested = checkBitOnByte(Interrupts.bitPositionSerialInterrupt, value);\n        Interrupts.isJoypadInterruptRequested = checkBitOnByte(Interrupts.bitPositionJoypadInterrupt, value);\n        Interrupts.interruptsRequestedValue = value;\n    };\n    // Function to return if we have any pending interrupts\n    Interrupts.areInterruptsPending = function () {\n        return (Interrupts.interruptsRequestedValue & Interrupts.interruptsEnabledValue & 0x1f) > 0;\n    };\n    // Function to save the state of the class\n    Interrupts.saveState = function () {\n        // Interrupt Master Interrupt Switch\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x00, Interrupts.saveStateSlot), Interrupts.masterInterruptSwitch);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x01, Interrupts.saveStateSlot), Interrupts.masterInterruptSwitchDelay);\n        // Interrupt Enabled\n        store(getSaveStateMemoryOffset(0x10, Interrupts.saveStateSlot), Interrupts.interruptsEnabledValue);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x11, Interrupts.saveStateSlot), Interrupts.isVBlankInterruptEnabled);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x12, Interrupts.saveStateSlot), Interrupts.isLcdInterruptEnabled);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x13, Interrupts.saveStateSlot), Interrupts.isTimerInterruptEnabled);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x14, Interrupts.saveStateSlot), Interrupts.isSerialInterruptEnabled);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x15, Interrupts.saveStateSlot), Interrupts.isJoypadInterruptEnabled);\n        // Interrupt Request\n        store(getSaveStateMemoryOffset(0x20, Interrupts.saveStateSlot), Interrupts.interruptsRequestedValue);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x21, Interrupts.saveStateSlot), Interrupts.isVBlankInterruptRequested);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x22, Interrupts.saveStateSlot), Interrupts.isLcdInterruptRequested);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x23, Interrupts.saveStateSlot), Interrupts.isTimerInterruptRequested);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x24, Interrupts.saveStateSlot), Interrupts.isSerialInterruptRequested);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x25, Interrupts.saveStateSlot), Interrupts.isJoypadInterruptRequested);\n    };\n    // Function to load the save state from memory\n    Interrupts.loadState = function () {\n        // Interrupt Master Interrupt Switch\n        Interrupts.masterInterruptSwitch = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x00, Interrupts.saveStateSlot));\n        Interrupts.masterInterruptSwitchDelay = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x01, Interrupts.saveStateSlot));\n        // Interrupt Enabled\n        Interrupts.interruptsEnabledValue = load(getSaveStateMemoryOffset(0x10, Interrupts.saveStateSlot));\n        Interrupts.isVBlankInterruptEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x11, Interrupts.saveStateSlot));\n        Interrupts.isLcdInterruptEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x12, Interrupts.saveStateSlot));\n        Interrupts.isTimerInterruptEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x13, Interrupts.saveStateSlot));\n        Interrupts.isSerialInterruptEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x14, Interrupts.saveStateSlot));\n        Interrupts.isJoypadInterruptEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x15, Interrupts.saveStateSlot));\n        // Interrupt Request\n        Interrupts.interruptsRequestedValue = load(getSaveStateMemoryOffset(0x20, Interrupts.saveStateSlot));\n        Interrupts.isVBlankInterruptRequested = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x21, Interrupts.saveStateSlot));\n        Interrupts.isLcdInterruptRequested = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x22, Interrupts.saveStateSlot));\n        Interrupts.isTimerInterruptRequested = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x23, Interrupts.saveStateSlot));\n        Interrupts.isSerialInterruptRequested = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x24, Interrupts.saveStateSlot));\n        Interrupts.isJoypadInterruptRequested = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x25, Interrupts.saveStateSlot));\n    };\n    Interrupts.masterInterruptSwitch = false;\n    // According to mooneye, interrupts are not handled until AFTER\n    // Next instruction\n    // https://github.com/Gekkio/mooneye-gb/blob/master/docs/accuracy.markdown\n    Interrupts.masterInterruptSwitchDelay = false;\n    // Biut position for each part of the interrupts HW registers\n    Interrupts.bitPositionVBlankInterrupt = 0;\n    Interrupts.bitPositionLcdInterrupt = 1;\n    Interrupts.bitPositionTimerInterrupt = 2;\n    Interrupts.bitPositionSerialInterrupt = 3;\n    Interrupts.bitPositionJoypadInterrupt = 4;\n    Interrupts.memoryLocationInterruptEnabled = 0xffff; // A.K.A interrupt Flag (IE)\n    // Cache which Interrupts are enabled\n    Interrupts.interruptsEnabledValue = 0;\n    Interrupts.isVBlankInterruptEnabled = false;\n    Interrupts.isLcdInterruptEnabled = false;\n    Interrupts.isTimerInterruptEnabled = false;\n    Interrupts.isSerialInterruptEnabled = false;\n    Interrupts.isJoypadInterruptEnabled = false;\n    Interrupts.memoryLocationInterruptRequest = 0xff0f; // A.K.A interrupt Flag (IF)\n    // Cache which Interrupts are requested\n    Interrupts.interruptsRequestedValue = 0;\n    Interrupts.isVBlankInterruptRequested = false;\n    Interrupts.isLcdInterruptRequested = false;\n    Interrupts.isTimerInterruptRequested = false;\n    Interrupts.isSerialInterruptRequested = false;\n    Interrupts.isJoypadInterruptRequested = false;\n    // Save States\n    Interrupts.saveStateSlot = 2;\n    return Interrupts;\n}());\n// Inlined because closure compiler inlines\nfunction initializeInterrupts() {\n    // Values from BGB\n    // IE\n    Interrupts.updateInterruptEnabled(0x00);\n    eightBitStoreIntoGBMemory(Interrupts.memoryLocationInterruptEnabled, Interrupts.interruptsEnabledValue);\n    // IF\n    Interrupts.updateInterruptRequested(0xe1);\n    eightBitStoreIntoGBMemory(Interrupts.memoryLocationInterruptRequest, Interrupts.interruptsRequestedValue);\n}\n// NOTE: Interrupts should be handled before reading an opcode\n// Inlined because closure compiler inlines\nfunction checkInterrupts() {\n    // First check for our delay was enabled\n    if (Interrupts.masterInterruptSwitchDelay) {\n        Interrupts.masterInterruptSwitch = true;\n        Interrupts.masterInterruptSwitchDelay = false;\n    }\n    // Check if we have an enabled and requested interrupt\n    var isAnInterruptRequestedAndEnabledValue = Interrupts.interruptsEnabledValue & Interrupts.interruptsRequestedValue & 0x1f;\n    if (isAnInterruptRequestedAndEnabledValue > 0) {\n        // Boolean to track if interrupts were handled\n        // Interrupt handling requires 20 cycles\n        // https://github.com/Gekkio/mooneye-gb/blob/master/docs/accuracy.markdown#what-is-the-exact-timing-of-cpu-servicing-an-interrupt\n        var wasInterruptHandled = false;\n        // Service our interrupts, if we have the master switch enabled\n        // https://www.reddit.com/r/EmuDev/comments/5ie3k7/infinite_loop_trying_to_pass_blarggs_interrupt/\n        if (Interrupts.masterInterruptSwitch && !Cpu.isHaltNoJump) {\n            if (Interrupts.isVBlankInterruptEnabled && Interrupts.isVBlankInterruptRequested) {\n                _handleInterrupt(Interrupts.bitPositionVBlankInterrupt);\n                wasInterruptHandled = true;\n            }\n            else if (Interrupts.isLcdInterruptEnabled && Interrupts.isLcdInterruptRequested) {\n                _handleInterrupt(Interrupts.bitPositionLcdInterrupt);\n                wasInterruptHandled = true;\n            }\n            else if (Interrupts.isTimerInterruptEnabled && Interrupts.isTimerInterruptRequested) {\n                _handleInterrupt(Interrupts.bitPositionTimerInterrupt);\n                wasInterruptHandled = true;\n            }\n            else if (Interrupts.isSerialInterruptEnabled && Interrupts.isSerialInterruptRequested) {\n                _handleInterrupt(Interrupts.bitPositionSerialInterrupt);\n                wasInterruptHandled = true;\n            }\n            else if (Interrupts.isJoypadInterruptEnabled && Interrupts.isJoypadInterruptRequested) {\n                _handleInterrupt(Interrupts.bitPositionJoypadInterrupt);\n                wasInterruptHandled = true;\n            }\n        }\n        var interuptHandlerCycles = 0;\n        if (wasInterruptHandled) {\n            // Interrupt handling requires 20 cycles, TCAGBD\n            interuptHandlerCycles = 20;\n            if (Cpu.isHalted()) {\n                // If the CPU was halted, now is the time to un-halt\n                // Should be done here when the jump occurs according to:\n                // https://www.reddit.com/r/EmuDev/comments/6fmjch/gb_glitches_in_links_awakening_and_pok%C3%A9mon_gold/\n                Cpu.exitHaltAndStop();\n                interuptHandlerCycles += 4;\n            }\n        }\n        if (Cpu.isHalted()) {\n            Cpu.exitHaltAndStop();\n        }\n        return interuptHandlerCycles;\n    }\n    return 0;\n}\nfunction _handleInterrupt(bitPosition) {\n    // Disable the master switch\n    setInterrupts(false);\n    // Disable the bit on the interruptRequest\n    var interruptRequest = eightBitLoadFromGBMemory(Interrupts.memoryLocationInterruptRequest);\n    interruptRequest = resetBitOnByte(bitPosition, interruptRequest);\n    Interrupts.interruptsRequestedValue = interruptRequest;\n    eightBitStoreIntoGBMemory(Interrupts.memoryLocationInterruptRequest, interruptRequest);\n    // Push the programCounter onto the stacks\n    // Push the next instruction, not the halt itself (TCAGBD).\n    Cpu.stackPointer = Cpu.stackPointer - 2;\n    if (Cpu.isHalted()) {\n        // TODO: This breaks Pokemon Yellow, And OG Link's awakening. Find out why...\n        // sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter + 1);\n        sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter);\n    }\n    else {\n        sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter);\n    }\n    // Jump to the correct interrupt location\n    // Also piggyback off of the switch to reset our HW Register caching\n    // http://www.codeslinger.co.uk/pages/projects/gameboy/interupts.html\n    switch (bitPosition) {\n        case Interrupts.bitPositionVBlankInterrupt:\n            Interrupts.isVBlankInterruptRequested = false;\n            Cpu.programCounter = 0x40;\n            break;\n        case Interrupts.bitPositionLcdInterrupt:\n            Interrupts.isLcdInterruptRequested = false;\n            Cpu.programCounter = 0x48;\n            break;\n        case Interrupts.bitPositionTimerInterrupt:\n            Interrupts.isTimerInterruptRequested = false;\n            Cpu.programCounter = 0x50;\n            break;\n        case Interrupts.bitPositionSerialInterrupt:\n            Interrupts.isSerialInterruptRequested = false;\n            Cpu.programCounter = 0x58;\n            break;\n        case Interrupts.bitPositionJoypadInterrupt:\n            Interrupts.isJoypadInterruptRequested = false;\n            Cpu.programCounter = 0x60;\n            break;\n    }\n}\nfunction _requestInterrupt(bitPosition) {\n    var interruptRequest = eightBitLoadFromGBMemory(Interrupts.memoryLocationInterruptRequest);\n    // Pass to set the correct interrupt bit on interruptRequest\n    interruptRequest = setBitOnByte(bitPosition, interruptRequest);\n    Interrupts.interruptsRequestedValue = interruptRequest;\n    eightBitStoreIntoGBMemory(Interrupts.memoryLocationInterruptRequest, interruptRequest);\n}\nfunction setInterrupts(value) {\n    // If we are enabling interrupts,\n    // we want to wait 4 cycles before enabling\n    if (value) {\n        Interrupts.masterInterruptSwitchDelay = true;\n    }\n    else {\n        Interrupts.masterInterruptSwitch = false;\n    }\n}\n// Inlined because closure compiler inlines\nfunction requestVBlankInterrupt() {\n    Interrupts.isVBlankInterruptRequested = true;\n    _requestInterrupt(Interrupts.bitPositionVBlankInterrupt);\n}\n// Inlined because closure compiler inlines\nfunction requestLcdInterrupt() {\n    Interrupts.isLcdInterruptRequested = true;\n    _requestInterrupt(Interrupts.bitPositionLcdInterrupt);\n}\n// Inlined because closure compiler inlines\nfunction requestTimerInterrupt() {\n    Interrupts.isTimerInterruptRequested = true;\n    _requestInterrupt(Interrupts.bitPositionTimerInterrupt);\n}\n// Inlined because closure compiler inlines\nfunction requestJoypadInterrupt() {\n    Interrupts.isJoypadInterruptRequested = true;\n    _requestInterrupt(Interrupts.bitPositionJoypadInterrupt);\n}\n// Inlined because closure compiler inlines\nfunction requestSerialInterrupt() {\n    Interrupts.isSerialInterruptRequested = true;\n    _requestInterrupt(Interrupts.bitPositionSerialInterrupt);\n}\n\nvar Timers = /** @class */ (function () {\n    function Timers() {\n    }\n    // Number of cycles to run in each batch process\n    Timers.batchProcessCycles = function () {\n        return 256;\n    };\n    Timers.updateDividerRegister = function () {\n        var oldDividerRegister = Timers.dividerRegister;\n        Timers.dividerRegister = 0;\n        eightBitStoreIntoGBMemory(Timers.memoryLocationDividerRegister, 0);\n        if (Timers.timerEnabled && _checkDividerRegisterFallingEdgeDetector(oldDividerRegister, 0)) {\n            _incrementTimerCounter();\n        }\n    };\n    Timers.updateTimerCounter = function (value) {\n        if (Timers.timerEnabled) {\n            // From binjgb, dont write TIMA if we were just reset\n            if (Timers.timerCounterWasReset) {\n                return;\n            }\n            // Mooneye Test, tima_write_reloading\n            // Writing in this strange delay cycle, will cancel\n            // Both the interrupt and the TMA reload\n            if (Timers.timerCounterOverflowDelay) {\n                Timers.timerCounterOverflowDelay = false;\n            }\n        }\n        Timers.timerCounter = value;\n    };\n    Timers.updateTimerModulo = function (value) {\n        Timers.timerModulo = value;\n        // Mooneye Test, tma_write_reloading\n        // Don't update if we were reloading\n        if (Timers.timerEnabled && Timers.timerCounterWasReset) {\n            Timers.timerCounter = value;\n            Timers.timerCounterWasReset = false;\n        }\n    };\n    Timers.updateTimerControl = function (value) {\n        // Get some initial values\n        var oldTimerEnabled = Timers.timerEnabled;\n        Timers.timerEnabled = checkBitOnByte(2, value);\n        var newTimerInputClock = value & 0x03;\n        // Do some obscure behavior for if we should increment TIMA\n        // This does the timer increments from rapid_toggle mooneye tests\n        if (!oldTimerEnabled) {\n            var oldTimerCounterMaskBit = _getTimerCounterMaskBit(Timers.timerInputClock);\n            var newTimerCounterMaskBit = _getTimerCounterMaskBit(newTimerInputClock);\n            var shouldIncrementTimerCounter = false;\n            var dividerRegister = Timers.dividerRegister;\n            if (Timers.timerEnabled) {\n                shouldIncrementTimerCounter = checkBitOnByte(oldTimerCounterMaskBit, dividerRegister);\n            }\n            else {\n                shouldIncrementTimerCounter =\n                    checkBitOnByte(oldTimerCounterMaskBit, dividerRegister) && checkBitOnByte(newTimerCounterMaskBit, dividerRegister);\n            }\n            if (shouldIncrementTimerCounter) {\n                _incrementTimerCounter();\n            }\n        }\n        Timers.timerInputClock = newTimerInputClock;\n    };\n    // Function to save the state of the class\n    // TODO: Save state for new properties on Timers\n    Timers.saveState = function () {\n        // Batch Processing\n        store(getSaveStateMemoryOffset(0x00, Timers.saveStateSlot), Timers.currentCycles);\n        // Divider Register\n        store(getSaveStateMemoryOffset(0x04, Timers.saveStateSlot), Timers.dividerRegister);\n        // Timer Counter\n        store(getSaveStateMemoryOffset(0x08, Timers.saveStateSlot), Timers.timerCounter);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0c, Timers.saveStateSlot), Timers.timerCounterOverflowDelay);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0d, Timers.saveStateSlot), Timers.timerCounterWasReset);\n        store(getSaveStateMemoryOffset(0x0e, Timers.saveStateSlot), Timers.timerCounterMask);\n        // Timer Modulo\n        store(getSaveStateMemoryOffset(0x12, Timers.saveStateSlot), Timers.timerModulo);\n        // Timer Control\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x16, Timers.saveStateSlot), Timers.timerEnabled);\n        store(getSaveStateMemoryOffset(0x17, Timers.saveStateSlot), Timers.timerInputClock);\n    };\n    // Function to load the save state from memory\n    Timers.loadState = function () {\n        // Batch Processing\n        Timers.currentCycles = load(getSaveStateMemoryOffset(0x00, Timers.saveStateSlot));\n        // Divider Register\n        Timers.dividerRegister = load(getSaveStateMemoryOffset(0x04, Timers.saveStateSlot));\n        // Timer Counter\n        Timers.timerCounter = load(getSaveStateMemoryOffset(0x08, Timers.saveStateSlot));\n        Timers.timerCounterOverflowDelay = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0c, Timers.saveStateSlot));\n        Timers.timerCounterWasReset = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0d, Timers.saveStateSlot));\n        Timers.timerCounterMask = load(getSaveStateMemoryOffset(0x0e, Timers.saveStateSlot));\n        // Timer Modulo\n        Timers.timerModulo = load(getSaveStateMemoryOffset(0x12, Timers.saveStateSlot));\n        // Timer Control\n        Timers.timerEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x16, Timers.saveStateSlot));\n        Timers.timerInputClock = load(getSaveStateMemoryOffset(0x17, Timers.saveStateSlot));\n    };\n    // Current cycles\n    // This will be used for batch processing\n    Timers.currentCycles = 0;\n    // Divider Register = DIV\n    // Divider Register is 16 bits.\n    // Divider Register when read is just the upper 8 bits\n    // But internally is used as the full 16\n    // Essentially dividerRegister is an always counting clock\n    // DIV Drives everything, it is the heart of the timer.\n    // All other timing registers base them selves relative to the DIV register\n    // Think of the div register as like a cycle counter :)\n    // DIV will increment TIMA, whenever there is a falling edge, see below for that.\n    Timers.memoryLocationDividerRegister = 0xff04; // DIV\n    Timers.dividerRegister = 0;\n    // timerCounter = TIMA\n    // TIMA is the actual counter.\n    // Whenever the DIV gets the falling edge, and other obscure cases,\n    // This is incremented. When this overflows, we need to fire an interrupt.\n    Timers.memoryLocationTimerCounter = 0xff05;\n    Timers.timerCounter = 0;\n    Timers.timerCounterOverflowDelay = false;\n    Timers.timerCounterWasReset = false;\n    Timers.timerCounterMask = 0;\n    // Timer Modulo = TMA\n    // TMA is what TIMA (Notice the I :p) is counting from, and TIMA will load\n    // Whenever TIMA overflow.\n    // For instance, we count like 1,2,3,4,5,6,7,8,9, and then overflow to 10.\n    // TMA would be like \"Hey, start counting from 5 whenever we reset\"\n    // Then we would be like 5,6,7,8,9...5,6,7,8,9...etc...\n    Timers.memoryLocationTimerModulo = 0xff06;\n    Timers.timerModulo = 0;\n    // Timer Control = TAC\n    // TAC Says how fast we are counting.\n    // TAC controls which bit we are watching for the falling edge on the DIV register\n    // And whenever the bit has the falling edge, we increment TIMA (The thing counting).\n    // Therefore, depending on the value, we will either count faster or slower.\n    Timers.memoryLocationTimerControl = 0xff07;\n    // Bit 2    - Timer Stop  (0=Stop, 1=Start)\n    // Bits 1-0 - Input Clock Select\n    //            00:   4096 Hz    (~4194 Hz SGB) (1024 cycles)\n    //            01: 262144 Hz  (~268400 Hz SGB) (16 cycles)\n    //            10:  65536 Hz   (~67110 Hz SGB) (64 cycles)\n    //            11:  16384 Hz   (~16780 Hz SGB) (256 cycles)\n    Timers.timerEnabled = false;\n    Timers.timerInputClock = 0;\n    // Save States\n    Timers.saveStateSlot = 5;\n    return Timers;\n}());\n// Inlined because closure compiler inlines\nfunction initializeTimers() {\n    // Reset stateful Variables\n    Timers.currentCycles = 0;\n    Timers.dividerRegister = 0;\n    Timers.timerCounter = 0;\n    Timers.timerModulo = 0;\n    Timers.timerEnabled = false;\n    Timers.timerInputClock = 0;\n    Timers.timerCounterOverflowDelay = false;\n    Timers.timerCounterWasReset = false;\n    if (Cpu.GBCEnabled) {\n        // DIV\n        eightBitStoreIntoGBMemory(0xff04, 0x1e);\n        Timers.dividerRegister = 0x1ea0;\n        // 0xFF05 -> 0xFF06 = 0x00\n        // TAC\n        eightBitStoreIntoGBMemory(0xff07, 0xf8);\n        Timers.timerInputClock = 0xf8;\n    }\n    else {\n        // DIV\n        eightBitStoreIntoGBMemory(0xff04, 0xab);\n        Timers.dividerRegister = 0xabcc;\n        // 0xFF05 -> 0xFF06 = 0x00\n        // TAC\n        eightBitStoreIntoGBMemory(0xff07, 0xf8);\n        Timers.timerInputClock = 0xf8;\n    }\n    // Override/reset some variables if the boot ROM is enabled\n    if (Cpu.BootROMEnabled) {\n        if (Cpu.GBCEnabled) ;\n        else {\n            // GB\n            // DIV\n            eightBitStoreIntoGBMemory(0xff04, 0x00);\n            Timers.dividerRegister = 0x0004;\n        }\n    }\n}\n// Batch Process Timers\n// Only checked on writes\n// Function to batch process our Timers after we skipped so many cycles\nfunction batchProcessTimers() {\n    // TODO: Did a timer rewrite, make a proper batch processing\n    // For timers\n    updateTimers(Timers.currentCycles);\n    Timers.currentCycles = 0;\n}\nfunction updateTimers(numberOfCycles) {\n    // Want to increment 4 cycles at a time like an actual GB would\n    var cyclesIncreased = 0;\n    while (cyclesIncreased < numberOfCycles) {\n        var oldDividerRegister = Timers.dividerRegister;\n        var curDividerRegister = oldDividerRegister;\n        cyclesIncreased += 4;\n        curDividerRegister += 4;\n        curDividerRegister &= 0xffff;\n        Timers.dividerRegister = curDividerRegister;\n        if (Timers.timerEnabled) {\n            var timerCounterWasReset = Timers.timerCounterWasReset;\n            if (Timers.timerCounterOverflowDelay) {\n                Timers.timerCounter = Timers.timerModulo;\n                // Fire off timer interrupt\n                requestTimerInterrupt();\n                Timers.timerCounterOverflowDelay = false;\n                Timers.timerCounterWasReset = true;\n            }\n            else if (timerCounterWasReset) {\n                Timers.timerCounterWasReset = false;\n            }\n            if (_checkDividerRegisterFallingEdgeDetector(oldDividerRegister, curDividerRegister)) {\n                _incrementTimerCounter();\n            }\n        }\n    }\n}\n// Function to increment our Timer Counter\n// This fires off interrupts once we overflow\nfunction _incrementTimerCounter() {\n    var counter = Timers.timerCounter;\n    if (++counter > 255) {\n        // Whenever the timer overflows, there is a slight delay (4 cycles)\n        // Of when TIMA gets TMA's value, and the interrupt is fired.\n        // Thus we will set the delay, which can be handled in the update timer or write trap\n        Timers.timerCounterOverflowDelay = true;\n        counter = 0;\n    }\n    Timers.timerCounter = counter;\n}\n// Function to act as our falling edge detector\n// Whenever we have a falling edge, we need to increment TIMA\n// http://gbdev.gg8.se/wiki/articles/Timer_Obscure_Behaviour\n// https://github.com/binji/binjgb/blob/master/src/emulator.c#L1944\nfunction _checkDividerRegisterFallingEdgeDetector(oldDividerRegister, newDividerRegister) {\n    // Get our mask\n    var timerCounterMaskBit = _getTimerCounterMaskBit(Timers.timerInputClock);\n    // If the old register's watched bit was zero,\n    // but after adding the new registers wastch bit is now 1\n    return checkBitOnByte(timerCounterMaskBit, oldDividerRegister) && !checkBitOnByte(timerCounterMaskBit, newDividerRegister);\n}\n// Function to get our current tima mask bit\n// used for our falling edge detector\n// See The docs linked above, or TCAGB for this bit mapping\nfunction _getTimerCounterMaskBit(timerInputClock) {\n    switch (timerInputClock) {\n        case 0x00:\n            return 9;\n        case 0x01:\n            return 3;\n        case 0x02:\n            return 5;\n        case 0x03:\n            return 7;\n    }\n    return 0;\n}\n\n// Link cable / serial implementation\nvar Serial = /** @class */ (function () {\n    function Serial() {\n    }\n    Serial.updateTransferControl = function (value) {\n        Serial.isShiftClockInternal = checkBitOnByte(0, value);\n        Serial.isClockSpeedFast = checkBitOnByte(1, value);\n        Serial.transferStartFlag = checkBitOnByte(7, value);\n        // Allow the original write, and return since we dont need to look anymore\n        return true;\n    };\n    // Cycle counter\n    Serial.currentCycles = 0x00;\n    // Register locations\n    Serial.memoryLocationSerialTransferData = 0xff01; // SB\n    Serial.memoryLocationSerialTransferControl = 0xff02; // SC\n    // Number of bits transferred\n    Serial.numberOfBitsTransferred = 0;\n    // Transfer control variables\n    Serial.isShiftClockInternal = false;\n    Serial.isClockSpeedFast = false;\n    Serial.transferStartFlag = false;\n    return Serial;\n}());\n// Function to initialize our serial values\n// Inlined because closure compiler inlines\nfunction initializeSerial() {\n    Serial.currentCycles = 0x00;\n    Serial.numberOfBitsTransferred = 0;\n    if (Cpu.GBCEnabled) {\n        // FF01 = 0x00\n        eightBitStoreIntoGBMemory(0xff02, 0x7c);\n        Serial.updateTransferControl(0x7c);\n    }\n    else {\n        // FF01 = 0x00\n        eightBitStoreIntoGBMemory(0xff02, 0x7e);\n        Serial.updateTransferControl(0x7e);\n    }\n}\n// TODO: Finish serial\n// See minimal serial: https://github.com/binji/binjgb/commit/64dece05c4ef5a052c4b9b75eb3ddbbfc6677cbe\n// Inlined because closure compiler inlines\nfunction updateSerial(numberOfCycles) {\n    // If we aren't starting our transfer, or transferring,\n    // return\n    if (!Serial.transferStartFlag) {\n        return;\n    }\n    // Want to increment 4 cycles at a time like an actual GB would\n    var cyclesIncreased = 0;\n    while (cyclesIncreased < numberOfCycles) {\n        var oldCycles = Serial.currentCycles;\n        var curCycles = oldCycles;\n        cyclesIncreased += 4;\n        curCycles += 4;\n        if (curCycles > 0xffff) {\n            curCycles -= 0x10000;\n        }\n        Serial.currentCycles = curCycles;\n        if (_checkFallingEdgeDetector(oldCycles, curCycles)) {\n            // TODO: Since no actual connection, always transfer 1\n            // Need to fix this\n            var memoryLocationSerialTransferData = Serial.memoryLocationSerialTransferData;\n            var transferData = eightBitLoadFromGBMemory(memoryLocationSerialTransferData);\n            transferData = (transferData << 1) + 1;\n            transferData = transferData & 0xff;\n            eightBitStoreIntoGBMemory(memoryLocationSerialTransferData, transferData);\n            var numberOfBitsTransferred = Serial.numberOfBitsTransferred;\n            if (++numberOfBitsTransferred === 8) {\n                Serial.numberOfBitsTransferred = 0;\n                requestSerialInterrupt();\n                // Disable transfer start\n                var memoryLocationSerialTransferControl = Serial.memoryLocationSerialTransferControl;\n                var transferControl = eightBitLoadFromGBMemory(memoryLocationSerialTransferControl);\n                eightBitStoreIntoGBMemory(memoryLocationSerialTransferControl, resetBitOnByte(7, transferControl));\n                Serial.transferStartFlag = false;\n            }\n            else {\n                Serial.numberOfBitsTransferred = numberOfBitsTransferred;\n            }\n        }\n    }\n}\n// Inlined because closure compiler inlines\nfunction _checkFallingEdgeDetector(oldCycles, newCycles) {\n    // Get our mask\n    var maskBit = _getFallingEdgeMaskBit();\n    // If the old register's watched bit was zero,\n    // but after adding the new registers wastch bit is now 1\n    return checkBitOnByte(maskBit, oldCycles) && !checkBitOnByte(maskBit, newCycles);\n}\n// Function to get our current tima mask bit\n// used for our falling edge detector\n// See The docs linked above, or TCAGB for this bit mapping\n// Inlined because closure compiler inlines\nfunction _getFallingEdgeMaskBit() {\n    return Serial.isClockSpeedFast ? 2 : 7;\n}\n\n// http://www.codeslinger.co.uk/pages/projects/gameboy/joypad.html\n// Joypad Register\n// Taken from pandocs\n// Bit 7 - Not used\n// Bit 6 - Not used\n// Bit 5 - P15 Select Button Keys (0=Select)\n// Bit 4 - P14 Select Direction Keys (0=Select)\n// Bit 3 - P13 Input Down or Start (0=Pressed) (Read Only)\n// Bit 2 - P12 Input Up or Select (0=Pressed) (Read Only)\n// Bit 1 - P11 Input Left or Button B (0=Pressed) (Read Only)\n// Bit 0 - P10 Input Right or Button A (0=Pressed) (Read Only)\n// Button Ids will be the following:\n// UP - 0\n// RIGHT - 1\n// DOWN - 2\n// LEFT - 3\n// A - 4\n// B - 5\n// SELECT - 6\n// START - 7\nvar Joypad = /** @class */ (function () {\n    function Joypad() {\n    }\n    Joypad.updateJoypad = function (value) {\n        Joypad.joypadRegisterFlipped = value ^ 0xff;\n        Joypad.isDpadType = checkBitOnByte(4, Joypad.joypadRegisterFlipped);\n        Joypad.isButtonType = checkBitOnByte(5, Joypad.joypadRegisterFlipped);\n    };\n    // Function to save the state of the class\n    Joypad.saveState = function () {\n        store(getSaveStateMemoryOffset(0x00, Joypad.saveStateSlot), Joypad.joypadRegisterFlipped);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x01, Joypad.saveStateSlot), Joypad.isDpadType);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x02, Joypad.saveStateSlot), Joypad.isButtonType);\n    };\n    // Function to load the save state from memory\n    Joypad.loadState = function () {\n        Joypad.joypadRegisterFlipped = load(getSaveStateMemoryOffset(0x00, Joypad.saveStateSlot));\n        Joypad.isDpadType = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x01, Joypad.saveStateSlot));\n        Joypad.isButtonType = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x02, Joypad.saveStateSlot));\n    };\n    Joypad.up = false;\n    Joypad.down = false;\n    Joypad.left = false;\n    Joypad.right = false;\n    Joypad.a = false;\n    Joypad.b = false;\n    Joypad.select = false;\n    Joypad.start = false;\n    Joypad.memoryLocationJoypadRegister = 0xff00;\n    // Cache some values on the Joypad register\n    Joypad.joypadRegisterFlipped = 0;\n    Joypad.isDpadType = false;\n    Joypad.isButtonType = false;\n    // Save States\n    // Not doing anything for Joypad for now\n    Joypad.saveStateSlot = 3;\n    return Joypad;\n}());\n// Inlined because closure compiler inlines\nfunction getJoypadState() {\n    // Get the joypad register\n    var joypadRegister = Joypad.joypadRegisterFlipped;\n    if (Joypad.isDpadType) {\n        // D-pad buttons\n        // Up\n        if (Joypad.up) {\n            joypadRegister = resetBitOnByte(2, joypadRegister);\n        }\n        else {\n            joypadRegister = setBitOnByte(2, joypadRegister);\n        }\n        // Right\n        if (Joypad.right) {\n            joypadRegister = resetBitOnByte(0, joypadRegister);\n        }\n        else {\n            joypadRegister = setBitOnByte(0, joypadRegister);\n        }\n        // Down\n        if (Joypad.down) {\n            joypadRegister = resetBitOnByte(3, joypadRegister);\n        }\n        else {\n            joypadRegister = setBitOnByte(3, joypadRegister);\n        }\n        // Left\n        if (Joypad.left) {\n            joypadRegister = resetBitOnByte(1, joypadRegister);\n        }\n        else {\n            joypadRegister = setBitOnByte(1, joypadRegister);\n        }\n    }\n    else if (Joypad.isButtonType) {\n        // A\n        if (Joypad.a) {\n            joypadRegister = resetBitOnByte(0, joypadRegister);\n        }\n        else {\n            joypadRegister = setBitOnByte(0, joypadRegister);\n        }\n        // B\n        if (Joypad.b) {\n            joypadRegister = resetBitOnByte(1, joypadRegister);\n        }\n        else {\n            joypadRegister = setBitOnByte(1, joypadRegister);\n        }\n        // Select\n        if (Joypad.select) {\n            joypadRegister = resetBitOnByte(2, joypadRegister);\n        }\n        else {\n            joypadRegister = setBitOnByte(2, joypadRegister);\n        }\n        // Start\n        if (Joypad.start) {\n            joypadRegister = resetBitOnByte(3, joypadRegister);\n        }\n        else {\n            joypadRegister = setBitOnByte(3, joypadRegister);\n        }\n    }\n    // Set the top 4 bits to on\n    joypadRegister = joypadRegister | 0xf0;\n    return joypadRegister;\n}\nfunction setJoypadState(up, right, down, left, a, b, select, start) {\n    if (up > 0) {\n        _pressJoypadButton(0);\n    }\n    else {\n        _releaseJoypadButton(0);\n    }\n    if (right > 0) {\n        _pressJoypadButton(1);\n    }\n    else {\n        _releaseJoypadButton(1);\n    }\n    if (down > 0) {\n        _pressJoypadButton(2);\n    }\n    else {\n        _releaseJoypadButton(2);\n    }\n    if (left > 0) {\n        _pressJoypadButton(3);\n    }\n    else {\n        _releaseJoypadButton(3);\n    }\n    if (a > 0) {\n        _pressJoypadButton(4);\n    }\n    else {\n        _releaseJoypadButton(4);\n    }\n    if (b > 0) {\n        _pressJoypadButton(5);\n    }\n    else {\n        _releaseJoypadButton(5);\n    }\n    if (select > 0) {\n        _pressJoypadButton(6);\n    }\n    else {\n        _releaseJoypadButton(6);\n    }\n    if (start > 0) {\n        _pressJoypadButton(7);\n    }\n    else {\n        _releaseJoypadButton(7);\n    }\n}\nfunction _pressJoypadButton(buttonId) {\n    // Un stop the CPU\n    Cpu.isStopped = false;\n    // Check if the button state changed from not pressed\n    var isButtonStateChanging = false;\n    if (!_getJoypadButtonStateFromButtonId(buttonId)) {\n        isButtonStateChanging = true;\n    }\n    // Set our joypad state\n    _setJoypadButtonStateFromButtonId(buttonId, true);\n    // If the button state is changing, check for an interrupt\n    if (isButtonStateChanging) {\n        // Determine if it is a button or a dpad button\n        var isDpadTypeButton = false;\n        if (buttonId <= 3) {\n            isDpadTypeButton = true;\n        }\n        // Determine if we should request an interrupt\n        var shouldRequestInterrupt = false;\n        // Check if the game is looking for a dpad type button press\n        if (Joypad.isDpadType && isDpadTypeButton) {\n            shouldRequestInterrupt = true;\n        }\n        // Check if the game is looking for a button type button press\n        if (Joypad.isButtonType && !isDpadTypeButton) {\n            shouldRequestInterrupt = true;\n        }\n        // Finally, request the interrupt, if the button state actually changed\n        if (shouldRequestInterrupt) {\n            requestJoypadInterrupt();\n        }\n    }\n}\n// Inlined because closure compiler inlines\nfunction _releaseJoypadButton(buttonId) {\n    // Set our joypad state\n    _setJoypadButtonStateFromButtonId(buttonId, false);\n}\nfunction _getJoypadButtonStateFromButtonId(buttonId) {\n    switch (buttonId) {\n        case 0:\n            return Joypad.up;\n        case 1:\n            return Joypad.right;\n        case 2:\n            return Joypad.down;\n        case 3:\n            return Joypad.left;\n        case 4:\n            return Joypad.a;\n        case 5:\n            return Joypad.b;\n        case 6:\n            return Joypad.select;\n        case 7:\n            return Joypad.start;\n        default:\n            return false;\n    }\n}\nfunction _setJoypadButtonStateFromButtonId(buttonId, isPressed) {\n    switch (buttonId) {\n        case 0:\n            Joypad.up = isPressed;\n            break;\n        case 1:\n            Joypad.right = isPressed;\n            break;\n        case 2:\n            Joypad.down = isPressed;\n            break;\n        case 3:\n            Joypad.left = isPressed;\n            break;\n        case 4:\n            Joypad.a = isPressed;\n            break;\n        case 5:\n            Joypad.b = isPressed;\n            break;\n        case 6:\n            Joypad.select = isPressed;\n            break;\n        case 7:\n            Joypad.start = isPressed;\n            break;\n    }\n}\n\n// Function to handle rom/rambanking\n// Inlined because closure compiler inlines\nfunction handleBanking(offset, value) {\n    // Is rom Only does not bank\n    if (Memory.isRomOnly) {\n        return;\n    }\n    var isMBC1 = Memory.isMBC1;\n    var isMBC2 = Memory.isMBC2;\n    // Enable Ram Banking\n    if (offset <= 0x1fff) {\n        if (isMBC2 && !checkBitOnByte(4, value)) {\n            // Do Nothing\n            return;\n        }\n        else {\n            var romEnableByte = value & 0x0f;\n            if (romEnableByte === 0x00) {\n                Memory.isRamBankingEnabled = false;\n            }\n            else if (romEnableByte === 0x0a) {\n                Memory.isRamBankingEnabled = true;\n            }\n        }\n    }\n    else if (offset <= 0x3fff) {\n        var isMBC5 = Memory.isMBC5;\n        if (!isMBC5 || offset <= 0x2fff) {\n            // Change Low Bits on the Current Rom Bank\n            var currentRomBank = Memory.currentRomBank;\n            if (isMBC2) {\n                currentRomBank = value & 0x0f;\n            }\n            // Set the number of bottom bytes from the MBC type\n            var romBankLowerBits = value;\n            if (isMBC1) {\n                // Only want the bottom 5\n                romBankLowerBits = romBankLowerBits & 0x1f;\n                currentRomBank &= 0xe0;\n            }\n            else if (Memory.isMBC3) {\n                // Only Want the bottom 7\n                romBankLowerBits = romBankLowerBits & 0x7f;\n                currentRomBank &= 0x80;\n            }\n            else if (isMBC5) {\n                // Going to switch the whole thing\n                currentRomBank &= 0x00;\n            }\n            // Set the lower bytes\n            currentRomBank |= romBankLowerBits;\n            Memory.currentRomBank = currentRomBank;\n            return;\n        }\n        else {\n            // TODO: MBC5 High bits Rom bank, check if this works, not sure about the value\n            var lowByte = splitLowByte(Memory.currentRomBank);\n            var highByte = (value > 0);\n            Memory.currentRomBank = concatenateBytes(highByte, lowByte);\n        }\n    }\n    else if (!isMBC2 && offset <= 0x5fff) {\n        // ROM / RAM Banking, MBC2 doesn't do this\n        if (isMBC1 && Memory.isMBC1RomModeEnabled) {\n            // Do an upper bit rom bank for MBC 1\n            // Remove upper bits of currentRomBank\n            var currentRomBank = Memory.currentRomBank & 0x1f;\n            var romBankHigherBits = value & 0xe0;\n            currentRomBank |= romBankHigherBits;\n            Memory.currentRomBank = currentRomBank;\n            return;\n        }\n        var ramBankBits = value;\n        if (!Memory.isMBC5) {\n            // Get the bottom 2 bits\n            ramBankBits &= 0x03;\n        }\n        else {\n            // Get the bottom nibble\n            ramBankBits &= 0x0f;\n        }\n        // Set our ram bank\n        Memory.currentRamBank = ramBankBits;\n        return;\n    }\n    else if (!isMBC2 && offset <= 0x7fff) {\n        if (isMBC1) {\n            Memory.isMBC1RomModeEnabled = checkBitOnByte(0, value);\n        }\n        // TODO: MBC3 Latch Clock Data\n    }\n}\n// Inlined because closure compiler inlines\nfunction getRomBankAddress(gameboyOffset) {\n    var currentRomBank = Memory.currentRomBank;\n    if (!Memory.isMBC5 && currentRomBank === 0) {\n        currentRomBank = 1;\n    }\n    // Adjust our gameboy offset relative to zero for the gameboy memory map\n    return (0x4000 * currentRomBank + (gameboyOffset - Memory.switchableCartridgeRomLocation));\n}\n// Inlined because closure compiler inlines\nfunction getRamBankAddress(gameboyOffset) {\n    // Adjust our gameboy offset relative to zero for the gameboy memory map\n    return (0x2000 * Memory.currentRamBank + (gameboyOffset - Memory.cartridgeRamLocation));\n}\n\n// Inlined because closure compiler inlines\nfunction initializeDma() {\n    if (Cpu.GBCEnabled) {\n        // GBC DMA\n        eightBitStoreIntoGBMemory(0xff51, 0xff);\n        eightBitStoreIntoGBMemory(0xff52, 0xff);\n        eightBitStoreIntoGBMemory(0xff53, 0xff);\n        eightBitStoreIntoGBMemory(0xff54, 0xff);\n        eightBitStoreIntoGBMemory(0xff55, 0xff);\n    }\n    else {\n        // GB DMA\n        eightBitStoreIntoGBMemory(0xff51, 0xff);\n        eightBitStoreIntoGBMemory(0xff52, 0xff);\n        eightBitStoreIntoGBMemory(0xff53, 0xff);\n        eightBitStoreIntoGBMemory(0xff54, 0xff);\n        eightBitStoreIntoGBMemory(0xff55, 0xff);\n    }\n}\n// Inlined because closure compiler inlines\nfunction startDmaTransfer(sourceAddressOffset) {\n    var sourceAddress = sourceAddressOffset << 8;\n    for (var i = 0; i <= 0x9f; ++i) {\n        var spriteInformationByte = eightBitLoadFromGBMemory(sourceAddress + i);\n        var spriteInformationAddress = Memory.spriteInformationTableLocation + i;\n        eightBitStoreIntoGBMemory(spriteInformationAddress, spriteInformationByte);\n    }\n    // TCAGBD:  This copy (DMA) needs 160 × 4 + 4 clocks to complete in both double speed and single speeds modes\n    // Increment all of our Cycle coiunters in ../cpu/opcodes\n    Memory.DMACycles = 644;\n}\n// https://gist.github.com/drhelius/3394856\n// http://bgb.bircd.org/pandocs.htm\n// Inlined because closure compiler inlines\nfunction startHdmaTransfer(hdmaTriggerByteToBeWritten) {\n    // Check if we are Gbc\n    if (!Cpu.GBCEnabled) {\n        return;\n    }\n    // Check if we are trying to terminate an already active HBLANK HDMA\n    if (Memory.isHblankHdmaActive && !checkBitOnByte(7, hdmaTriggerByteToBeWritten)) {\n        // Don't reset anything, just set bit 7 to 1 on the trigger byte\n        Memory.isHblankHdmaActive = false;\n        var hdmaTriggerByte = eightBitLoadFromGBMemory(Memory.memoryLocationHdmaTrigger);\n        eightBitStoreIntoGBMemory(Memory.memoryLocationHdmaTrigger, setBitOnByte(7, hdmaTriggerByte));\n        return;\n    }\n    // Get our source and destination for the HDMA\n    var hdmaSource = getHdmaSourceFromMemory();\n    var hdmaDestination = getHdmaDestinationFromMemory();\n    // Get the length from the trigger\n    // Lower 7 bits, Add 1, times 16\n    // https://gist.github.com/drhelius/3394856\n    var transferLength = resetBitOnByte(7, hdmaTriggerByteToBeWritten);\n    transferLength = (transferLength + 1) << 4;\n    // Get bit 7 of the trigger for the HDMA type\n    if (checkBitOnByte(7, hdmaTriggerByteToBeWritten)) {\n        // H-Blank DMA\n        Memory.isHblankHdmaActive = true;\n        Memory.hblankHdmaTransferLengthRemaining = transferLength;\n        Memory.hblankHdmaSource = hdmaSource;\n        Memory.hblankHdmaDestination = hdmaDestination;\n        // This will be handled in updateHblankHdma()\n        // Since we return false in write traps, we need to now write the byte\n        // Be sure to reset bit 7, to show that the hdma is active\n        eightBitStoreIntoGBMemory(Memory.memoryLocationHdmaTrigger, resetBitOnByte(7, hdmaTriggerByteToBeWritten));\n    }\n    else {\n        // General DMA\n        hdmaTransfer(hdmaSource, hdmaDestination, transferLength);\n        // Stop the DMA\n        eightBitStoreIntoGBMemory(Memory.memoryLocationHdmaTrigger, 0xff);\n    }\n}\n// Inlined because closure compiler inlines\nfunction updateHblankHdma() {\n    if (!Memory.isHblankHdmaActive) {\n        return;\n    }\n    // Get our amount of bytes to transfer (Only 0x10 bytes at a time)\n    var bytesToTransfer = 0x10;\n    var hblankHdmaTransferLengthRemaining = Memory.hblankHdmaTransferLengthRemaining;\n    if (hblankHdmaTransferLengthRemaining < bytesToTransfer) {\n        // Set to the difference\n        bytesToTransfer = hblankHdmaTransferLengthRemaining;\n    }\n    // Do the transfer (Only 0x10 bytes at a time)\n    hdmaTransfer(Memory.hblankHdmaSource, Memory.hblankHdmaDestination, bytesToTransfer);\n    // Update our source and destination\n    Memory.hblankHdmaSource += bytesToTransfer;\n    Memory.hblankHdmaDestination += bytesToTransfer;\n    hblankHdmaTransferLengthRemaining -= bytesToTransfer;\n    Memory.hblankHdmaTransferLengthRemaining = hblankHdmaTransferLengthRemaining;\n    var memoryLocationHdmaTrigger = Memory.memoryLocationHdmaTrigger;\n    if (hblankHdmaTransferLengthRemaining <= 0) {\n        // End the transfer\n        Memory.isHblankHdmaActive = false;\n        // Need to clear the HDMA with 0xFF, which sets bit 7 to 1 to show the HDMA has ended\n        eightBitStoreIntoGBMemory(memoryLocationHdmaTrigger, 0xff);\n    }\n    else {\n        // Set our new transfer length, make sure it is in the weird format,\n        // and make sure bit 7 is 0, to show that the HDMA is Active\n        var remainingTransferLength = hblankHdmaTransferLengthRemaining;\n        var transferLengthAsByte = (remainingTransferLength >> 4) - 1;\n        eightBitStoreIntoGBMemory(memoryLocationHdmaTrigger, resetBitOnByte(7, transferLengthAsByte));\n    }\n}\n// Simple Function to transfer the bytes from a destination to a source for a general pourpose or Hblank HDMA\nfunction hdmaTransfer(hdmaSource, hdmaDestination, transferLength) {\n    for (var i = 0; i < transferLength; ++i) {\n        var sourceByte = eightBitLoadFromGBMemoryWithTraps(hdmaSource + i);\n        // get the hdmaDestination with wrapping\n        // See issue #61: https://github.com/torch2424/wasmBoy/issues/61\n        var hdmaDestinationWithWrapping = hdmaDestination + i;\n        while (hdmaDestinationWithWrapping > 0x9fff) {\n            // Simply clear the top 3 bits\n            hdmaDestinationWithWrapping -= 0x2000;\n        }\n        eightBitStoreIntoGBMemoryWithTraps(hdmaDestinationWithWrapping, sourceByte);\n    }\n    // Set our Cycles used for the HDMA\n    // Since DMA in GBC Double Speed Mode takes 80 micro seconds,\n    // And HDMA takes 8 micro seconds per 0x10 bytes in GBC Double Speed mode (and GBC Normal Mode)\n    // Will assume (644 / 10) cycles for GBC Double Speed Mode,\n    // and (644 / 10 / 2) for GBC Normal Mode\n    var hdmaCycles = 32 << Cpu.GBCDoubleSpeed;\n    hdmaCycles = hdmaCycles * (transferLength >> 4);\n    Memory.DMACycles += hdmaCycles;\n}\n// Function to get our HDMA Source\n// Follows the poan docs\n// Inlined because closure compiler inlines\nfunction getHdmaSourceFromMemory() {\n    // Get our source for the HDMA\n    var hdmaSourceHigh = eightBitLoadFromGBMemory(Memory.memoryLocationHdmaSourceHigh);\n    var hdmaSourceLow = eightBitLoadFromGBMemory(Memory.memoryLocationHdmaSourceLow);\n    var hdmaSource = concatenateBytes(hdmaSourceHigh, hdmaSourceLow);\n    // And off the appopriate bits for the source and destination\n    // And off the bottom 4 bits\n    hdmaSource = hdmaSource & 0xfff0;\n    return hdmaSource;\n}\n// Function to get our HDMA Destination\n// Follows the poan docs\n// Inlined because closure compiler inlines\nfunction getHdmaDestinationFromMemory() {\n    var hdmaDestinationHigh = eightBitLoadFromGBMemory(Memory.memoryLocationHdmaDestinationHigh);\n    var hdmaDestinationLow = eightBitLoadFromGBMemory(Memory.memoryLocationHdmaDestinationLow);\n    var hdmaDestination = concatenateBytes(hdmaDestinationHigh, hdmaDestinationLow);\n    // Can only be in VRAM, 0x8000 -> 0x9FF0\n    // Pan docs says to knock off upper 3 bits, and lower 4 bits\n    // Which gives us: 0001111111110000 or 0x1FF0\n    // Meaning we must add 0x8000\n    hdmaDestination = hdmaDestination & 0x1ff0;\n    hdmaDestination += Memory.videoRamLocation;\n    return hdmaDestination;\n}\n\n// Internal function to trap any modify data trying to be written to Gameboy memory\n// Follows the Gameboy memory map\n// Return true if you want to continue the write, return false to end it here\nfunction checkWriteTraps(offset, value) {\n    // Cpu\n    if (offset === Cpu.memoryLocationSpeedSwitch) {\n        // TCAGBD, only Bit 0 is writable\n        eightBitStoreIntoGBMemory(Cpu.memoryLocationSpeedSwitch, value & 0x01);\n        // We did the write, dont need to\n        return false;\n    }\n    // Handle Boot ROM Switch\n    if (Cpu.BootROMEnabled && offset === Cpu.memoryLocationBootROMSwitch) {\n        // Disable the boot rom\n        Cpu.BootROMEnabled = false;\n        // Set the program counter to be incremented after this command\n        Cpu.programCounter = 0x00ff;\n        // Allow the write\n        return true;\n    }\n    // Graphics\n    // Cache globals used multiple times for performance\n    var videoRamLocation = Memory.videoRamLocation;\n    var spriteInformationTableLocation = Memory.spriteInformationTableLocation;\n    // Handle banking\n    if (offset < videoRamLocation) {\n        handleBanking(offset, value);\n        return false;\n    }\n    // Check the graphics mode to see if we can write to VRAM\n    // http://gbdev.gg8.se/wiki/articles/Video_Display#Accessing_VRAM_and_OAM\n    if (offset >= videoRamLocation && offset < Memory.cartridgeRamLocation) {\n        // Can only read/write from VRAM During Modes 0 - 2\n        // See graphics/lcd.ts\n        // TODO: This can do more harm than good in a beta emulator,\n        // requires precise timing disabling for now\n        // if (Graphics.currentLcdMode > 2) {\n        //   return false;\n        // }\n        // Not batch processing here for performance\n        // batchProcessGraphics();\n        // Allow the original write, and return since we dont need to look anymore\n        return true;\n    }\n    // Be sure to copy everything in EchoRam to Work Ram\n    // Codeslinger: The ECHO memory region (0xE000-0xFDFF) is quite different because any data written here is also written in the equivelent ram memory region 0xC000-0xDDFF.\n    // Hence why it is called echo\n    if (offset >= Memory.echoRamLocation && offset < spriteInformationTableLocation) {\n        var wramOffset = offset - 0x2000;\n        eightBitStoreIntoGBMemory(wramOffset, value);\n        // Allow the original write, and return since we dont need to look anymore\n        return true;\n    }\n    // Also check for individal writes\n    // Can only read/write from OAM During Modes 0 - 1\n    // See graphics/lcd.ts\n    if (offset >= spriteInformationTableLocation && offset <= Memory.spriteInformationTableLocationEnd) {\n        // Can only read/write from OAM During Mode 2\n        // See graphics/lcd.ts\n        // if (Lcd.currentLcdMode < 2) {\n        // return false;\n        // }\n        // Not batch processing here for performance\n        // batchProcessGraphics();\n        // Allow the original write, and return since we dont need to look anymore\n        // return true;\n        return Lcd.currentLcdMode >= 2;\n    }\n    if (offset >= Memory.unusableMemoryLocation && offset <= Memory.unusableMemoryEndLocation) {\n        return false;\n    }\n    // Serial\n    if (offset === Serial.memoryLocationSerialTransferControl) {\n        // SC\n        return Serial.updateTransferControl(value);\n    }\n    // Sound\n    // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Registers\n    if (offset >= 0xff10 && offset <= 0xff26) {\n        batchProcessAudio();\n        return SoundRegisterWriteTraps(offset, value);\n    }\n    // FF27 - FF2F not used\n    // Final Wave Table for Channel 3\n    if (offset >= 0xff30 && offset <= 0xff3f) {\n        batchProcessAudio();\n        // Need to handle the write if channel 3 is enabled\n        if (Channel3.isEnabled) {\n            Channel3.handleWaveRamWrite(value);\n            return false;\n        }\n        return true;\n    }\n    // Other Memory effects fomr read/write to Lcd/Graphics\n    if (offset >= Lcd.memoryLocationLcdControl && offset <= Graphics.memoryLocationWindowX) {\n        // Not batch processing here for performance\n        // batchProcessGraphics();\n        if (offset === Lcd.memoryLocationLcdControl) {\n            // Shorcut for isLCD Enabled since it gets \"hot\"\n            Lcd.updateLcdControl(value);\n            return true;\n        }\n        if (offset === Lcd.memoryLocationLcdStatus) {\n            // We are handling the write here\n            Lcd.updateLcdStatus(value);\n            return false;\n        }\n        // reset the current scanline if the game tries to write to it\n        if (offset === Graphics.memoryLocationScanlineRegister) {\n            Graphics.scanlineRegister = 0;\n            eightBitStoreIntoGBMemory(offset, 0);\n            return false;\n        }\n        // Cache our coincidence compare\n        if (offset === Lcd.memoryLocationCoincidenceCompare) {\n            Lcd.coincidenceCompare = value;\n            return true;\n        }\n        // Do the direct memory access transfer for spriteInformationTable\n        // Check the graphics mode to see if we can write to VRAM\n        // http://gbdev.gg8.se/wiki/articles/Video_Display#Accessing_VRAM_and_OAM\n        if (offset === Graphics.memoryLocationDmaTransfer) {\n            // otherwise, perform a DMA transfer\n            // And allow the original write\n            startDmaTransfer(value);\n            return true;\n        }\n        // Scroll and Window XY\n        switch (offset) {\n            case Graphics.memoryLocationScrollX:\n                Graphics.scrollX = value;\n                return true;\n            case Graphics.memoryLocationScrollY:\n                Graphics.scrollY = value;\n                return true;\n            case Graphics.memoryLocationWindowX:\n                Graphics.windowX = value;\n                return true;\n            case Graphics.memoryLocationWindowY:\n                Graphics.windowY = value;\n                return true;\n        }\n        // Allow the original write, and return since we dont need to look anymore\n        return true;\n    }\n    // Do an HDMA\n    if (offset === Memory.memoryLocationHdmaTrigger) {\n        startHdmaTransfer(value);\n        return false;\n    }\n    // Don't allow banking if we are doing an Hblank HDM transfer\n    // https://gist.github.com/drhelius/3394856\n    if (offset === Memory.memoryLocationGBCWRAMBank || offset === Memory.memoryLocationGBCVRAMBank) {\n        if (Memory.isHblankHdmaActive) {\n            var hblankHdmaSource = Memory.hblankHdmaSource;\n            if ((hblankHdmaSource >= 0x4000 && hblankHdmaSource <= 0x7fff) || (hblankHdmaSource >= 0xd000 && hblankHdmaSource <= 0xdfff)) {\n                return false;\n            }\n        }\n    }\n    // Handle GBC Pallete Write\n    if (offset >= Palette.memoryLocationBackgroundPaletteIndex && offset <= Palette.memoryLocationSpritePaletteData) {\n        // Incremeenting the palette handled by the write\n        writeColorPaletteToMemory(offset, value);\n        return true;\n    }\n    // Handle timer writes\n    if (offset >= Timers.memoryLocationDividerRegister && offset <= Timers.memoryLocationTimerControl) {\n        // Batch Process\n        batchProcessTimers();\n        switch (offset) {\n            case Timers.memoryLocationDividerRegister:\n                Timers.updateDividerRegister();\n                return false;\n            case Timers.memoryLocationTimerCounter:\n                Timers.updateTimerCounter(value);\n                return true;\n            case Timers.memoryLocationTimerModulo:\n                Timers.updateTimerModulo(value);\n                return true;\n            case Timers.memoryLocationTimerControl:\n                Timers.updateTimerControl(value);\n                return true;\n        }\n        return true;\n    }\n    // Handle Joypad writes for HW reg caching\n    if (offset === Joypad.memoryLocationJoypadRegister) {\n        Joypad.updateJoypad(value);\n    }\n    // Handle Interrupt writes\n    if (offset === Interrupts.memoryLocationInterruptRequest) {\n        Interrupts.updateInterruptRequested(value);\n        return true;\n    }\n    if (offset === Interrupts.memoryLocationInterruptEnabled) {\n        Interrupts.updateInterruptEnabled(value);\n        return true;\n    }\n    // Allow the original write\n    return true;\n}\n\n// WasmBoy memory map:\n// Private function to translate a offset meant for the gameboy memory map\n// To the wasmboy memory map\n// Following: http://gameboy.mongenel.com/dmg/asmmemmap.html\n// And https://github.com/Dooskington/GameLad/wiki/Part-11---Memory-Bank-Controllers\n// Performance help from @dcodeIO, and awesome-gbdev\nfunction getWasmBoyOffsetFromGameBoyOffset(gameboyOffset) {\n    // Get the top byte and switch\n    var gameboyOffsetHighByte = gameboyOffset >> 12;\n    switch (gameboyOffsetHighByte) {\n        case 0x00:\n            // Check if we are currently executing the boot rom\n            // Otherwise, bottom 0x0000 -> 0x03FF is Cartridge ROM Ram Bank 1\n            if (Cpu.BootROMEnabled) {\n                if (Cpu.GBCEnabled) {\n                    // See: http://gbdev.gg8.se/wiki/articles/Gameboy_Bootstrap_ROM\n                    // \"The rom dump includes the 256 byte rom (0x0000-0x00FF) and the,\n                    // 1792 byte rom (0x0200-0x08FF) which Dr. Decapitator observed,\n                    // but not the 512 byte rom,\n                    // which may be cpu microcode or lcd color lookup related.\"\n                    // First 0xFF bytes are BOOT rom\n                    if (gameboyOffset < 0x0100) {\n                        return gameboyOffset + BOOT_ROM_LOCATION;\n                    }\n                    // 0x100 -> 0x1FF is the actual ROM\n                    // Everything from 0x200 -> 0x8FF is BOOT ROM Again\n                    if (gameboyOffset > 0x01ff && gameboyOffset < 0x0900) {\n                        return gameboyOffset + BOOT_ROM_LOCATION;\n                    }\n                }\n                else if (!Cpu.GBCEnabled && gameboyOffset < 0x0100) {\n                    return gameboyOffset + BOOT_ROM_LOCATION;\n                }\n            }\n        case 0x01:\n        case 0x02:\n        case 0x03:\n            // Cartridge ROM - Bank 0 (fixed)\n            // 0x0000 -> 0x0D2400\n            return gameboyOffset + CARTRIDGE_ROM_LOCATION;\n        case 0x04:\n        case 0x05:\n        case 0x06:\n        case 0x07:\n            // Cartridge ROM - Switchable Banks 1-xx\n            // 0x4000 -> (0x0D2400 + 0x4000)\n            return getRomBankAddress(gameboyOffset) + CARTRIDGE_ROM_LOCATION;\n        case 0x08:\n        case 0x09:\n            // Video RAM\n            // 0x8000 -> 0x000400\n            var vramBankId = 0;\n            if (Cpu.GBCEnabled) {\n                // Find our current VRAM Bank\n                vramBankId = eightBitLoadFromGBMemory(Memory.memoryLocationGBCVRAMBank) & 0x01;\n                // Even though We added another 0x2000, the Cartridge ram is pulled out of our Internal Memory Space\n                // Therefore, we do not need to adjust for this extra 0x2000\n            }\n            return gameboyOffset - Memory.videoRamLocation + VIDEO_RAM_LOCATION + 0x2000 * vramBankId;\n        case 0x0a:\n        case 0x0b:\n            // Cartridge RAM - A.K.A External RAM\n            // 0xA000 -> 0x008400\n            return getRamBankAddress(gameboyOffset) + CARTRIDGE_RAM_LOCATION;\n        case 0x0c:\n            // Gameboy Ram Bank 0\n            // 0xC000 -> 0x000400\n            // Don't need to add head, since we move out 0x200 from the cartridge ram\n            return gameboyOffset - Memory.internalRamBankZeroLocation + WORK_RAM_LOCATION;\n        case 0x0d:\n            // Gameboy Ram Banks, Switchable in GBC Mode\n            // 0xD000 -> 0x000400\n            // In CGB Mode 32 KBytes internal RAM are available.\n            // This memory is divided into 8 banks of 4 KBytes each.\n            // Bank 0 is always available in memory at C000-CFFF,\n            // Bank 1-7 can be selected into the address space at D000-DFFF.\n            // http://gbdev.gg8.se/wiki/articles/CGB_Registers#FF70_-_SVBK_-_CGB_Mode_Only_-_WRAM_Bank\n            // Get the last 3 bits to find our wram ID\n            var wramBankId = 0;\n            if (Cpu.GBCEnabled) {\n                wramBankId = eightBitLoadFromGBMemory(Memory.memoryLocationGBCWRAMBank) & 0x07;\n            }\n            wramBankId = wramBankId < 1 ? 1 : wramBankId;\n            // (0x1000 * (wramBankId - 1)) -> To find the correct wram bank.\n            // wramBankId - 1, because we alreayd have the space for wramBank 1, and are currently in it\n            // So need to address space for 6 OTHER banks\n            return gameboyOffset - Memory.internalRamBankZeroLocation + WORK_RAM_LOCATION + 0x1000 * (wramBankId - 1);\n        default:\n            // Everything Else after Gameboy Ram Banks\n            // 0xE000 -> 0x000400\n            // 0x6000 For the Extra WRAM Banks\n            return gameboyOffset - Memory.echoRamLocation + OTHER_GAMEBOY_INTERNAL_MEMORY_LOCATION;\n    }\n}\n\n// Breakpoints for memory / cpu\nvar Breakpoints = /** @class */ (function () {\n    function Breakpoints() {\n    }\n    Breakpoints.programCounter = -1;\n    Breakpoints.readGbMemory = -1;\n    Breakpoints.writeGbMemory = -1;\n    Breakpoints.reachedBreakpoint = false;\n    return Breakpoints;\n}());\nfunction setProgramCounterBreakpoint(breakpoint) {\n    Breakpoints.programCounter = breakpoint;\n}\nfunction resetProgramCounterBreakpoint() {\n    Breakpoints.programCounter = -1;\n}\nfunction setReadGbMemoryBreakpoint(breakpoint) {\n    Breakpoints.readGbMemory = breakpoint;\n}\nfunction resetReadGbMemoryBreakpoint() {\n    Breakpoints.readGbMemory = -1;\n}\nfunction setWriteGbMemoryBreakpoint(breakpoint) {\n    Breakpoints.writeGbMemory = breakpoint;\n}\nfunction resetWriteGbMemoryBreakpoint() {\n    Breakpoints.writeGbMemory = -1;\n}\n\n// Store / Write memory access\nfunction eightBitStoreIntoGBMemory(gameboyOffset, value) {\n    store(getWasmBoyOffsetFromGameBoyOffset(gameboyOffset), value);\n}\nfunction eightBitStoreIntoGBMemoryWithTraps(offset, value) {\n    if (offset === Breakpoints.writeGbMemory) {\n        Breakpoints.reachedBreakpoint = true;\n    }\n    if (checkWriteTraps(offset, value)) {\n        eightBitStoreIntoGBMemory(offset, value);\n    }\n}\nfunction sixteenBitStoreIntoGBMemoryWithTraps(offset, value) {\n    // Dividing into two seperate eight bit calls to help with debugging tilemap overwrites\n    // Split the value into two seperate bytes\n    var highByte = splitHighByte(value);\n    var lowByte = splitLowByte(value);\n    if (checkWriteTraps(offset, lowByte)) {\n        eightBitStoreIntoGBMemory(offset, lowByte);\n    }\n    var nextOffset = offset + 1;\n    if (checkWriteTraps(nextOffset, highByte)) {\n        eightBitStoreIntoGBMemory(nextOffset, highByte);\n    }\n}\nfunction sixteenBitStoreIntoGBMemory(offset, value) {\n    // Dividing into two seperate eight bit calls to help with debugging tilemap overwrites\n    // Split the value into two seperate bytes\n    var highByte = splitHighByte(value);\n    var lowByte = splitLowByte(value);\n    eightBitStoreIntoGBMemory(offset + 0, lowByte);\n    eightBitStoreIntoGBMemory(offset + 1, highByte);\n}\nfunction storeBooleanDirectlyToWasmMemory(offset, value) {\n    store(offset, value);\n}\n\n// Funcitons for setting and checking the LCD\nvar Lcd = /** @class */ (function () {\n    function Lcd() {\n    }\n    // Function called in write traps to update our hardware registers\n    Lcd.updateLcdStatus = function (value) {\n        // Bottom three bits are read only\n        var currentLcdStatus = eightBitLoadFromGBMemory(Lcd.memoryLocationLcdStatus);\n        var valueNoBottomBits = value & 0xf8;\n        var lcdStatusOnlyBottomBits = currentLcdStatus & 0x07;\n        value = valueNoBottomBits | lcdStatusOnlyBottomBits;\n        // Top bit is always 1\n        value = setBitOnByte(7, value);\n        eightBitStoreIntoGBMemory(Lcd.memoryLocationLcdStatus, value);\n    };\n    // Function called in write traps to update our hardware registers\n    Lcd.updateLcdControl = function (value) {\n        var wasLcdEnabled = Lcd.enabled;\n        Lcd.enabled = checkBitOnByte(7, value);\n        Lcd.windowTileMapDisplaySelect = checkBitOnByte(6, value);\n        Lcd.windowDisplayEnabled = checkBitOnByte(5, value);\n        Lcd.bgWindowTileDataSelect = checkBitOnByte(4, value);\n        Lcd.bgTileMapDisplaySelect = checkBitOnByte(3, value);\n        Lcd.tallSpriteSize = checkBitOnByte(2, value);\n        Lcd.spriteDisplayEnable = checkBitOnByte(1, value);\n        Lcd.bgDisplayEnabled = checkBitOnByte(0, value);\n        if (wasLcdEnabled && !Lcd.enabled) {\n            // Disable the LCD\n            resetLcd(true);\n        }\n        if (!wasLcdEnabled && Lcd.enabled) {\n            // Re-enable the LCD\n            resetLcd(false);\n        }\n    };\n    // Memory Locations\n    // Also known at STAT\n    // LCD Status (0xFF41) bits Explanation\n    // 0                0                    000                    0             00\n    //       |Coicedence Interrupt|     |Mode Interrupts|  |coincidence flag|  | Mode |\n    // Modes:\n    // 0 or 00: H-Blank\n    // 1 or 01: V-Blank\n    // 2 or 10: Searching Sprites Atts\n    // 3 or 11: Transfering Data to LCD Driver\n    Lcd.memoryLocationLcdStatus = 0xff41;\n    Lcd.currentLcdMode = 0;\n    Lcd.memoryLocationCoincidenceCompare = 0xff45;\n    Lcd.coincidenceCompare = 0;\n    // Also known as LCDC\n    // http://www.codeslinger.co.uk/pages/projects/gameboy/graphics.html\n    // Bit 7 - LCD Display Enable (0=Off, 1=On)\n    // Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)\n    // Bit 5 - Window Display Enable (0=Off, 1=On)\n    // Bit 4 - BG & Window Tile Data Select (0=8800-97FF, 1=8000-8FFF)\n    // Bit 3 - BG Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)\n    // Bit 2 - OBJ (Sprite) Size (0=8x8, 1=8x16)\n    // Bit 1 - OBJ (Sprite) Display Enable (0=Off, 1=On)\n    // Bit 0 - BG Display (for CGB see below) (0=Off, 1=On\n    Lcd.memoryLocationLcdControl = 0xff40;\n    // Decoupled LCDC for caching\n    Lcd.enabled = true;\n    Lcd.windowTileMapDisplaySelect = false;\n    Lcd.windowDisplayEnabled = false;\n    Lcd.bgWindowTileDataSelect = false;\n    Lcd.bgTileMapDisplaySelect = false;\n    Lcd.tallSpriteSize = false;\n    Lcd.spriteDisplayEnable = false;\n    Lcd.bgDisplayEnabled = false;\n    return Lcd;\n}());\nfunction resetLcd(shouldBlankScreen) {\n    // Reset scanline cycle counter\n    Graphics.scanlineCycleCounter = 0;\n    Graphics.scanlineRegister = 0;\n    eightBitStoreIntoGBMemory(Graphics.memoryLocationScanlineRegister, 0);\n    // Set to mode 0\n    // https://www.reddit.com/r/EmuDev/comments/4w6479/gb_dr_mario_level_generation_issues/\n    var lcdStatus = eightBitLoadFromGBMemory(Lcd.memoryLocationLcdStatus);\n    lcdStatus = resetBitOnByte(1, lcdStatus);\n    lcdStatus = resetBitOnByte(0, lcdStatus);\n    Lcd.currentLcdMode = 0;\n    // Store the status in memory\n    eightBitStoreIntoGBMemory(Lcd.memoryLocationLcdStatus, lcdStatus);\n    // Blank the screen\n    if (shouldBlankScreen) {\n        for (var i = 0; i < FRAME_SIZE; ++i) {\n            store(FRAME_LOCATION + i, 255);\n        }\n    }\n}\n// Pass in the lcd status for performance\n// Inlined because closure compiler inlines\nfunction setLcdStatus() {\n    // Check if the Lcd was disabled\n    if (!Lcd.enabled) {\n        return;\n    }\n    // Get our current scanline, and lcd mode\n    var scanlineRegister = Graphics.scanlineRegister;\n    var lcdMode = Lcd.currentLcdMode;\n    // Default to  H-Blank\n    var newLcdMode = 0;\n    // Find our newLcd mode\n    if (scanlineRegister >= 144) {\n        // VBlank mode\n        newLcdMode = 1;\n    }\n    else {\n        var scanlineCycleCounter = Graphics.scanlineCycleCounter;\n        var MIN_CYCLES_SPRITES_LCD_MODE = Graphics.MIN_CYCLES_SPRITES_LCD_MODE();\n        if (scanlineCycleCounter >= MIN_CYCLES_SPRITES_LCD_MODE) {\n            // Searching Sprites Atts\n            newLcdMode = 2;\n        }\n        else if (scanlineCycleCounter >= MIN_CYCLES_SPRITES_LCD_MODE) {\n            // Transferring data to lcd\n            newLcdMode = 3;\n        }\n    }\n    if (lcdMode !== newLcdMode) {\n        // Get our lcd status\n        var lcdStatus = eightBitLoadFromGBMemory(Lcd.memoryLocationLcdStatus);\n        // Save our lcd mode\n        Lcd.currentLcdMode = newLcdMode;\n        var shouldRequestInterrupt = false;\n        // Set our LCD Status accordingly\n        switch (newLcdMode) {\n            case 0x00:\n                lcdStatus = resetBitOnByte(0, lcdStatus);\n                lcdStatus = resetBitOnByte(1, lcdStatus);\n                shouldRequestInterrupt = checkBitOnByte(3, lcdStatus);\n                break;\n            case 0x01:\n                lcdStatus = resetBitOnByte(1, lcdStatus);\n                lcdStatus = setBitOnByte(0, lcdStatus);\n                shouldRequestInterrupt = checkBitOnByte(4, lcdStatus);\n                break;\n            case 0x02:\n                lcdStatus = resetBitOnByte(0, lcdStatus);\n                lcdStatus = setBitOnByte(1, lcdStatus);\n                shouldRequestInterrupt = checkBitOnByte(5, lcdStatus);\n                break;\n            case 0x03:\n                lcdStatus = setBitOnByte(0, lcdStatus);\n                lcdStatus = setBitOnByte(1, lcdStatus);\n                break;\n        }\n        // Check if we want to request an interrupt, and we JUST changed modes\n        if (shouldRequestInterrupt) {\n            requestLcdInterrupt();\n        }\n        // Check for updating the Hblank HDMA\n        if (newLcdMode === 0) {\n            // Update the Hblank DMA, will simply return if not active\n            updateHblankHdma();\n        }\n        // Check for requesting a VBLANK interrupt\n        if (newLcdMode === 1) {\n            requestVBlankInterrupt();\n        }\n        // Check for the coincidence\n        lcdStatus = checkCoincidence(newLcdMode, lcdStatus);\n        // Finally, save our status\n        eightBitStoreIntoGBMemory(Lcd.memoryLocationLcdStatus, lcdStatus);\n    }\n    else if (scanlineRegister === 153) {\n        // Special Case, need to check LYC\n        // Fix prehistorik man freeze\n        var lcdStatus = eightBitLoadFromGBMemory(Lcd.memoryLocationLcdStatus);\n        lcdStatus = checkCoincidence(newLcdMode, lcdStatus);\n        eightBitStoreIntoGBMemory(Lcd.memoryLocationLcdStatus, lcdStatus);\n    }\n}\nfunction checkCoincidence(lcdMode, lcdStatus) {\n    // Check for the coincidence flag\n    // Need to check on every mode, and not just HBLANK, as checking on hblank breaks shantae, which checks on vblank\n    if ((lcdMode === 0 || lcdMode === 1) && Graphics.scanlineRegister === Lcd.coincidenceCompare) {\n        lcdStatus = setBitOnByte(2, lcdStatus);\n        if (checkBitOnByte(6, lcdStatus)) {\n            requestLcdInterrupt();\n        }\n    }\n    else {\n        lcdStatus = resetBitOnByte(2, lcdStatus);\n    }\n    return lcdStatus;\n}\n\n// Functions for rendering the background\n// NOTE: i32Portable wraps modulo here as somehow it gets converted to a double:\n// https://github.com/torch2424/wasmboy/issues/216\n// Inlined because closure compiler inlines\nfunction renderBackground(scanlineRegister, tileDataMemoryLocation, tileMapMemoryLocation) {\n    // NOTE: Camera is reffering to what you can see inside the 160x144 viewport of the entire rendered 256x256 map.\n    // Get our scrollX and scrollY (u16 to play nice with assemblyscript)\n    // let scrollX: i32 = eightBitLoadFromGBMemory(Graphics.memoryLocationScrollX);\n    // let scrollY: i32 = eightBitLoadFromGBMemory(Graphics.memoryLocationScrollY);\n    var scrollX = Graphics.scrollX;\n    var scrollY = Graphics.scrollY;\n    // Get our current pixel y positon on the 160x144 camera (Row that the scanline draws across)\n    // this is done by getting the current scroll Y position,\n    // and adding it do what Y Value the scanline is drawing on the camera.\n    var pixelYPositionInMap = scanlineRegister + scrollY;\n    // Gameboy camera will \"wrap\" around the background map,\n    // meaning that if the pixelValue is 350, then we need to subtract 256 (decimal) to get it's actual value\n    // pixel values (scrollX and scrollY) range from 0x00 - 0xFF\n    pixelYPositionInMap &= 0x100 - 1;\n    // Draw the Background scanline\n    drawBackgroundWindowScanline(scanlineRegister, tileDataMemoryLocation, tileMapMemoryLocation, pixelYPositionInMap, 0, scrollX);\n}\n// Inlined because closure compiler inlines\nfunction renderWindow(scanlineRegister, tileDataMemoryLocation, tileMapMemoryLocation) {\n    // Get our windowX and windowY\n    // let windowX: i32 = eightBitLoadFromGBMemory(Graphics.memoryLocationWindowX);\n    // let windowY: i32 = eightBitLoadFromGBMemory(Graphics.memoryLocationWindowY);\n    var windowX = Graphics.windowX;\n    var windowY = Graphics.windowY;\n    // NOTE: Camera is reffering to what you can see inside the 160x144 viewport of the entire rendered 256x256 map.\n    // First ensure that the scanline is greater than our window\n    if (scanlineRegister < windowY) {\n        // Window is not within the current camera view\n        return;\n    }\n    // WindowX is offset by 7\n    windowX -= 7;\n    // Get our current pixel y positon on the 160x144 camera (Row that the scanline draws across)\n    var pixelYPositionInMap = scanlineRegister - windowY;\n    // xOffset is simply a neagative window x\n    // NOTE: This can become negative zero?\n    // https://github.com/torch2424/wasmboy/issues/216\n    var xOffset = i32Portable(-windowX);\n    // Draw the Background scanline\n    drawBackgroundWindowScanline(scanlineRegister, tileDataMemoryLocation, tileMapMemoryLocation, pixelYPositionInMap, windowX, xOffset);\n}\n// Function frankenstein'd together to allow background and window to share the same draw scanline function\nfunction drawBackgroundWindowScanline(scanlineRegister, tileDataMemoryLocation, tileMapMemoryLocation, pixelYPositionInMap, iStart, xOffset) {\n    // Get our tile Y position in the map\n    var tileYPositionInMap = pixelYPositionInMap >> 3;\n    // Loop through x to draw the line like a CRT\n    for (var i = iStart; i < 160; ++i) {\n        // Get our Current X position of our pixel on the on the 160x144 camera\n        // this is done by getting the current scroll X position,\n        // and adding it do what X Value the scanline is drawing on the camera.\n        var pixelXPositionInMap = i + xOffset;\n        // This is to compensate wrapping, same as pixelY\n        if (pixelXPositionInMap >= 0x100) {\n            pixelXPositionInMap -= 0x100;\n        }\n        // Divide our pixel position by 8 to get our tile.\n        // Since, there are 256x256 pixels, and 32x32 tiles.\n        // 256 / 8 = 32.\n        // Also, bitshifting by 3, do do a division by 8\n        // Need to use u16s, as they will be used to compute an address, which will cause weird errors and overflows\n        var tileXPositionInMap = pixelXPositionInMap >> 3;\n        // Get our tile address on the tileMap\n        // NOTE: (tileMap represents where each tile is displayed on the screen)\n        // NOTE: (tile map represents the entire map, now just what is within the \"camera\")\n        // For instance, if we have y pixel 144. 144 / 8 = 18. 18 * 32 = line address in map memory.\n        // And we have x pixel 160. 160 / 8 = 20.\n        // * 32, because remember, this is NOT only for the camera, the actual map is 32x32. Therefore, the next tile line of the map, is 32 byte offset.\n        // Think like indexing a 2d array, as a 1d array and it make sense :)\n        var tileMapAddress = tileMapMemoryLocation + (tileYPositionInMap << 5) + tileXPositionInMap;\n        // Get the tile Id on the Tile Map\n        var tileIdFromTileMap = loadFromVramBank(tileMapAddress, 0);\n        // Now that we have our Tile Id, let's check our Tile Cache\n        var usedTileCache = false;\n        if (Config.tileCaching) {\n            var pixelsDrawn = drawLineOfTileFromTileCache(i, scanlineRegister, pixelXPositionInMap, pixelYPositionInMap, tileMapAddress, tileDataMemoryLocation, tileIdFromTileMap);\n            // Increment i by 7, not 8 because i will be incremented at end of for loop\n            if (pixelsDrawn > 0) {\n                i += pixelsDrawn - 1;\n                usedTileCache = true;\n            }\n        }\n        if (Config.tileRendering && !usedTileCache) {\n            var pixelsDrawn = drawLineOfTileFromTileId(i, scanlineRegister, pixelXPositionInMap, pixelYPositionInMap, tileMapAddress, tileDataMemoryLocation, tileIdFromTileMap);\n            // A line of a tile is 8 pixels wide, therefore increase i by (pixelsDrawn - 1), and then the for loop will increment by 1\n            // For a net increment for 8\n            if (pixelsDrawn > 0) {\n                i += pixelsDrawn - 1;\n            }\n        }\n        else if (!usedTileCache) {\n            if (Cpu.GBCEnabled) {\n                // Draw the individual pixel\n                drawColorPixelFromTileId(i, scanlineRegister, pixelXPositionInMap, pixelYPositionInMap, tileMapAddress, tileDataMemoryLocation, tileIdFromTileMap);\n            }\n            else {\n                // Draw the individual pixel\n                drawMonochromePixelFromTileId(i, scanlineRegister, pixelXPositionInMap, pixelYPositionInMap, tileDataMemoryLocation, tileIdFromTileMap);\n            }\n        }\n    }\n}\n// Function to draw a pixel for the standard GB\n// Inlined because closure compiler inlines\nfunction drawMonochromePixelFromTileId(xPixel, yPixel, pixelXPositionInMap, pixelYPositionInMap, tileDataMemoryLocation, tileIdFromTileMap) {\n    // Now we can process the the individual bytes that represent the pixel on a tile\n    // Now get our tileDataAddress for the corresponding tileID we found in the map\n    // Read the comments in _getTileDataAddress() to see what's going on.\n    // tl;dr if we had the tile map of \"a b c d\", and wanted tileId 2.\n    // This funcitons returns the start of memory locaiton for the tile 'c'.\n    var tileDataAddress = getTileDataAddress(tileDataMemoryLocation, tileIdFromTileMap);\n    // Get the y pixel of the 8 by 8 tile.\n    // Simply modulo the scanline.\n    // For instance, let's say we are printing the first line of pixels on our camera,\n    // And the first line of pixels on our tile.\n    // yPixel = 1. 1 % 8 = 1.\n    // And for the last line\n    // yPixel = 144. 144 % 8 = 0.\n    // 0 Represents last line of pixels in a tile, 1 represents first. 1 2 3 4 5 6 7 0.\n    // Because remember, we are counting lines on the display NOT including zero\n    var pixelYInTile = i32Portable(pixelYPositionInMap & 7);\n    // Remember to represent a single line of 8 pixels on a tile, we need two bytes.\n    // Therefore, we need to times our modulo by 2, to get the correct line of pixels on the tile.\n    // Again, think like you had to map a 2d array as a 1d.\n    var byteOneForLineOfTilePixels = loadFromVramBank(tileDataAddress + pixelYInTile * 2, 0);\n    var byteTwoForLineOfTilePixels = loadFromVramBank(tileDataAddress + pixelYInTile * 2 + 1, 0);\n    // Same logic as pixelYInTile.\n    // However, We need to reverse our byte,\n    // As pixel 0 is on byte 7, and pixel 1 is on byte 6, etc...\n    // Therefore, is pixelX was 2, then really is need to be 5\n    // So 2 - 7 = -5, * 1 = 5\n    // Or to simplify, 7 - 2 = 5 haha!\n    var pixelXInTile = i32Portable(pixelXPositionInMap & 7);\n    pixelXInTile = 7 - pixelXInTile;\n    // Now we can get the color for that pixel\n    // Colors are represented by getting X position of ByteTwo, and X positon of Byte One\n    // To Get the color Id.\n    // For example, the result of the color id is 0000 00[xPixelByteTwo][xPixelByteOne]\n    // See: How to draw a tile/sprite from memory: http://www.codeslinger.co.uk/pages/projects/gameboy/graphics.html\n    var paletteColorId = 0;\n    if (checkBitOnByte(pixelXInTile, byteTwoForLineOfTilePixels)) {\n        // Byte one represents the second bit in our color id, so bit shift\n        paletteColorId += 1;\n        paletteColorId = paletteColorId << 1;\n    }\n    if (checkBitOnByte(pixelXInTile, byteOneForLineOfTilePixels)) {\n        paletteColorId += 1;\n    }\n    // Not checking u8 Portability overflow here, since it can't be greater than i32 over :p\n    // Now get the colorId from the pallete, to get our final color\n    // Developers could change colorIds to represents different colors\n    // in their palette, thus we need to grab the color from there\n    //let pixelColorInTileFromPalette: u8 = getColorFromPalette(paletteColorId, Graphics.memoryLocationBackgroundPalette);\n    // Moved below for perofrmance\n    // FINALLY, RENDER THAT PIXEL!\n    // Only rendering camera for now, so coordinates are for the camera.\n    // Get the rgb value for the color Id, will be repeated into R, G, B. if not colorized\n    var hexColor = getColorizedGbHexColorFromPalette(paletteColorId, Graphics.memoryLocationBackgroundPalette);\n    setPixelOnFrame(xPixel, yPixel, 0, getRedFromHexColor(hexColor));\n    setPixelOnFrame(xPixel, yPixel, 1, getGreenFromHexColor(hexColor));\n    setPixelOnFrame(xPixel, yPixel, 2, getBlueFromHexColor(hexColor));\n    // Lastly, add the pixel to our background priority map\n    // https://github.com/torch2424/wasmBoy/issues/51\n    // Bits 0 & 1 will represent the color Id drawn by the BG/Window\n    // Bit 2 will represent if the Bg/Window has GBC priority.\n    addPriorityforPixel(xPixel, yPixel, paletteColorId);\n}\n// Function to draw a pixel from a tile in C O L O R\n// See above for more context on some variables\n// Inlined because closure compiler inlines\nfunction drawColorPixelFromTileId(xPixel, yPixel, pixelXPositionInMap, pixelYPositionInMap, tileMapAddress, tileDataMemoryLocation, tileIdFromTileMap) {\n    // Now get our tileDataAddress for the corresponding tileID we found in the map\n    // Read the comments in _getTileDataAddress() to see what's going on.\n    // tl;dr if we had the tile map of \"a b c d\", and wanted tileId 2.\n    // This funcitons returns the start of memory locaiton for the tile 'c'.\n    var tileDataAddress = getTileDataAddress(tileDataMemoryLocation, tileIdFromTileMap);\n    // Get the GB Map Attributes\n    // Bit 0-2  Background Palette number  (BGP0-7)\n    // Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)\n    // Bit 4    Not used\n    // Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)\n    // Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)\n    // Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)\n    var bgMapAttributes = loadFromVramBank(tileMapAddress, 1);\n    // See above for explanation\n    var pixelYInTile = i32Portable(pixelYPositionInMap & 7);\n    if (checkBitOnByte(6, bgMapAttributes)) {\n        // We are mirroring the tile, therefore, we need to opposite byte\n        // So if our pixel was 0 our of 8, it wild become 7 :)\n        pixelYInTile = 7 - pixelYInTile;\n    }\n    // Remember to represent a single line of 8 pixels on a tile, we need two bytes.\n    // Therefore, we need to times our modulo by 2, to get the correct line of pixels on the tile.\n    // But we need to load the time from a specific Vram bank\n    var vramBankId = i32Portable(checkBitOnByte(3, bgMapAttributes));\n    var byteOneForLineOfTilePixels = loadFromVramBank(tileDataAddress + pixelYInTile * 2, vramBankId);\n    var byteTwoForLineOfTilePixels = loadFromVramBank(tileDataAddress + pixelYInTile * 2 + 1, vramBankId);\n    // Get our X pixel. Need to NOT reverse it if it was flipped.\n    // See above, you have to reverse this normally\n    var pixelXInTile = i32Portable(pixelXPositionInMap & 7);\n    if (!checkBitOnByte(5, bgMapAttributes)) {\n        pixelXInTile = 7 - pixelXInTile;\n    }\n    // Now we can get the color for that pixel\n    // Colors are represented by getting X position of ByteTwo, and X positon of Byte One\n    // To Get the color Id.\n    // For example, the result of the color id is 0000 00[xPixelByteTwo][xPixelByteOne]\n    // See: How to draw a tile/sprite from memory: http://www.codeslinger.co.uk/pages/projects/gameboy/graphics.html\n    var paletteColorId = 0;\n    if (checkBitOnByte(pixelXInTile, byteTwoForLineOfTilePixels)) {\n        // Byte one represents the second bit in our color id, so bit shift\n        paletteColorId += 1;\n        paletteColorId = paletteColorId << 1;\n    }\n    if (checkBitOnByte(pixelXInTile, byteOneForLineOfTilePixels)) {\n        paletteColorId += 1;\n    }\n    // Finally lets add some, C O L O R\n    // Want the botom 3 bits\n    var bgPalette = bgMapAttributes & 0x07;\n    // Call the helper function to grab the correct color from the palette\n    var rgbColorPalette = getRgbColorFromPalette(bgPalette, paletteColorId, false);\n    // Split off into red green and blue\n    var red = getColorComponentFromRgb(0, rgbColorPalette);\n    var green = getColorComponentFromRgb(1, rgbColorPalette);\n    var blue = getColorComponentFromRgb(2, rgbColorPalette);\n    // Finally Place our colors on the things\n    setPixelOnFrame(xPixel, yPixel, 0, red);\n    setPixelOnFrame(xPixel, yPixel, 1, green);\n    setPixelOnFrame(xPixel, yPixel, 2, blue);\n    // Lastly, add the pixel to our background priority map\n    // https://github.com/torch2424/wasmBoy/issues/51\n    // Bits 0 & 1 will represent the color Id drawn by the BG/Window\n    // Bit 2 will represent if the Bg/Window has GBC priority.\n    addPriorityforPixel(xPixel, yPixel, paletteColorId, checkBitOnByte(7, bgMapAttributes));\n}\n// Function to attempt to draw the tile from the tile cache\n// Inlined because closure compiler inlines\nfunction drawLineOfTileFromTileCache(xPixel, yPixel, pixelXPositionInMap, pixelYPositionInMap, tileMapAddress, tileDataMemoryLocation, tileIdFromTileMap) {\n    // First, initialize how many pixels we have drawn\n    var pixelsDrawn = 0;\n    // Check if the current tile matches our tileId\n    // TODO: Allow the first line to use the tile cache, for some odd reason it doesn't work when scanline is 0\n    var nextXIndexToPerformCacheCheck = TileCache.nextXIndexToPerformCacheCheck;\n    if (yPixel > 0 && xPixel > 8 && tileIdFromTileMap === TileCache.tileId && xPixel === nextXIndexToPerformCacheCheck) {\n        // Was last tile flipped\n        var wasLastTileHorizontallyFlipped = checkBitOnByte(5, eightBitLoadFromGBMemory(tileMapAddress - 1));\n        var isCurrentTileHorizontallyFlipped = checkBitOnByte(5, eightBitLoadFromGBMemory(tileMapAddress));\n        // Simply copy the last 8 pixels from memory to copy the line from the tile\n        for (var tileCacheIndex = 0; tileCacheIndex < 8; ++tileCacheIndex) {\n            // Check if we need to render backwards for flipping\n            if (wasLastTileHorizontallyFlipped !== isCurrentTileHorizontallyFlipped) {\n                tileCacheIndex = 7 - tileCacheIndex;\n            }\n            var xPos = xPixel + tileCacheIndex;\n            // First check for overflow\n            if (xPos <= 160) {\n                // Get the pixel location in memory of the tile\n                var previousXPixel = xPixel - (8 - tileCacheIndex);\n                var previousTilePixelLocation = FRAME_LOCATION + getRgbPixelStart(xPos, yPixel);\n                // Cycle through the RGB\n                // for (let tileCacheRgb = 0; tileCacheRgb < 3; ++tileCacheRgb) {\n                //  setPixelOnFrame(xPixel + tileCacheIndex, yPixel, tileCacheRgb, load<u8>(previousTilePixelLocation + tileCacheRgb));\n                // }\n                // unroll\n                setPixelOnFrame(xPos, yPixel, 0, load(previousTilePixelLocation, 0));\n                setPixelOnFrame(xPos, yPixel, 1, load(previousTilePixelLocation, 1));\n                setPixelOnFrame(xPos, yPixel, 2, load(previousTilePixelLocation, 2));\n                // Copy the priority for the pixel\n                var pixelPriority = getPriorityforPixel(previousXPixel, yPixel);\n                addPriorityforPixel(xPos, yPixel, resetBitOnByte(2, pixelPriority), checkBitOnByte(2, pixelPriority));\n                pixelsDrawn++;\n            }\n        }\n    }\n    else {\n        // Save our current tile Id, and the next x value we should check the x index\n        TileCache.tileId = tileIdFromTileMap;\n    }\n    // Calculate when we should do the tileCache calculation again\n    if (xPixel >= nextXIndexToPerformCacheCheck) {\n        nextXIndexToPerformCacheCheck = xPixel + 8;\n        var xOffsetTileWidthRemainder = i32Portable(pixelXPositionInMap & 7);\n        if (xPixel < xOffsetTileWidthRemainder) {\n            nextXIndexToPerformCacheCheck += xOffsetTileWidthRemainder;\n        }\n    }\n    TileCache.nextXIndexToPerformCacheCheck = nextXIndexToPerformCacheCheck;\n    return pixelsDrawn;\n}\n// Function to draw a line of a tile in Color\n// This is for tile rendering shortcuts\n// Inlined because closure compiler inlines\nfunction drawLineOfTileFromTileId(xPixel, yPixel, pixelXPositionInMap, pixelYPositionInMap, tileMapAddress, tileDataMemoryLocation, tileIdFromTileMap) {\n    // Get the which line of the tile we are rendering\n    var tileLineY = i32Portable(pixelYPositionInMap & 7);\n    // Now lets find our tileX start and end\n    // This is for the case where i = 0, but scroll X was 3.\n    // Or i is 157, and our camera is only 160 pixels wide\n    var tileXStart = 0;\n    if (xPixel == 0) {\n        tileXStart = pixelXPositionInMap - ((pixelXPositionInMap >> 3) << 3);\n    }\n    var tileXEnd = 7;\n    if (xPixel + 8 > 160) {\n        tileXEnd = 160 - xPixel;\n    }\n    // initialize some variables for GBC\n    var bgMapAttributes = -1;\n    var vramBankId = 0;\n    if (Cpu.GBCEnabled) {\n        // Get Our GBC properties\n        bgMapAttributes = loadFromVramBank(tileMapAddress, 1);\n        vramBankId = i32Portable(checkBitOnByte(3, bgMapAttributes));\n        if (checkBitOnByte(6, bgMapAttributes)) {\n            // We are mirroring the tile, therefore, we need to opposite byte\n            // So if our pixel was 0 our of 8, it wild become 7 :)\n            tileLineY = 7 - tileLineY;\n        }\n    }\n    // Return the number of pixels drawn\n    return drawPixelsFromLineOfTile(tileIdFromTileMap, tileDataMemoryLocation, vramBankId, tileXStart, tileXEnd, tileLineY, xPixel, yPixel, 160, FRAME_LOCATION, false, 0, bgMapAttributes, -1);\n}\n\n// Functions for rendering the sprites\n// Inlined because closure compiler inlines\nfunction renderSprites(scanlineRegister, useLargerSprites) {\n    // Need to loop through all 40 sprites to check their status\n    // Going backwards since lower sprites draw over higher ones\n    // Will fix dragon warrior 3 intro\n    for (var i = 39; i >= 0; --i) {\n        // Sprites occupy 4 bytes in the sprite attribute table\n        var spriteTableIndex = i * 4;\n        // Y positon is offset by 16, X position is offset by 8\n        var index = Graphics.memoryLocationSpriteAttributesTable + spriteTableIndex;\n        var spriteYPosition = eightBitLoadFromGBMemory(index + 0);\n        var spriteXPosition = eightBitLoadFromGBMemory(index + 1);\n        var spriteTileId = eightBitLoadFromGBMemory(index + 2);\n        // Pan docs of sprite attirbute table\n        // Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)\n        //      (Used for both BG and Window. BG color 0 is always behind OBJ)\n        // Bit6   Y flip          (0=Normal, 1=Vertically mirrored)\n        // Bit5   X flip          (0=Normal, 1=Horizontally mirrored)\n        // Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)\n        // Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)\n        // Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)\n        // Apply sprite X and Y offset\n        // TODO: Sprites are overflowing on x if less than 8\n        spriteYPosition -= 16;\n        spriteXPosition -= 8;\n        // Find our sprite height\n        var spriteHeight = 8;\n        if (useLargerSprites) {\n            spriteHeight = 16;\n            // @binji says in 8x16 mode, even tileId always drawn first\n            // This will fix shantae sprites which always uses odd numbered indexes\n            // TODO: Do the actual Pandocs thing:\n            // \"In 8x16 mode, the lower bit of the tile number is ignored. Ie. the upper 8x8 tile is \"NN AND FEh\", and the lower 8x8 tile is \"NN OR 01h\".\"\n            // So just knock off the last bit? :)\n            spriteTileId -= spriteTileId & 1;\n        }\n        // Find if our sprite is on the current scanline\n        if (scanlineRegister >= spriteYPosition && scanlineRegister < spriteYPosition + spriteHeight) {\n            // Then we need to draw the current sprite\n            // Get our sprite attributes since we know we shall be drawing the tile\n            var spriteAttributes = eightBitLoadFromGBMemory(Graphics.memoryLocationSpriteAttributesTable + spriteTableIndex + 3);\n            // Check sprite Priority\n            var isSpritePriorityBehindWindowAndBackground = checkBitOnByte(7, spriteAttributes);\n            // Check if we should flip the sprite on the x or y axis\n            var flipSpriteY = checkBitOnByte(6, spriteAttributes);\n            var flipSpriteX = checkBitOnByte(5, spriteAttributes);\n            // TODO: Torch2424 continue here.\n            // Find which line on the sprite we are on\n            var currentSpriteLine = scanlineRegister - spriteYPosition;\n            // If we fliiped the Y axis on our sprite, need to read from memory backwards to acheive the same effect\n            if (flipSpriteY) {\n                currentSpriteLine = spriteHeight - currentSpriteLine;\n                // Bug fix for the flipped flies in link's awakening\n                currentSpriteLine -= 1;\n            }\n            // Each line of a tile takes two bytes of memory\n            currentSpriteLine <<= 1;\n            // Get our sprite tile address, need to also add the current sprite line to get the correct bytes\n            var spriteTileAddressStart = getTileDataAddress(Graphics.memoryLocationTileDataSelectOneStart, spriteTileId);\n            spriteTileAddressStart += currentSpriteLine;\n            var spriteTileAddress = spriteTileAddressStart;\n            // Find which VRAM Bank to load from\n            var vramBankId = (Cpu.GBCEnabled && checkBitOnByte(3, spriteAttributes));\n            var spriteDataByteOneForLineOfTilePixels = loadFromVramBank(spriteTileAddress + 0, vramBankId);\n            var spriteDataByteTwoForLineOfTilePixels = loadFromVramBank(spriteTileAddress + 1, vramBankId);\n            // Iterate over the width of our sprite to find our individual pixels\n            for (var tilePixel = 7; tilePixel >= 0; --tilePixel) {\n                // Get our spritePixel, and check for flipping\n                var spritePixelXInTile = tilePixel;\n                if (flipSpriteX) {\n                    spritePixelXInTile -= 7;\n                    spritePixelXInTile = -spritePixelXInTile;\n                }\n                // Get the color Id of our sprite, similar to renderBackground()\n                // With the first byte, and second byte lined up method thing\n                // Yes, the second byte comes before the first, see ./background.ts\n                var spriteColorId = 0;\n                if (checkBitOnByte(spritePixelXInTile, spriteDataByteTwoForLineOfTilePixels)) {\n                    // Byte one represents the second bit in our color id, so bit shift\n                    spriteColorId = (spriteColorId + 1) << 1;\n                }\n                if (checkBitOnByte(spritePixelXInTile, spriteDataByteOneForLineOfTilePixels)) {\n                    spriteColorId += 1;\n                }\n                // ColorId zero (last two bits of pallette) are transparent\n                // http://gbdev.gg8.se/wiki/articles/Video_Display\n                if (spriteColorId !== 0) {\n                    // Find our actual X pixel location on the gameboy \"camera\" view\n                    // This cannot be less than zero, i32 will overflow\n                    var spriteXPixelLocationInCameraView = spriteXPosition + (7 - tilePixel);\n                    if (spriteXPixelLocationInCameraView >= 0 && spriteXPixelLocationInCameraView <= 160) {\n                        // There are two cases where wouldnt draw the pixel on top of the Bg/window\n                        // 1. if isSpritePriorityBehindWindowAndBackground, sprite can only draw over color 0\n                        // 2. if bit 2 of our priority is set, then BG-to-OAM Priority from pandoc\n                        //  is active, meaning BG tile will have priority above all OBJs\n                        //  (regardless of the priority bits in OAM memory)\n                        // But if GBC and Bit 0 of LCDC is set, we always draw the object\n                        var shouldShowFromLcdcPriority = Cpu.GBCEnabled && !Lcd.bgDisplayEnabled; // LCDC Priority\n                        var shouldHideFromOamPriority = false;\n                        var shouldHideFromBgPriority = false;\n                        if (!shouldShowFromLcdcPriority) {\n                            // Now that we have our coordinates, check for sprite priority\n                            // Lets get the priority byte we put in memory\n                            var bgPriorityByte = getPriorityforPixel(spriteXPixelLocationInCameraView, scanlineRegister);\n                            var bgColorFromPriorityByte = bgPriorityByte & 0x03;\n                            // Doing an else if, since either will automatically stop drawing the pixel\n                            if (isSpritePriorityBehindWindowAndBackground && bgColorFromPriorityByte > 0) {\n                                // OAM Priority\n                                shouldHideFromOamPriority = true;\n                            }\n                            else if (Cpu.GBCEnabled && checkBitOnByte(2, bgPriorityByte) && bgColorFromPriorityByte > 0) {\n                                // Bg priority\n                                shouldHideFromBgPriority = true;\n                            }\n                        }\n                        if (shouldShowFromLcdcPriority || (!shouldHideFromOamPriority && !shouldHideFromBgPriority)) {\n                            if (!Cpu.GBCEnabled) {\n                                // Get our monochrome color RGB from the current sprite pallete\n                                // Get our sprite pallete\n                                var spritePaletteLocation = Graphics.memoryLocationSpritePaletteOne;\n                                if (checkBitOnByte(4, spriteAttributes)) {\n                                    spritePaletteLocation = Graphics.memoryLocationSpritePaletteTwo;\n                                }\n                                var hexColor = getColorizedGbHexColorFromPalette(spriteColorId, spritePaletteLocation);\n                                // Finally set the pixel!\n                                setPixelOnFrame(spriteXPixelLocationInCameraView, scanlineRegister, 0, getRedFromHexColor(hexColor));\n                                setPixelOnFrame(spriteXPixelLocationInCameraView, scanlineRegister, 1, getGreenFromHexColor(hexColor));\n                                setPixelOnFrame(spriteXPixelLocationInCameraView, scanlineRegister, 2, getBlueFromHexColor(hexColor));\n                            }\n                            else {\n                                // Get our RGB Color\n                                // Finally lets add some, C O L O R\n                                // Want the botom 3 bits\n                                var bgPalette = spriteAttributes & 0x07;\n                                // Call the helper function to grab the correct color from the palette\n                                var rgbColorPalette = getRgbColorFromPalette(bgPalette, spriteColorId, true);\n                                // Split off into red green and blue\n                                var red = getColorComponentFromRgb(0, rgbColorPalette);\n                                var green = getColorComponentFromRgb(1, rgbColorPalette);\n                                var blue = getColorComponentFromRgb(2, rgbColorPalette);\n                                // Finally Place our colors on the things\n                                setPixelOnFrame(spriteXPixelLocationInCameraView, scanlineRegister, 0, red);\n                                setPixelOnFrame(spriteXPixelLocationInCameraView, scanlineRegister, 1, green);\n                                setPixelOnFrame(spriteXPixelLocationInCameraView, scanlineRegister, 2, blue);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n// Main Class and funcitons for rendering the gameboy display\nvar Graphics = /** @class */ (function () {\n    function Graphics() {\n    }\n    // Number of cycles to run in each batch process\n    // This number should be in sync so that graphics doesn't run too many cyles at once\n    // and does not exceed the minimum number of cyles for either scanlines, or\n    // How often we change the frame, or a channel's update process\n    Graphics.batchProcessCycles = function () {\n        return Graphics.MAX_CYCLES_PER_SCANLINE();\n    };\n    // TCAGBD says 456 per scanline, but 153 only a handful\n    Graphics.MAX_CYCLES_PER_SCANLINE = function () {\n        if (Graphics.scanlineRegister === 153) {\n            return 4 << Cpu.GBCDoubleSpeed;\n        }\n        else {\n            return 456 << Cpu.GBCDoubleSpeed;\n        }\n    };\n    Graphics.MIN_CYCLES_SPRITES_LCD_MODE = function () {\n        // TODO: Confirm these clock cyles, double similar to scanline, which TCAGBD did\n        return 376 << Cpu.GBCDoubleSpeed;\n    };\n    Graphics.MIN_CYCLES_TRANSFER_DATA_LCD_MODE = function () {\n        // TODO: Confirm these clock cyles, double similar to scanline, which TCAGBD did\n        return 249 << Cpu.GBCDoubleSpeed;\n    };\n    // Function to save the state of the class\n    Graphics.saveState = function () {\n        // Graphics\n        store(getSaveStateMemoryOffset(0x00, Graphics.saveStateSlot), Graphics.scanlineCycleCounter);\n        store(getSaveStateMemoryOffset(0x04, Graphics.saveStateSlot), Graphics.scanlineRegister);\n        store(getSaveStateMemoryOffset(0x05, Graphics.saveStateSlot), Graphics.scrollX);\n        store(getSaveStateMemoryOffset(0x06, Graphics.saveStateSlot), Graphics.scrollY);\n        store(getSaveStateMemoryOffset(0x07, Graphics.saveStateSlot), Graphics.windowX);\n        store(getSaveStateMemoryOffset(0x08, Graphics.saveStateSlot), Graphics.windowY);\n        // LCD\n        store(getSaveStateMemoryOffset(0x09, Graphics.saveStateSlot), Lcd.currentLcdMode);\n        store(getSaveStateMemoryOffset(0x0a, Graphics.saveStateSlot), Lcd.coincidenceCompare);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0b, Graphics.saveStateSlot), Lcd.enabled);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0c, Graphics.saveStateSlot), Lcd.windowTileMapDisplaySelect);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0d, Graphics.saveStateSlot), Lcd.windowDisplayEnabled);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0e, Graphics.saveStateSlot), Lcd.bgWindowTileDataSelect);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0f, Graphics.saveStateSlot), Lcd.bgTileMapDisplaySelect);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x10, Graphics.saveStateSlot), Lcd.tallSpriteSize);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x11, Graphics.saveStateSlot), Lcd.spriteDisplayEnable);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x12, Graphics.saveStateSlot), Lcd.bgDisplayEnabled);\n    };\n    // Function to load the save state from memory\n    Graphics.loadState = function () {\n        // Graphics\n        Graphics.scanlineCycleCounter = load(getSaveStateMemoryOffset(0x00, Graphics.saveStateSlot));\n        Graphics.scanlineRegister = load(getSaveStateMemoryOffset(0x04, Graphics.scanlineRegister));\n        Graphics.scrollX = load(getSaveStateMemoryOffset(0x05, Graphics.saveStateSlot));\n        Graphics.scrollY = load(getSaveStateMemoryOffset(0x06, Graphics.saveStateSlot));\n        Graphics.windowX = load(getSaveStateMemoryOffset(0x07, Graphics.saveStateSlot));\n        Graphics.windowY = load(getSaveStateMemoryOffset(0x08, Graphics.saveStateSlot));\n        // LCD\n        Lcd.currentLcdMode = load(getSaveStateMemoryOffset(0x09, Graphics.saveStateSlot));\n        Lcd.coincidenceCompare = load(getSaveStateMemoryOffset(0x0a, Graphics.saveStateSlot));\n        Lcd.enabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0b, Graphics.saveStateSlot));\n        Lcd.windowTileMapDisplaySelect = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0c, Graphics.saveStateSlot));\n        Lcd.windowDisplayEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0d, Graphics.saveStateSlot));\n        Lcd.bgWindowTileDataSelect = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0e, Graphics.saveStateSlot));\n        Lcd.bgTileMapDisplaySelect = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0f, Graphics.saveStateSlot));\n        Lcd.tallSpriteSize = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x10, Graphics.saveStateSlot));\n        Lcd.spriteDisplayEnable = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x11, Graphics.saveStateSlot));\n        Lcd.bgDisplayEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x12, Graphics.saveStateSlot));\n    };\n    // Current cycles\n    // This will be used for batch processing\n    Graphics.currentCycles = 0;\n    // Count the number of cycles to keep synced with cpu cycles\n    // Found GBC cycles by finding clock speed from Gb Cycles\n    // See TCAGBD For cycles\n    Graphics.scanlineCycleCounter = 0x00;\n    // LCD\n    // scanlineRegister also known as LY\n    // See: http://bgb.bircd.org/pandocs.txt , and search \" LY \"\n    Graphics.memoryLocationScanlineRegister = 0xff44;\n    Graphics.scanlineRegister = 0;\n    Graphics.memoryLocationDmaTransfer = 0xff46;\n    // Scroll and Window\n    Graphics.memoryLocationScrollX = 0xff43;\n    Graphics.scrollX = 0;\n    Graphics.memoryLocationScrollY = 0xff42;\n    Graphics.scrollY = 0;\n    Graphics.memoryLocationWindowX = 0xff4b;\n    Graphics.windowX = 0;\n    Graphics.memoryLocationWindowY = 0xff4a;\n    Graphics.windowY = 0;\n    // Tile Maps And Data\n    Graphics.memoryLocationTileMapSelectZeroStart = 0x9800;\n    Graphics.memoryLocationTileMapSelectOneStart = 0x9c00;\n    Graphics.memoryLocationTileDataSelectZeroStart = 0x8800;\n    Graphics.memoryLocationTileDataSelectOneStart = 0x8000;\n    // Sprites\n    Graphics.memoryLocationSpriteAttributesTable = 0xfe00;\n    // Palettes\n    Graphics.memoryLocationBackgroundPalette = 0xff47;\n    Graphics.memoryLocationSpritePaletteOne = 0xff48;\n    Graphics.memoryLocationSpritePaletteTwo = 0xff49;\n    // Screen data needs to be stored in wasm memory\n    // Save States\n    Graphics.saveStateSlot = 1;\n    return Graphics;\n}());\n// Batch Process Graphics\n// http://gameboy.mongenel.com/dmg/asmmemmap.html and http://gbdev.gg8.se/wiki/articles/Video_Display\n// Function to batch process our graphics after we skipped so many cycles\n// This is not currently checked in memory read/write\nfunction batchProcessGraphics() {\n    var batchProcessCycles = Graphics.batchProcessCycles();\n    while (Graphics.currentCycles >= batchProcessCycles) {\n        updateGraphics(batchProcessCycles);\n        Graphics.currentCycles -= batchProcessCycles;\n    }\n}\n// Inlined because closure compiler inlines\nfunction initializeGraphics() {\n    // Reset Stateful Variables\n    Graphics.currentCycles = 0;\n    Graphics.scanlineCycleCounter = 0x00;\n    Graphics.scanlineRegister = 0;\n    Graphics.scrollX = 0;\n    Graphics.scrollY = 0;\n    Graphics.windowX = 0;\n    Graphics.windowY = 0;\n    Graphics.scanlineRegister = 0x90;\n    if (Cpu.GBCEnabled) {\n        eightBitStoreIntoGBMemory(0xff41, 0x81);\n        // 0xFF42 -> 0xFF43 = 0x00\n        eightBitStoreIntoGBMemory(0xff44, 0x90);\n        // 0xFF45 -> 0xFF46 = 0x00\n        eightBitStoreIntoGBMemory(0xff47, 0xfc);\n        // 0xFF48 -> 0xFF4B = 0x00\n    }\n    else {\n        eightBitStoreIntoGBMemory(0xff41, 0x85);\n        // 0xFF42 -> 0xFF45 = 0x00\n        eightBitStoreIntoGBMemory(0xff46, 0xff);\n        eightBitStoreIntoGBMemory(0xff47, 0xfc);\n        eightBitStoreIntoGBMemory(0xff48, 0xff);\n        eightBitStoreIntoGBMemory(0xff49, 0xff);\n        // 0xFF4A -> 0xFF4B = 0x00\n        // GBC VRAM Banks (Handled by Memory, initializeCartridge)\n    }\n    // Scanline\n    // Bgb says LY is 90 on boot\n    Graphics.scanlineRegister = 0x90;\n    // LCDC register\n    eightBitStoreIntoGBMemory(0xff40, 0x91);\n    // GBC VRAM Banks\n    eightBitStoreIntoGBMemory(0xff4f, 0x00);\n    eightBitStoreIntoGBMemory(0xff70, 0x01);\n    // Override/reset some variables if the boot ROM is enabled\n    if (Cpu.BootROMEnabled) {\n        if (Cpu.GBCEnabled) {\n            // GBC\n            Graphics.scanlineRegister = 0x00;\n            eightBitStoreIntoGBMemory(0xff40, 0x00);\n            eightBitStoreIntoGBMemory(0xff41, 0x80);\n            eightBitStoreIntoGBMemory(0xff44, 0x00);\n        }\n        else {\n            // GB\n            Graphics.scanlineRegister = 0x00;\n            eightBitStoreIntoGBMemory(0xff40, 0x00);\n            eightBitStoreIntoGBMemory(0xff41, 0x84);\n        }\n    }\n    initializeColors();\n}\nfunction updateGraphics(numberOfCycles) {\n    if (Lcd.enabled) {\n        Graphics.scanlineCycleCounter += numberOfCycles;\n        var graphicsDisableScanlineRendering = Config.graphicsDisableScanlineRendering;\n        while (Graphics.scanlineCycleCounter >= Graphics.MAX_CYCLES_PER_SCANLINE()) {\n            // Reset the scanlineCycleCounter\n            // Don't set to zero to catch extra cycles\n            Graphics.scanlineCycleCounter -= Graphics.MAX_CYCLES_PER_SCANLINE();\n            // Move to next scanline\n            // let scanlineRegister: i32 = eightBitLoadFromGBMemory(Graphics.memoryLocationScanlineRegister);\n            var scanlineRegister = Graphics.scanlineRegister;\n            // Check if we've reached the last scanline\n            if (scanlineRegister === 144) {\n                // Draw the scanline\n                if (!graphicsDisableScanlineRendering) {\n                    _drawScanline(scanlineRegister);\n                }\n                else {\n                    _renderEntireFrame();\n                }\n                // Clear the priority map\n                clearPriorityMap();\n                // Reset the tile cache\n                resetTileCache();\n            }\n            else if (scanlineRegister < 144) {\n                // Draw the scanline\n                if (!graphicsDisableScanlineRendering) {\n                    _drawScanline(scanlineRegister);\n                }\n            }\n            // Post increment the scanline register after drawing\n            // TODO: Need to fix graphics timing\n            if (scanlineRegister > 153) {\n                // Check if we overflowed scanlines\n                // if so, reset our scanline number\n                scanlineRegister = 0;\n            }\n            else {\n                scanlineRegister += 1;\n            }\n            // Store our new scanline value\n            Graphics.scanlineRegister = scanlineRegister;\n            // eightBitStoreIntoGBMemory(Graphics.memoryLocationScanlineRegister, scanlineRegister);\n        }\n    }\n    // Games like Pokemon crystal want the vblank right as it turns to the value, and not have it increment after\n    // It will break and lead to an infinite loop in crystal\n    // Therefore, we want to be checking/Setting our LCD status after the scanline updates\n    setLcdStatus();\n}\n// TODO: Make this a _drawPixelOnScanline, as values can be updated while drawing a scanline\nfunction _drawScanline(scanlineRegister) {\n    // Get our seleted tile data memory location\n    var tileDataMemoryLocation = Graphics.memoryLocationTileDataSelectZeroStart;\n    if (Lcd.bgWindowTileDataSelect) {\n        tileDataMemoryLocation = Graphics.memoryLocationTileDataSelectOneStart;\n    }\n    // Check if the background is enabled\n    // NOTE: On Gameboy color, Pandocs says this does something completely different\n    // LCDC.0 - 2) CGB in CGB Mode: BG and Window Master Priority\n    // When Bit 0 is cleared, the background and window lose their priority -\n    // the sprites will be always displayed on top of background and window,\n    // independently of the priority flags in OAM and BG Map attributes.\n    // TODO: Enable this different feature for GBC\n    if (Cpu.GBCEnabled || Lcd.bgDisplayEnabled) {\n        // Get our map memory location\n        var tileMapMemoryLocation = Graphics.memoryLocationTileMapSelectZeroStart;\n        if (Lcd.bgTileMapDisplaySelect) {\n            tileMapMemoryLocation = Graphics.memoryLocationTileMapSelectOneStart;\n        }\n        // Finally, pass everything to draw the background\n        renderBackground(scanlineRegister, tileDataMemoryLocation, tileMapMemoryLocation);\n    }\n    // Check if the window is enabled, and we are currently\n    // Drawing lines on the window\n    if (Lcd.windowDisplayEnabled) {\n        // Get our map memory location\n        var tileMapMemoryLocation = Graphics.memoryLocationTileMapSelectZeroStart;\n        if (Lcd.windowTileMapDisplaySelect) {\n            tileMapMemoryLocation = Graphics.memoryLocationTileMapSelectOneStart;\n        }\n        // Finally, pass everything to draw the background\n        renderWindow(scanlineRegister, tileDataMemoryLocation, tileMapMemoryLocation);\n    }\n    if (Lcd.spriteDisplayEnable) {\n        // Sprites are enabled, render them!\n        renderSprites(scanlineRegister, Lcd.tallSpriteSize);\n    }\n}\n// Function to render everything for a frame at once\n// This is to improve performance\n// See above for comments on how things are donw\nfunction _renderEntireFrame() {\n    // Scanline needs to be in sync while we draw, thus, we can't shortcut anymore than here\n    for (var i = 0; i <= 144; ++i) {\n        _drawScanline(i);\n    }\n}\n// Function to get the start of a RGB pixel (R, G, B)\n// Inlined because closure compiler inlines\nfunction getRgbPixelStart(x, y) {\n    // Get the pixel number\n    // let pixelNumber: i32 = (y * 160) + x;\n    // Each pixel takes 3 slots, therefore, multiply by 3!\n    return (y * 160 + x) * 3;\n}\n// Also need to store current frame in memory to be read by JS\nfunction setPixelOnFrame(x, y, colorId, color) {\n    // Currently only supports 160x144\n    // Storing in X, then y\n    // So need an offset\n    store(FRAME_LOCATION + getRgbPixelStart(x, y) + colorId, color);\n}\n// Function to shortcut the memory map, and load directly from the VRAM Bank\nfunction loadFromVramBank(gameboyOffset, vramBankId) {\n    var wasmBoyAddress = gameboyOffset - Memory.videoRamLocation + GAMEBOY_INTERNAL_MEMORY_LOCATION + 0x2000 * (vramBankId & 0x01);\n    return load(wasmBoyAddress);\n}\n\n// Returns -1 if no trap found, otherwise returns a value that should be fed for the address\nfunction checkReadTraps(offset) {\n    // Cache globals used multiple times for performance\n    var videoRamLocation = Memory.videoRamLocation;\n    // Try to break early for most common scenario\n    if (offset < videoRamLocation) {\n        return -1;\n    }\n    // Check the graphics mode to see if we can read VRAM\n    // http://gbdev.gg8.se/wiki/articles/Video_Display#Accessing_VRAM_and_OAM\n    if (offset >= videoRamLocation && offset < Memory.cartridgeRamLocation) {\n        // Can only read/write from VRAM During Modes 0 - 2\n        // See graphics/lcd.ts\n        // TODO: This can do more harm than good in a beta emulator,\n        // requres precise timing, disabling for now\n        // if (Graphics.currentLcdMode > 2) {\n        //   return 0xFF;\n        // }\n        return -1;\n    }\n    // ECHO Ram, E000\tFDFF\tMirror of C000~DDFF (ECHO RAM)\n    // http://gbdev.gg8.se/wiki/articles/Memory_Map\n    if (offset >= Memory.echoRamLocation && offset < Memory.spriteInformationTableLocation) {\n        // Simply return the mirror'd value\n        return eightBitLoadFromGBMemory(offset - 0x2000);\n    }\n    // Check for individal writes\n    // Can only read/write from OAM During Modes 0 - 1\n    // See graphics/lcd.ts\n    if (offset >= Memory.spriteInformationTableLocation && offset <= Memory.spriteInformationTableLocationEnd) {\n        // Can only read/write from OAM During Mode 2\n        // See graphics/lcd.ts\n        // if (Lcd.currentLcdMode < 2) {\n        // return 0xff;\n        // }\n        // Not batch processing here for performance\n        // batchProcessGraphics();\n        // return -1;\n        return Lcd.currentLcdMode < 2 ? 0xff : -1;\n    }\n    // CPU\n    if (offset === Cpu.memoryLocationSpeedSwitch) {\n        // TCAGBD, only Bit 7 and 0 are readable, all others are 1\n        var response = 0xff;\n        var currentSpeedSwitchRegister = eightBitLoadFromGBMemory(Cpu.memoryLocationSpeedSwitch);\n        if (!checkBitOnByte(0, currentSpeedSwitchRegister)) {\n            response = resetBitOnByte(0, response);\n        }\n        if (!Cpu.GBCDoubleSpeed) {\n            response = resetBitOnByte(7, response);\n        }\n        return response;\n    }\n    // Graphics\n    // Not batch processing here for performance\n    // batchProcessGraphics();\n    if (offset === Graphics.memoryLocationScanlineRegister) {\n        eightBitStoreIntoGBMemory(offset, Graphics.scanlineRegister);\n        return Graphics.scanlineRegister;\n    }\n    // Sound\n    // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Registers\n    // TODO: Put these bounds on the Sound Class\n    if (offset >= 0xff10 && offset <= 0xff26) {\n        batchProcessAudio();\n        return SoundRegisterReadTraps(offset);\n    }\n    // FF27 - FF2F not used\n    // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Register_Reading\n    // Always read as 0xFF\n    if (offset >= 0xff27 && offset <= 0xff2f) {\n        return 0xff;\n    }\n    // Final Wave Table for Channel 3\n    if (offset >= 0xff30 && offset <= 0xff3f) {\n        batchProcessAudio();\n        if (Channel3.isEnabled) {\n            return Channel3.handleWaveRamRead();\n        }\n        return -1;\n    }\n    // Timers\n    if (offset === Timers.memoryLocationDividerRegister) {\n        // Divider register in memory is just the upper 8 bits\n        // http://gbdev.gg8.se/wiki/articles/Timer_Obscure_Behaviour\n        var upperDividerRegisterBits = splitHighByte(Timers.dividerRegister);\n        eightBitStoreIntoGBMemory(offset, upperDividerRegisterBits);\n        return upperDividerRegisterBits;\n    }\n    if (offset === Timers.memoryLocationTimerCounter) {\n        eightBitStoreIntoGBMemory(offset, Timers.timerCounter);\n        return Timers.timerCounter;\n    }\n    // Interrupts\n    if (offset === Interrupts.memoryLocationInterruptRequest) {\n        // TCAGB and BGB say the top 5 bits are always 1.\n        return 0xe0 | Interrupts.interruptsRequestedValue;\n    }\n    // Joypad\n    if (offset === Joypad.memoryLocationJoypadRegister) {\n        return getJoypadState();\n    }\n    return -1;\n}\n\n// Load/Read functionality for memory\nfunction eightBitLoadFromGBMemory(gameboyOffset) {\n    return load(getWasmBoyOffsetFromGameBoyOffset(gameboyOffset));\n}\nfunction eightBitLoadFromGBMemoryWithTraps(offset) {\n    if (offset === Breakpoints.readGbMemory) {\n        Breakpoints.reachedBreakpoint = true;\n    }\n    var readTrapResult = checkReadTraps(offset);\n    return readTrapResult === -1 ? eightBitLoadFromGBMemory(offset) : readTrapResult;\n}\n// TODO: Rename this to sixteenBitLoadFromGBMemoryWithTraps\n// Inlined because closure compiler inlines\nfunction sixteenBitLoadFromGBMemory(offset) {\n    // Get our low byte\n    var lowByteReadTrapResult = checkReadTraps(offset);\n    var lowByte = lowByteReadTrapResult === -1 ? eightBitLoadFromGBMemory(offset) : lowByteReadTrapResult;\n    // Get the next offset for the second byte\n    var nextOffset = offset + 1;\n    // Get our high byte\n    var highByteReadTrapResult = checkReadTraps(nextOffset);\n    var highByte = highByteReadTrapResult === -1 ? eightBitLoadFromGBMemory(nextOffset) : highByteReadTrapResult;\n    // Concatenate the bytes and return\n    return concatenateBytes(highByte, lowByte);\n}\nfunction loadBooleanDirectlyFromWasmMemory(offset) {\n    return load(offset) > 0;\n}\n\n// WasmBoy memory map:\nvar Memory = /** @class */ (function () {\n    function Memory() {\n    }\n    // Function to save the state of the class\n    Memory.saveState = function () {\n        store(getSaveStateMemoryOffset(0x00, Memory.saveStateSlot), Memory.currentRomBank);\n        store(getSaveStateMemoryOffset(0x02, Memory.saveStateSlot), Memory.currentRamBank);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x04, Memory.saveStateSlot), Memory.isRamBankingEnabled);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x05, Memory.saveStateSlot), Memory.isMBC1RomModeEnabled);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x06, Memory.saveStateSlot), Memory.isRomOnly);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x07, Memory.saveStateSlot), Memory.isMBC1);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x08, Memory.saveStateSlot), Memory.isMBC2);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x09, Memory.saveStateSlot), Memory.isMBC3);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0a, Memory.saveStateSlot), Memory.isMBC5);\n        store(getSaveStateMemoryOffset(0x0b, Memory.saveStateSlot), Memory.DMACycles);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0f, Memory.saveStateSlot), Memory.isHblankHdmaActive);\n        store(getSaveStateMemoryOffset(0x10, Memory.saveStateSlot), Memory.hblankHdmaTransferLengthRemaining);\n        store(getSaveStateMemoryOffset(0x14, Memory.saveStateSlot), Memory.hblankHdmaSource);\n        store(getSaveStateMemoryOffset(0x18, Memory.saveStateSlot), Memory.hblankHdmaDestination);\n    };\n    // Function to load the save state from memory\n    Memory.loadState = function () {\n        Memory.currentRomBank = load(getSaveStateMemoryOffset(0x00, Memory.saveStateSlot));\n        Memory.currentRamBank = load(getSaveStateMemoryOffset(0x02, Memory.saveStateSlot));\n        Memory.isRamBankingEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x04, Memory.saveStateSlot));\n        Memory.isMBC1RomModeEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x05, Memory.saveStateSlot));\n        Memory.isRomOnly = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x06, Memory.saveStateSlot));\n        Memory.isMBC1 = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x07, Memory.saveStateSlot));\n        Memory.isMBC2 = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x08, Memory.saveStateSlot));\n        Memory.isMBC3 = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x09, Memory.saveStateSlot));\n        Memory.isMBC5 = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0a, Memory.saveStateSlot));\n        Memory.DMACycles = load(getSaveStateMemoryOffset(0x0b, Memory.saveStateSlot));\n        Memory.isHblankHdmaActive = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0f, Memory.saveStateSlot));\n        Memory.hblankHdmaTransferLengthRemaining = load(getSaveStateMemoryOffset(0x10, Memory.saveStateSlot));\n        Memory.hblankHdmaSource = load(getSaveStateMemoryOffset(0x14, Memory.saveStateSlot));\n        Memory.hblankHdmaDestination = load(getSaveStateMemoryOffset(0x18, Memory.saveStateSlot));\n    };\n    // ----------------------------------\n    // Gameboy Memory Map\n    // ----------------------------------\n    // https://github.com/AntonioND/giibiiadvance/blob/master/docs/TCAGBD.pdf\n    // http://gameboy.mongenel.com/dmg/asmmemmap.html\n    // using Arrays, first index is start, second is end\n    Memory.cartridgeRomLocation = 0x0000;\n    Memory.switchableCartridgeRomLocation = 0x4000;\n    Memory.videoRamLocation = 0x8000;\n    Memory.cartridgeRamLocation = 0xa000;\n    Memory.internalRamBankZeroLocation = 0xc000;\n    // This ram bank is switchable\n    Memory.internalRamBankOneLocation = 0xd000;\n    Memory.echoRamLocation = 0xe000;\n    Memory.spriteInformationTableLocation = 0xfe00;\n    Memory.spriteInformationTableLocationEnd = 0xfe9f;\n    Memory.unusableMemoryLocation = 0xfea0;\n    Memory.unusableMemoryEndLocation = 0xfeff;\n    // Hardware I/O, 0xFF00 -> 0xFF7F\n    // Zero Page, 0xFF80 -> 0xFFFE\n    // Intterupt Enable Flag, 0xFFFF\n    // ----------------------------------\n    // Rom/Ram Banking\n    // ----------------------------------\n    // http://gbdev.gg8.se/wiki/articles/Memory_Bank_Controllers#MBC3_.28max_2MByte_ROM_and.2For_32KByte_RAM_and_Timer.29\n    // http://www.codeslinger.co.uk/pages/projects/gameboy/banking.html\n    Memory.currentRomBank = 0x00;\n    Memory.currentRamBank = 0x00;\n    Memory.isRamBankingEnabled = false;\n    Memory.isMBC1RomModeEnabled = true;\n    // Cartridge Types\n    // http://gbdev.gg8.se/wiki/articles/The_Cartridge_Header\n    Memory.isRomOnly = true;\n    Memory.isMBC1 = false;\n    Memory.isMBC2 = false;\n    Memory.isMBC3 = false;\n    Memory.isMBC5 = false;\n    // DMA\n    Memory.memoryLocationHdmaSourceHigh = 0xff51;\n    Memory.memoryLocationHdmaSourceLow = 0xff52;\n    Memory.memoryLocationHdmaDestinationHigh = 0xff53;\n    Memory.memoryLocationHdmaDestinationLow = 0xff54;\n    Memory.memoryLocationHdmaTrigger = 0xff55;\n    // Cycles accumulated for DMA\n    Memory.DMACycles = 0;\n    // Boolean we will mirror to indicate if Hdma is active\n    Memory.isHblankHdmaActive = false;\n    Memory.hblankHdmaTransferLengthRemaining = 0x00;\n    // Store the source and destination for performance, and update as needed\n    Memory.hblankHdmaSource = 0x00;\n    Memory.hblankHdmaDestination = 0x00;\n    // GBC Registers\n    Memory.memoryLocationGBCVRAMBank = 0xff4f;\n    Memory.memoryLocationGBCWRAMBank = 0xff70;\n    // Save States\n    Memory.saveStateSlot = 4;\n    return Memory;\n}());\n// Inlined because closure compiler inlines\nfunction initializeCartridge() {\n    // Reset stateful variables\n    Memory.isRamBankingEnabled = false;\n    Memory.isMBC1RomModeEnabled = true;\n    // Get our game MBC type from the cartridge header\n    // http://gbdev.gg8.se/wiki/articles/The_Cartridge_Header\n    var cartridgeType = eightBitLoadFromGBMemory(0x0147);\n    // Reset our Cartridge types\n    Memory.isRomOnly = cartridgeType === 0x00;\n    Memory.isMBC1 = cartridgeType >= 0x01 && cartridgeType <= 0x03;\n    Memory.isMBC2 = cartridgeType >= 0x05 && cartridgeType <= 0x06;\n    Memory.isMBC3 = cartridgeType >= 0x0f && cartridgeType <= 0x13;\n    Memory.isMBC5 = cartridgeType >= 0x19 && cartridgeType <= 0x1e;\n    Memory.currentRomBank = 0x01;\n    Memory.currentRamBank = 0x00;\n    // Set our GBC Banks\n    eightBitStoreIntoGBMemory(Memory.memoryLocationGBCVRAMBank, 0x00);\n    eightBitStoreIntoGBMemory(Memory.memoryLocationGBCWRAMBank, 0x01);\n}\n\n// WasmBoy memory map:\n\n// Everything Static as class instances just aren't quite there yet\n// https://github.com/AssemblyScript/assemblyscript/blob/master/tests/compiler/showcase.ts\nvar Cpu = /** @class */ (function () {\n    function Cpu() {\n    }\n    Cpu.CLOCK_SPEED = function () {\n        // 2^23, thanks binji!\n        // return Cpu.GBCDoubleSpeed ? 8388608 : 4194304;\n        return 4194304 << Cpu.GBCDoubleSpeed;\n    };\n    // Cycles Per Frame = Clock Speed / fps\n    // So: 4194304 / 59.73\n    Cpu.MAX_CYCLES_PER_FRAME = function () {\n        // return Cpu.GBCDoubleSpeed ? 140448 : 70224;\n        return 70224 << Cpu.GBCDoubleSpeed;\n    };\n    // See section 4.10 of TCAGBD\n    // Cpu Halting explained: https://www.reddit.com/r/EmuDev/comments/5ie3k7/infinite_loop_trying_to_pass_blarggs_interrupt/db7xnbe/\n    Cpu.enableHalt = function () {\n        if (Interrupts.masterInterruptSwitch) {\n            Cpu.isHaltNormal = true;\n            return;\n        }\n        var haltTypeValue = Interrupts.interruptsEnabledValue & Interrupts.interruptsRequestedValue & 0x1f;\n        if (haltTypeValue === 0) {\n            Cpu.isHaltNoJump = true;\n            return;\n        }\n        Cpu.isHaltBug = true;\n    };\n    Cpu.exitHaltAndStop = function () {\n        Cpu.isHaltNoJump = false;\n        Cpu.isHaltNormal = false;\n        Cpu.isHaltBug = false;\n        Cpu.isStopped = false;\n    };\n    Cpu.isHalted = function () {\n        return Cpu.isHaltNormal || Cpu.isHaltNoJump;\n    };\n    // Function to save the state of the class\n    Cpu.saveState = function () {\n        // Registers\n        store(getSaveStateMemoryOffset(0x00, Cpu.saveStateSlot), Cpu.registerA);\n        store(getSaveStateMemoryOffset(0x01, Cpu.saveStateSlot), Cpu.registerB);\n        store(getSaveStateMemoryOffset(0x02, Cpu.saveStateSlot), Cpu.registerC);\n        store(getSaveStateMemoryOffset(0x03, Cpu.saveStateSlot), Cpu.registerD);\n        store(getSaveStateMemoryOffset(0x04, Cpu.saveStateSlot), Cpu.registerE);\n        store(getSaveStateMemoryOffset(0x05, Cpu.saveStateSlot), Cpu.registerH);\n        store(getSaveStateMemoryOffset(0x06, Cpu.saveStateSlot), Cpu.registerL);\n        store(getSaveStateMemoryOffset(0x07, Cpu.saveStateSlot), Cpu.registerF);\n        store(getSaveStateMemoryOffset(0x08, Cpu.saveStateSlot), Cpu.stackPointer);\n        store(getSaveStateMemoryOffset(0x0a, Cpu.saveStateSlot), Cpu.programCounter);\n        store(getSaveStateMemoryOffset(0x0c, Cpu.saveStateSlot), Cpu.currentCycles);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x11, Cpu.saveStateSlot), Cpu.isHaltNormal);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x12, Cpu.saveStateSlot), Cpu.isHaltNoJump);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x13, Cpu.saveStateSlot), Cpu.isHaltBug);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x14, Cpu.saveStateSlot), Cpu.isStopped);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x15, Cpu.saveStateSlot), Cpu.BootROMEnabled);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x16, Cpu.saveStateSlot), Cpu.GBCEnabled);\n        storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x17, Cpu.saveStateSlot), Cpu.GBCDoubleSpeed);\n    };\n    // Function to load the save state from memory\n    Cpu.loadState = function () {\n        // Registers\n        Cpu.registerA = load(getSaveStateMemoryOffset(0x00, Cpu.saveStateSlot));\n        Cpu.registerB = load(getSaveStateMemoryOffset(0x01, Cpu.saveStateSlot));\n        Cpu.registerC = load(getSaveStateMemoryOffset(0x02, Cpu.saveStateSlot));\n        Cpu.registerD = load(getSaveStateMemoryOffset(0x03, Cpu.saveStateSlot));\n        Cpu.registerE = load(getSaveStateMemoryOffset(0x04, Cpu.saveStateSlot));\n        Cpu.registerH = load(getSaveStateMemoryOffset(0x05, Cpu.saveStateSlot));\n        Cpu.registerL = load(getSaveStateMemoryOffset(0x06, Cpu.saveStateSlot));\n        Cpu.registerF = load(getSaveStateMemoryOffset(0x07, Cpu.saveStateSlot));\n        Cpu.stackPointer = load(getSaveStateMemoryOffset(0x08, Cpu.saveStateSlot));\n        Cpu.programCounter = load(getSaveStateMemoryOffset(0x0a, Cpu.saveStateSlot));\n        Cpu.currentCycles = load(getSaveStateMemoryOffset(0x0c, Cpu.saveStateSlot));\n        Cpu.isHaltNormal = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x11, Cpu.saveStateSlot));\n        Cpu.isHaltNoJump = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x12, Cpu.saveStateSlot));\n        Cpu.isHaltBug = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x13, Cpu.saveStateSlot));\n        Cpu.isStopped = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x14, Cpu.saveStateSlot));\n        Cpu.BootROMEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x15, Cpu.saveStateSlot));\n        Cpu.GBCEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x16, Cpu.saveStateSlot));\n        Cpu.GBCDoubleSpeed = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x17, Cpu.saveStateSlot));\n    };\n    // Status to track if we are currently executing the boot rom\n    Cpu.memoryLocationBootROMSwitch = 0xff50;\n    Cpu.BootROMEnabled = false;\n    // Status to track if we are in Gameboy Color Mode, and GBC State\n    Cpu.GBCEnabled = false;\n    // Memory Location for the GBC Speed switch\n    // And the current status\n    Cpu.memoryLocationSpeedSwitch = 0xff4d;\n    Cpu.GBCDoubleSpeed = false;\n    // 8-bit Cpu.registers\n    Cpu.registerA = 0;\n    Cpu.registerB = 0;\n    Cpu.registerC = 0;\n    Cpu.registerD = 0;\n    Cpu.registerE = 0;\n    Cpu.registerH = 0;\n    Cpu.registerL = 0;\n    Cpu.registerF = 0;\n    // 16-bit Cpu.registers\n    Cpu.stackPointer = 0;\n    // Boot rom from 0x00 to 0x99, all games start at 0x100\n    Cpu.programCounter = 0x00;\n    // Current number of cycles, shouldn't execeed max number of cycles\n    Cpu.currentCycles = 0;\n    // HALT and STOP instructions need to stop running opcodes, but simply check timers\n    // https://github.com/nakardo/node-gameboy/blob/master/lib/cpu/opcodes.js\n    // Matt said is should work to, so it must work!\n    // TCAGBD shows three different HALT states. Therefore, we need to handle each\n    Cpu.isHaltNormal = false;\n    Cpu.isHaltNoJump = false;\n    Cpu.isHaltBug = false;\n    Cpu.isStopped = false;\n    // Save States\n    Cpu.saveStateSlot = 0;\n    return Cpu;\n}());\n// Inlined because closure compiler does so\nfunction initializeCpu() {\n    // Reset all stateful Cpu variables\n    // Cpu.GBCEnabled is done by core/initialize\n    Cpu.GBCDoubleSpeed = false;\n    Cpu.registerA = 0;\n    Cpu.registerB = 0;\n    Cpu.registerC = 0;\n    Cpu.registerD = 0;\n    Cpu.registerE = 0;\n    Cpu.registerH = 0;\n    Cpu.registerL = 0;\n    Cpu.registerF = 0;\n    Cpu.stackPointer = 0;\n    Cpu.programCounter = 0x00;\n    Cpu.currentCycles = 0;\n    Cpu.isHaltNormal = false;\n    Cpu.isHaltNoJump = false;\n    Cpu.isHaltBug = false;\n    Cpu.isStopped = false;\n    // Everything is done by Boot ROM is enabled.\n    if (Cpu.BootROMEnabled) {\n        return;\n    }\n    if (Cpu.GBCEnabled) {\n        // CPU Registers\n        Cpu.registerA = 0x11;\n        Cpu.registerF = 0x80;\n        Cpu.registerB = 0x00;\n        Cpu.registerC = 0x00;\n        Cpu.registerD = 0xff;\n        Cpu.registerE = 0x56;\n        Cpu.registerH = 0x00;\n        Cpu.registerL = 0x0d;\n    }\n    else {\n        // Cpu Registers\n        Cpu.registerA = 0x01;\n        Cpu.registerF = 0xb0;\n        Cpu.registerB = 0x00;\n        Cpu.registerC = 0x13;\n        Cpu.registerD = 0x00;\n        Cpu.registerE = 0xd8;\n        Cpu.registerH = 0x01;\n        Cpu.registerL = 0x4d;\n    }\n    // Cpu Control Flow\n    Cpu.programCounter = 0x100;\n    Cpu.stackPointer = 0xfffe;\n}\n\n// Imports\n// General Logic Instructions\n// Such as the ones found on the CB table and 0x40 - 0xBF\n// NOTE: Only CB table uses these for now, was mostly me realizing that I messed up, trying to be all cute and verbose :p\n// NOTE: TODO: Refactor honestly shouldn't take that long, and may happen once assembly script is improved\nfunction addARegister(register) {\n    var registerA = Cpu.registerA;\n    checkAndSetEightBitHalfCarryFlag(registerA, register);\n    checkAndSetEightBitCarryFlag(registerA, register);\n    registerA = u8Portable(registerA + register);\n    Cpu.registerA = registerA;\n    setZeroFlag$$1((registerA === 0));\n    setSubtractFlag(0);\n}\nfunction addAThroughCarryRegister(register) {\n    // Handling flags manually as they require some special overflow\n    // From: https://github.com/nakardo/node-gameboy/blob/master/lib/cpu/opcodes.js\n    // CTRL+F adc\n    var registerA = Cpu.registerA;\n    var result = u8Portable(registerA + register + getCarryFlag$$1());\n    setHalfCarryFlag(((u8Portable(registerA ^ register ^ result) & 0x10) != 0));\n    var overflowedResult = u16Portable(registerA + register + getCarryFlag$$1());\n    setCarryFlag(((overflowedResult & 0x100) > 0));\n    Cpu.registerA = result;\n    setZeroFlag$$1((result === 0));\n    setSubtractFlag(0);\n}\nfunction subARegister(register) {\n    // Need to convert the register on one line, and flip the sign on another\n    var negativeRegister = register;\n    negativeRegister = negativeRegister * -1;\n    var registerA = Cpu.registerA;\n    checkAndSetEightBitHalfCarryFlag(registerA, negativeRegister);\n    checkAndSetEightBitCarryFlag(registerA, negativeRegister);\n    registerA = u8Portable(registerA - register);\n    Cpu.registerA = registerA;\n    setZeroFlag$$1((registerA === 0));\n    setSubtractFlag(1);\n}\nfunction subAThroughCarryRegister(register) {\n    // Handling flags manually as they require some special overflow\n    // From: https://github.com/nakardo/node-gameboy/blob/master/lib/cpu/opcodes.js\n    // CTRL+F adc\n    var registerA = Cpu.registerA;\n    var result = u8Portable(registerA - register - getCarryFlag$$1());\n    var carryRegisterCheck = u8Portable((registerA ^ register ^ result) & 0x10);\n    setHalfCarryFlag((carryRegisterCheck != 0));\n    var overflowedResult = u16Portable(registerA - register - getCarryFlag$$1());\n    setCarryFlag(((overflowedResult & 0x100) > 0));\n    Cpu.registerA = result;\n    setZeroFlag$$1((result === 0));\n    setSubtractFlag(1);\n}\nfunction andARegister(register) {\n    var registerA = Cpu.registerA & register;\n    Cpu.registerA = registerA;\n    setZeroFlag$$1((registerA === 0));\n    setSubtractFlag(0);\n    setHalfCarryFlag(1);\n    setCarryFlag(0);\n}\nfunction xorARegister(register) {\n    var registerA = u8Portable(Cpu.registerA ^ register);\n    Cpu.registerA = registerA;\n    setZeroFlag$$1((registerA === 0));\n    setSubtractFlag(0);\n    setHalfCarryFlag(0);\n    setCarryFlag(0);\n}\nfunction orARegister(register) {\n    var registerA = Cpu.registerA | register;\n    Cpu.registerA = registerA;\n    setZeroFlag$$1((registerA === 0));\n    setSubtractFlag(0);\n    setHalfCarryFlag(0);\n    setCarryFlag(0);\n}\nfunction cpARegister(register) {\n    // 0xB8 - 0xBF\n    // CP B\n    // 1  4\n    // Z 1 H C\n    var registerA = Cpu.registerA;\n    var negativeRegister = register;\n    negativeRegister = negativeRegister * -1;\n    checkAndSetEightBitHalfCarryFlag(registerA, negativeRegister);\n    checkAndSetEightBitCarryFlag(registerA, negativeRegister);\n    var tempResult = registerA + negativeRegister;\n    setZeroFlag$$1((tempResult === 0));\n    setSubtractFlag(1);\n}\n// Inlined because closure compiler inlines\nfunction rotateRegisterLeft(register) {\n    // RLC register 8-bit\n    // Z 0 0 C\n    setCarryFlag(((register & 0x80) === 0x80));\n    register = rotateByteLeft(register);\n    setZeroFlag$$1((register === 0));\n    // Set all other flags to zero\n    setSubtractFlag(0);\n    setHalfCarryFlag(0);\n    // Return the register\n    return register;\n}\n// Inlined because closure compiler inlines\nfunction rotateRegisterRight(register) {\n    // RLC register 8-bit\n    // Z 0 0 C\n    // Check for the last bit, to see if it will be carried\n    setCarryFlag(((register & 0x01) > 0));\n    register = rotateByteRight(register);\n    setZeroFlag$$1((register === 0));\n    setSubtractFlag(0);\n    setHalfCarryFlag(0);\n    // Return the register\n    return register;\n}\n// Inlined because closure compiler inlines\nfunction rotateRegisterLeftThroughCarry(register) {\n    // RL register 8-bit\n    // Z 0 0 C\n    // setting has first bit since we need to use carry\n    var hasHighbit = (register & 0x80) === 0x80;\n    register = rotateByteLeftThroughCarry(register);\n    setCarryFlag(hasHighbit);\n    setZeroFlag$$1((register === 0));\n    setSubtractFlag(0);\n    setHalfCarryFlag(0);\n    return register;\n}\n// Inlined because closure compiler inlines\nfunction rotateRegisterRightThroughCarry(register) {\n    // RR register 8-bit\n    // Z 0 0 C\n    var hasLowBit = (register & 0x01) === 0x01;\n    register = rotateByteRightThroughCarry(register);\n    setCarryFlag(hasLowBit);\n    setZeroFlag$$1((register === 0));\n    setSubtractFlag(0);\n    setHalfCarryFlag(0);\n    return register;\n}\n// Inlined because closure compiler inlines\nfunction shiftLeftRegister(register) {\n    // SLA register 8-bit\n    // Z 0 0 C\n    var hasHighbit = (register & 0x80) === 0x80;\n    register = u8Portable(register << 1);\n    setCarryFlag(hasHighbit);\n    setZeroFlag$$1((register === 0));\n    setSubtractFlag(0);\n    setHalfCarryFlag(0);\n    return register;\n}\n// Inlined because closure compiler inlines\nfunction shiftRightArithmeticRegister(register) {\n    // SRA register 8-bit\n    // Z 0 0 C\n    // NOTE: This C flag may need to be set to 0;\n    // This preserves the MSB (Most significant bit)\n    var hasHighbit = (register & 0x80) === 0x80;\n    var hasLowbit = (register & 0x01) === 0x01;\n    register = u8Portable(register >> 1);\n    if (hasHighbit) {\n        register = register | 0x80;\n    }\n    setZeroFlag$$1((register === 0));\n    setSubtractFlag(0);\n    setHalfCarryFlag(0);\n    setCarryFlag(hasLowbit);\n    return register;\n}\n// Inlined because closure compiler inlines\nfunction swapNibblesOnRegister(register) {\n    // SWAP register 8-bit\n    // Z 0 0 0\n    var highNibble = register & 0xf0;\n    var lowNibble = register & 0x0f;\n    register = u8Portable((lowNibble << 4) | (highNibble >> 4));\n    setZeroFlag$$1((register === 0));\n    setSubtractFlag(0);\n    setHalfCarryFlag(0);\n    setCarryFlag(0);\n    return register;\n}\n// Inlined because closure compiler inlines\nfunction shiftRightLogicalRegister(register) {\n    // SRA register 8-bit\n    // Z 0 0 C\n    // NOTE: This C flag may need to be set to 0;\n    // This does NOT preserve MSB (most significant bit)\n    var hasLowbit = (register & 0x01) === 0x01;\n    register = u8Portable(register >> 1);\n    setZeroFlag$$1((register === 0));\n    setSubtractFlag(0);\n    setHalfCarryFlag(0);\n    setCarryFlag(hasLowbit);\n    return register;\n}\nfunction testBitOnRegister(bitPosition, register) {\n    // BIT bitPosition ,register 8-bit\n    // Z 0 1 -\n    var testByte = 0x01 << bitPosition;\n    var result = register & testByte;\n    setZeroFlag$$1((result === 0x00));\n    setSubtractFlag(0);\n    setHalfCarryFlag(1);\n    return register;\n}\nfunction setBitOnRegister(bitPosition, bitValue, register) {\n    // RES 0,B or SET 0,B depending on bit value\n    if (bitValue > 0) {\n        var setByte = 0x01 << bitPosition;\n        register = register | setByte;\n    }\n    else {\n        // NOT (byte we want)\n        // 0000 0100 becomes 1111 1011\n        var setByte = ~(0x01 << bitPosition);\n        register = register & setByte;\n    }\n    return register;\n}\n// Private function for our relative jumps\nfunction relativeJump(value) {\n    // Need to convert the value to i8, since in this case, u8 can be negative\n    var relativeJumpOffset = i8Portable(value);\n    var programCounter = Cpu.programCounter;\n    programCounter = u16Portable(programCounter + relativeJumpOffset);\n    // Realtive jump, using bgb debugger\n    // and my debugger shows,\n    // on JR you need to jump to the relative jump offset,\n    // However, if the jump fails (such as conditional), only jump +2 in total\n    programCounter = u16Portable(programCounter + 1);\n    Cpu.programCounter = programCounter;\n}\n\n// Imports\n// Handle CB Opcodes\n// NOTE: Program stpes and cycles are standardized depending on the register type\n// NOTE: Doing some funny stuff to get around not having arrays or objects\n// Inlined because closure compiler inlines.\nfunction handleCbOpcode(cbOpcode) {\n    var numberOfCycles = -1;\n    var handledOpcode = false;\n    // The result of our cb logic instruction\n    var instructionRegisterValue = 0;\n    var instructionRegisterResult = 0;\n    // Get our register number by modulo 0x08 (number of registers)\n    // cbOpcode % 0x08\n    var registerNumber = cbOpcode & 0x07;\n    // NOTE: registerNumber = register on CB table. Cpu.registerB = 0, Cpu.registerC = 1....Cpu.registerA = 7\n    switch (registerNumber) {\n        case 0:\n            instructionRegisterValue = Cpu.registerB;\n            break;\n        case 1:\n            instructionRegisterValue = Cpu.registerC;\n            break;\n        case 2:\n            instructionRegisterValue = Cpu.registerD;\n            break;\n        case 3:\n            instructionRegisterValue = Cpu.registerE;\n            break;\n        case 4:\n            instructionRegisterValue = Cpu.registerH;\n            break;\n        case 5:\n            instructionRegisterValue = Cpu.registerL;\n            break;\n        case 6:\n            // Value at register HL\n            // 4 cycles\n            instructionRegisterValue = eightBitLoadSyncCycles(concatenateBytes(Cpu.registerH, Cpu.registerL));\n            break;\n        case 7:\n            instructionRegisterValue = Cpu.registerA;\n            break;\n    }\n    // Grab the high nibble to perform skips to speed up performance\n    var opcodeHighNibble = cbOpcode & 0xf0;\n    opcodeHighNibble = opcodeHighNibble >> 4;\n    // Send to the correct function\n    switch (opcodeHighNibble) {\n        case 0x00:\n            if (cbOpcode <= 0x07) {\n                // RLC register 8-bit\n                // Z 0 0 C\n                instructionRegisterResult = rotateRegisterLeft(instructionRegisterValue);\n                handledOpcode = true;\n            }\n            else if (cbOpcode <= 0x0f) {\n                // RRC register 8-bit\n                // Z 0 0 C\n                instructionRegisterResult = rotateRegisterRight(instructionRegisterValue);\n                handledOpcode = true;\n            }\n            break;\n        case 0x01:\n            if (cbOpcode <= 0x17) {\n                // RL register 8-bit\n                // Z 0 0 C\n                instructionRegisterResult = rotateRegisterLeftThroughCarry(instructionRegisterValue);\n                handledOpcode = true;\n            }\n            else if (cbOpcode <= 0x1f) {\n                // RR register 8-bit\n                // Z 0 0 C\n                instructionRegisterResult = rotateRegisterRightThroughCarry(instructionRegisterValue);\n                handledOpcode = true;\n            }\n            break;\n        case 0x02:\n            if (cbOpcode <= 0x27) {\n                // SLA register 8-bit\n                // Z 0 0 C\n                instructionRegisterResult = shiftLeftRegister(instructionRegisterValue);\n                handledOpcode = true;\n            }\n            else if (cbOpcode <= 0x2f) {\n                // SRA register 8-bit\n                // Z 0 0 0\n                instructionRegisterResult = shiftRightArithmeticRegister(instructionRegisterValue);\n                handledOpcode = true;\n            }\n            break;\n        case 0x03:\n            if (cbOpcode <= 0x37) {\n                // SWAP register 8-bit\n                // Z 0 0 0\n                instructionRegisterResult = swapNibblesOnRegister(instructionRegisterValue);\n                handledOpcode = true;\n            }\n            else if (cbOpcode <= 0x3f) {\n                // SRL B\n                // Z 0 0 C\n                instructionRegisterResult = shiftRightLogicalRegister(instructionRegisterValue);\n                handledOpcode = true;\n            }\n            break;\n        case 0x04:\n            if (cbOpcode <= 0x47) {\n                // BIT 0,register 8-bit\n                // Z 0 1 -\n                //TODO: Optimize this not to do logic of setting register back\n                instructionRegisterResult = testBitOnRegister(0, instructionRegisterValue);\n                handledOpcode = true;\n            }\n            else if (cbOpcode <= 0x4f) {\n                // BIT 1,register 8-bit\n                // Z 0 1 -\n                instructionRegisterResult = testBitOnRegister(1, instructionRegisterValue);\n                handledOpcode = true;\n            }\n            break;\n        case 0x05:\n            if (cbOpcode <= 0x57) {\n                // BIT 2,register 8-bit\n                // Z 0 1 -\n                instructionRegisterResult = testBitOnRegister(2, instructionRegisterValue);\n                handledOpcode = true;\n            }\n            else if (cbOpcode <= 0x5f) {\n                // BIT 3,register 8-bit\n                // Z 0 1 -\n                instructionRegisterResult = testBitOnRegister(3, instructionRegisterValue);\n                handledOpcode = true;\n            }\n            break;\n        case 0x06:\n            if (cbOpcode <= 0x67) {\n                // BIT 4,register 8-bit\n                // Z 0 1 -\n                instructionRegisterResult = testBitOnRegister(4, instructionRegisterValue);\n                handledOpcode = true;\n            }\n            else if (cbOpcode <= 0x6f) {\n                // BIT 5,register 8-bit\n                // Z 0 1 -\n                instructionRegisterResult = testBitOnRegister(5, instructionRegisterValue);\n                handledOpcode = true;\n            }\n            break;\n        case 0x07:\n            if (cbOpcode <= 0x77) {\n                // BIT 6,register 8-bit\n                // Z 0 1 -\n                instructionRegisterResult = testBitOnRegister(6, instructionRegisterValue);\n                handledOpcode = true;\n            }\n            else if (cbOpcode <= 0x7f) {\n                // BIT 7,register 8-bit\n                // Z 0 1 -\n                instructionRegisterResult = testBitOnRegister(7, instructionRegisterValue);\n                handledOpcode = true;\n            }\n            break;\n        case 0x08:\n            if (cbOpcode <= 0x87) {\n                // Res 0,register 8-bit\n                // - - - -\n                instructionRegisterResult = setBitOnRegister(0, 0, instructionRegisterValue);\n                handledOpcode = true;\n            }\n            else if (cbOpcode <= 0x8f) {\n                // Res 1,register 8-bit\n                // - - - -\n                instructionRegisterResult = setBitOnRegister(1, 0, instructionRegisterValue);\n                handledOpcode = true;\n            }\n            break;\n        case 0x09:\n            if (cbOpcode <= 0x97) {\n                // Res 2,register 8-bit\n                // - - - -\n                instructionRegisterResult = setBitOnRegister(2, 0, instructionRegisterValue);\n                handledOpcode = true;\n            }\n            else if (cbOpcode <= 0x9f) {\n                // Res 3,register 8-bit\n                // - - - -\n                instructionRegisterResult = setBitOnRegister(3, 0, instructionRegisterValue);\n                handledOpcode = true;\n            }\n            break;\n        case 0x0a:\n            if (cbOpcode <= 0xa7) {\n                // Res 4,register 8-bit\n                // - - - -\n                instructionRegisterResult = setBitOnRegister(4, 0, instructionRegisterValue);\n                handledOpcode = true;\n            }\n            else if (cbOpcode <= 0xaf) {\n                // Res 5,register 8-bit\n                // - - - -\n                instructionRegisterResult = setBitOnRegister(5, 0, instructionRegisterValue);\n                handledOpcode = true;\n            }\n            break;\n        case 0x0b:\n            if (cbOpcode <= 0xb7) {\n                // Res 6,register 8-bit\n                // - - - -\n                instructionRegisterResult = setBitOnRegister(6, 0, instructionRegisterValue);\n                handledOpcode = true;\n            }\n            else if (cbOpcode <= 0xbf) {\n                // Res 7,register 8-bit\n                // - - - -\n                instructionRegisterResult = setBitOnRegister(7, 0, instructionRegisterValue);\n                handledOpcode = true;\n            }\n            break;\n        case 0x0c:\n            if (cbOpcode <= 0xc7) {\n                // SET 0,register 8-bit\n                // - - - -\n                instructionRegisterResult = setBitOnRegister(0, 1, instructionRegisterValue);\n                handledOpcode = true;\n            }\n            else if (cbOpcode <= 0xcf) {\n                // SET 1,register 8-bit\n                // - - - -\n                instructionRegisterResult = setBitOnRegister(1, 1, instructionRegisterValue);\n                handledOpcode = true;\n            }\n            break;\n        case 0x0d:\n            if (cbOpcode <= 0xd7) {\n                // SET 2,register 8-bit\n                // - - - -\n                instructionRegisterResult = setBitOnRegister(2, 1, instructionRegisterValue);\n                handledOpcode = true;\n            }\n            else if (cbOpcode <= 0xdf) {\n                // SET 3,register 8-bit\n                // - - - -\n                instructionRegisterResult = setBitOnRegister(3, 1, instructionRegisterValue);\n                handledOpcode = true;\n            }\n            break;\n        case 0x0e:\n            if (cbOpcode <= 0xe7) {\n                // SET 4,register 8-bit\n                // - - - -\n                instructionRegisterResult = setBitOnRegister(4, 1, instructionRegisterValue);\n                handledOpcode = true;\n            }\n            else if (cbOpcode <= 0xef) {\n                // SET 5,register 8-bit\n                // - - - -\n                instructionRegisterResult = setBitOnRegister(5, 1, instructionRegisterValue);\n                handledOpcode = true;\n            }\n            break;\n        case 0x0f:\n            if (cbOpcode <= 0xf7) {\n                // SET 6,register 8-bit\n                // - - - -\n                instructionRegisterResult = setBitOnRegister(6, 1, instructionRegisterValue);\n                handledOpcode = true;\n            }\n            else if (cbOpcode <= 0xff) {\n                // SET 7,register 8-bit\n                // - - - -\n                instructionRegisterResult = setBitOnRegister(7, 1, instructionRegisterValue);\n                handledOpcode = true;\n            }\n            break;\n    }\n    // Finally Pass back into the correct register\n    switch (registerNumber) {\n        case 0:\n            Cpu.registerB = instructionRegisterResult;\n            break;\n        case 1:\n            Cpu.registerC = instructionRegisterResult;\n            break;\n        case 2:\n            Cpu.registerD = instructionRegisterResult;\n            break;\n        case 3:\n            Cpu.registerE = instructionRegisterResult;\n            break;\n        case 4:\n            Cpu.registerH = instructionRegisterResult;\n            break;\n        case 5:\n            Cpu.registerL = instructionRegisterResult;\n            break;\n        case 6:\n            // Value at register HL\n            // Opcodes 0x40 -> 0x7F only do simple\n            // Bit test, and don't need to be stored back in memory\n            // Thus they take 4 less cycles to run\n            if (opcodeHighNibble < 0x04 || opcodeHighNibble > 0x07) {\n                // Store the result back\n                // 4 cycles\n                eightBitStoreSyncCycles(concatenateBytes(Cpu.registerH, Cpu.registerL), instructionRegisterResult);\n            }\n            break;\n        case 7:\n            Cpu.registerA = instructionRegisterResult;\n            break;\n    }\n    // Finally our number of cycles\n    // Set if we handled the opcode\n    if (handledOpcode) {\n        numberOfCycles = 4;\n    }\n    // Return our number of cycles\n    return numberOfCycles;\n}\n\n// Imports\n// Take in any opcode, and decode it, and return the number of cycles\n// Program counter can be gotten from getProgramCounter();\n// Setting return value to i32 instead of u16, as we want to return a negative number on error\n// https://rednex.github.io/rgbds/gbz80.7.html\n// http://pastraiser.com/cpu/gameboy/gameboyopcodes.html\nfunction executeOpcode$$1(opcode) {\n    // Always implement the program counter by one\n    // Any other value can just subtract or add however much offset before reaching this line\n    var programCounter = Cpu.programCounter;\n    programCounter = u16Portable(programCounter + 1);\n    // Check if we are in the halt bug\n    if (Cpu.isHaltBug) {\n        // Need to not increment program counter,\n        // thus, running the next opcode twice\n        // E.g\n        // 0x76 - halt\n        // FA 34 12 - ld a,(1234)\n        // Becomes\n        // FA FA 34 ld a,(34FA)\n        // 12 ld (de),a\n        programCounter = u16Portable(programCounter - 1);\n    }\n    Cpu.programCounter = programCounter;\n    // Split our opcode into a high nibble to speed up performance\n    // Running 255 if statements is slow, even in wasm haha!\n    var opcodeHighNibble = opcode & 0xf0;\n    opcodeHighNibble = opcodeHighNibble >> 4;\n    // NOTE: @binji rule of thumb: it takes 4 cpu cycles to read one byte\n    // Therefore isntructions that use more than just the opcode (databyte one and two) will take at least\n    // 8 cyckles to use getDataByteOne(), and two cycles to use the concatented\n    // Not using a switch statement to avoid cannot redeclare this variable errors\n    // And it would be a ton of work :p\n    switch (opcodeHighNibble) {\n        case 0x00:\n            return handleOpcode0x(opcode);\n        case 0x01:\n            return handleOpcode1x(opcode);\n        case 0x02:\n            return handleOpcode2x(opcode);\n        case 0x03:\n            return handleOpcode3x(opcode);\n        case 0x04:\n            return handleOpcode4x(opcode);\n        case 0x05:\n            return handleOpcode5x(opcode);\n        case 0x06:\n            return handleOpcode6x(opcode);\n        case 0x07:\n            return handleOpcode7x(opcode);\n        case 0x08:\n            return handleOpcode8x(opcode);\n        case 0x09:\n            return handleOpcode9x(opcode);\n        case 0x0a:\n            return handleOpcodeAx(opcode);\n        case 0x0b:\n            return handleOpcodeBx(opcode);\n        case 0x0c:\n            return handleOpcodeCx(opcode);\n        case 0x0d:\n            return handleOpcodeDx(opcode);\n        case 0x0e:\n            return handleOpcodeEx(opcode);\n        default:\n            return handleOpcodeFx(opcode);\n    }\n}\n// Wrapper functions around loading and storing memory, and syncing those cycles\nfunction eightBitLoadSyncCycles(gameboyOffset) {\n    syncCycles(4);\n    return eightBitLoadFromGBMemoryWithTraps(gameboyOffset);\n}\nfunction eightBitStoreSyncCycles(gameboyOffset, value) {\n    syncCycles(4);\n    eightBitStoreIntoGBMemoryWithTraps(gameboyOffset, value);\n}\nfunction sixteenBitLoadSyncCycles(gameboyOffset) {\n    syncCycles(8);\n    // sixteen bit load has traps even though it has no label\n    return sixteenBitLoadFromGBMemory(gameboyOffset);\n}\nfunction sixteenBitStoreSyncCycles(gameboyOffset, value) {\n    syncCycles(8);\n    sixteenBitStoreIntoGBMemoryWithTraps(gameboyOffset, value);\n}\n// Functions to access the next operands of a opcode, reffering to them as \"dataBytes\"\nfunction getDataByteOne() {\n    syncCycles(4);\n    return eightBitLoadFromGBMemory(Cpu.programCounter);\n}\nfunction getDataByteTwo() {\n    syncCycles(4);\n    return eightBitLoadFromGBMemory(u16Portable(Cpu.programCounter + 1));\n}\n// Get our concatenated databyte one and getDataByteTwo()\n// Find and replace with : getConcatenatedDataByte()\nfunction getConcatenatedDataByte() {\n    return concatenateBytes(getDataByteTwo(), getDataByteOne());\n}\nfunction handleOpcode0x(opcode) {\n    switch (opcode) {\n        case 0x00:\n            // NOP\n            // 1  4\n            // No Operation\n            return 4;\n        case 0x01: {\n            // LD BC,d16\n            // 3  12\n            // 8 cycles\n            var concatenatedDataByte = getConcatenatedDataByte();\n            Cpu.registerB = splitHighByte(concatenatedDataByte);\n            Cpu.registerC = splitLowByte(concatenatedDataByte);\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 2);\n            return 4;\n        }\n        case 0x02: {\n            // LD (BC),A\n            // 1  8\n            // () means load into address pointed by BC\n            // 4 cycles\n            eightBitStoreSyncCycles(concatenateBytes(Cpu.registerB, Cpu.registerC), Cpu.registerA);\n            return 4;\n        }\n        case 0x03: {\n            // INC BC\n            // 1  8\n            var registerBC3 = concatenateBytes(Cpu.registerB, Cpu.registerC);\n            registerBC3++;\n            Cpu.registerB = splitHighByte(registerBC3);\n            Cpu.registerC = splitLowByte(registerBC3);\n            return 8;\n        }\n        case 0x04: {\n            // INC B\n            // 1  4\n            // Z 0 H -\n            var registerB = Cpu.registerB;\n            checkAndSetEightBitHalfCarryFlag(registerB, 1);\n            registerB = u8Portable(registerB + 1);\n            Cpu.registerB = registerB;\n            setZeroFlag$$1((registerB === 0));\n            setSubtractFlag(0);\n            return 4;\n        }\n        case 0x05: {\n            // DEC B\n            // 1  4\n            // Z 1 H -\n            var registerB = Cpu.registerB;\n            checkAndSetEightBitHalfCarryFlag(registerB, -1);\n            registerB = u8Portable(registerB - 1);\n            Cpu.registerB = registerB;\n            setZeroFlag$$1((registerB === 0));\n            setSubtractFlag(1);\n            return 4;\n        }\n        case 0x06: {\n            // LD B,d8\n            // 2  8\n            // 4 cycles\n            Cpu.registerB = getDataByteOne();\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            return 4;\n        }\n        case 0x07: {\n            // RLCA\n            // 1  4\n            // 0 0 0 C\n            // Check for the carry\n            var registerA = Cpu.registerA;\n            setCarryFlag(((registerA & 0x80) === 0x80));\n            Cpu.registerA = rotateByteLeft(registerA);\n            // Set all other flags to zero\n            setZeroFlag$$1(0);\n            setSubtractFlag(0);\n            setHalfCarryFlag(0);\n            return 4;\n        }\n        case 0x08: {\n            // LD (a16),SP\n            // 3  20\n            // Load the stack pointer into the 16 bit address represented by the two data bytes\n            // 16 cycles, 8 from data byte, 8 from sixteenbit store\n            sixteenBitStoreSyncCycles(getConcatenatedDataByte(), Cpu.stackPointer);\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 2);\n            return 4;\n        }\n        case 0x09: {\n            // ADD HL,BC\n            // 1 8\n            // - 0 H C\n            var registerHL = concatenateBytes(Cpu.registerH, Cpu.registerL);\n            var registerBC9 = concatenateBytes(Cpu.registerB, Cpu.registerC);\n            checkAndSetSixteenBitFlagsAddOverflow(registerHL, registerBC9, false);\n            var result = u16Portable((registerHL + registerBC9));\n            Cpu.registerH = splitHighByte(result);\n            Cpu.registerL = splitLowByte(result);\n            setSubtractFlag(0);\n            return 8;\n        }\n        case 0x0a: {\n            // LD A,(BC)\n            // 1 8\n            // 4 cycles from load\n            Cpu.registerA = eightBitLoadSyncCycles(concatenateBytes(Cpu.registerB, Cpu.registerC));\n            return 4;\n        }\n        case 0x0b: {\n            // DEC BC\n            // 1  8\n            var registerBCB = concatenateBytes(Cpu.registerB, Cpu.registerC);\n            registerBCB = u16Portable(registerBCB - 1);\n            Cpu.registerB = splitHighByte(registerBCB);\n            Cpu.registerC = splitLowByte(registerBCB);\n            return 8;\n        }\n        case 0x0c: {\n            // INC C\n            // 1  4\n            // Z 0 H -\n            var registerC = Cpu.registerC;\n            checkAndSetEightBitHalfCarryFlag(registerC, 1);\n            registerC = u8Portable(registerC + 1);\n            Cpu.registerC = registerC;\n            setZeroFlag$$1((registerC === 0));\n            setSubtractFlag(0);\n            return 4;\n        }\n        case 0x0d: {\n            // DEC C\n            // 1  4\n            // Z 1 H -\n            var registerC = Cpu.registerC;\n            checkAndSetEightBitHalfCarryFlag(registerC, -1);\n            registerC = u8Portable(registerC - 1);\n            Cpu.registerC = registerC;\n            setZeroFlag$$1((registerC === 0));\n            setSubtractFlag(1);\n            return 4;\n        }\n        case 0x0e: {\n            // LD C,d8\n            // 2 8\n            // 4 cycles\n            Cpu.registerC = getDataByteOne();\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            return 4;\n        }\n        case 0x0f: {\n            // RRCA\n            // 1 4\n            // 0 0 0 C\n            // Check for the last bit, to see if it will be carried\n            var registerA = Cpu.registerA;\n            setCarryFlag(((registerA & 0x01) > 0));\n            Cpu.registerA = rotateByteRight(registerA);\n            // Set all other flags to zero\n            setZeroFlag$$1(0);\n            setSubtractFlag(0);\n            setHalfCarryFlag(0);\n            return 4;\n        }\n    }\n    return -1;\n}\nfunction handleOpcode1x(opcode) {\n    switch (opcode) {\n        case 0x10: {\n            // STOP 0\n            // 2 4\n            // Enter CPU very low power mode. Also used to switch between double and normal speed CPU modes in GBC.\n            // Meaning Don't Decode anymore opcodes , or updated the LCD until joypad interrupt (or when button is pressed if I am wrong)\n            // See HALT\n            // If we are in gameboy color mode, set the new speed\n            if (Cpu.GBCEnabled) {\n                // 4 cycles\n                var speedSwitch = eightBitLoadSyncCycles(Cpu.memoryLocationSpeedSwitch);\n                if (checkBitOnByte(0, speedSwitch)) {\n                    // Reset the prepare bit\n                    speedSwitch = resetBitOnByte(0, speedSwitch);\n                    // Switch to the new mode, and set the speed switch to the OTHER speed, to represent our new speed\n                    if (!checkBitOnByte(7, speedSwitch)) {\n                        Cpu.GBCDoubleSpeed = true;\n                        speedSwitch = setBitOnByte(7, speedSwitch);\n                    }\n                    else {\n                        Cpu.GBCDoubleSpeed = false;\n                        speedSwitch = resetBitOnByte(7, speedSwitch);\n                    }\n                    // Store the final speed switch\n                    // 4 cycles\n                    eightBitStoreSyncCycles(Cpu.memoryLocationSpeedSwitch, speedSwitch);\n                    // Cycle accurate gameboy docs says this takes 76 clocks\n                    // 76 - 8 cycles (from load/store) = 68\n                    return 68;\n                }\n            }\n            // NOTE: This breaks Blarggs CPU tests if CGB Stop is not implemented\n            Cpu.isStopped = true;\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            return 4;\n        }\n        case 0x11: {\n            // LD DE,d16\n            // 3  12\n            // 8 cycles\n            var concatenatedDataByte = getConcatenatedDataByte();\n            Cpu.registerD = splitHighByte(concatenatedDataByte);\n            Cpu.registerE = splitLowByte(concatenatedDataByte);\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 2);\n            return 4;\n        }\n        case 0x12: {\n            // LD (DE),A\n            // 1 8\n            // 4 cycles\n            eightBitStoreSyncCycles(concatenateBytes(Cpu.registerD, Cpu.registerE), Cpu.registerA);\n            return 4;\n        }\n        case 0x13: {\n            // INC DE\n            // 1 8\n            var registerDE3 = concatenateBytes(Cpu.registerD, Cpu.registerE);\n            registerDE3 = u16Portable(registerDE3 + 1);\n            Cpu.registerD = splitHighByte(registerDE3);\n            Cpu.registerE = splitLowByte(registerDE3);\n            return 8;\n        }\n        case 0x14: {\n            // INC D\n            // 1  4\n            // Z 0 H -\n            var registerD = Cpu.registerD;\n            checkAndSetEightBitHalfCarryFlag(registerD, 1);\n            registerD = u8Portable(registerD + 1);\n            Cpu.registerD = registerD;\n            setZeroFlag$$1((Cpu.registerD === 0));\n            setSubtractFlag(0);\n            return 4;\n        }\n        case 0x15: {\n            // DEC D\n            // 1  4\n            // Z 1 H -\n            var registerD = Cpu.registerD;\n            checkAndSetEightBitHalfCarryFlag(registerD, -1);\n            registerD = u8Portable(registerD - 1);\n            Cpu.registerD = registerD;\n            setZeroFlag$$1((Cpu.registerD === 0));\n            setSubtractFlag(1);\n            return 4;\n        }\n        case 0x16: {\n            // LD D,d8\n            // 2 8\n            // 4 cycles\n            Cpu.registerD = getDataByteOne();\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            return 4;\n        }\n        case 0x17: {\n            // RLA\n            // 1 4\n            // 0 0 0 C\n            // Check for the carry\n            // setting has first bit since we need to use carry\n            var hasHighbit = (Cpu.registerA & 0x80) === 0x80;\n            Cpu.registerA = rotateByteLeftThroughCarry(Cpu.registerA);\n            // OR the carry flag to the end\n            setCarryFlag(hasHighbit);\n            // Set all other flags to zero\n            setZeroFlag$$1(0);\n            setSubtractFlag(0);\n            setHalfCarryFlag(0);\n            return 4;\n        }\n        case 0x18: {\n            // JR r8\n            // 2  12\n            // NOTE: Discoved dataByte is signed\n            // However the relative Jump Function handles this\n            // 4 cycles\n            relativeJump(getDataByteOne());\n            return 8;\n        }\n        // Relative Jump Function Handles program counter\n        case 0x19: {\n            // ADD HL,DE\n            // 1  8\n            // - 0 H C\n            var registerHL = concatenateBytes(Cpu.registerH, Cpu.registerL);\n            var registerDE9 = concatenateBytes(Cpu.registerD, Cpu.registerE);\n            checkAndSetSixteenBitFlagsAddOverflow(registerHL, registerDE9, false);\n            var result = u16Portable((registerHL + registerDE9));\n            Cpu.registerH = splitHighByte(result);\n            Cpu.registerL = splitLowByte(result);\n            setSubtractFlag(0);\n            return 8;\n        }\n        case 0x1a: {\n            // LD A,(DE)\n            // 1 8\n            var registerDEA = concatenateBytes(Cpu.registerD, Cpu.registerE);\n            // 4 cycles\n            Cpu.registerA = eightBitLoadSyncCycles(registerDEA);\n            return 4;\n        }\n        case 0x1b: {\n            // DEC DE\n            // 1 8\n            var registerDEB = concatenateBytes(Cpu.registerD, Cpu.registerE);\n            registerDEB = u16Portable(registerDEB - 1);\n            Cpu.registerD = splitHighByte(registerDEB);\n            Cpu.registerE = splitLowByte(registerDEB);\n            return 8;\n        }\n        case 0x1c: {\n            // INC E\n            // 1  4\n            // Z 0 H -\n            var registerE = Cpu.registerE;\n            checkAndSetEightBitHalfCarryFlag(registerE, 1);\n            registerE = u8Portable(registerE + 1);\n            Cpu.registerE = registerE;\n            setZeroFlag$$1((registerE === 0));\n            setSubtractFlag(0);\n            return 4;\n        }\n        case 0x1d: {\n            // DEC E\n            // 1  4\n            // Z 1 H -\n            var registerE = Cpu.registerE;\n            checkAndSetEightBitHalfCarryFlag(registerE, -1);\n            registerE = u8Portable(registerE - 1);\n            Cpu.registerE = registerE;\n            setZeroFlag$$1((registerE === 0));\n            setSubtractFlag(1);\n            return 4;\n        }\n        case 0x1e: {\n            // LD E,d8\n            // 2 8\n            // 4 cycles\n            Cpu.registerE = getDataByteOne();\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            return 4;\n        }\n        case 0x1f: {\n            // RRA\n            // 1 4\n            // 0 0 0 C\n            // Check for the carry\n            // setting has low bit since we need to use carry\n            var hasLowBit = (Cpu.registerA & 0x01) === 0x01;\n            Cpu.registerA = rotateByteRightThroughCarry(Cpu.registerA);\n            setCarryFlag(hasLowBit);\n            // Set all other flags to zero\n            setZeroFlag$$1(0);\n            setSubtractFlag(0);\n            setHalfCarryFlag(0);\n            return 4;\n        }\n    }\n    return -1;\n}\nfunction handleOpcode2x(opcode) {\n    switch (opcode) {\n        case 0x20: {\n            // JR NZ,r8\n            // 2  12/8\n            // NOTE: NZ stands for not [flag], so in this case, not zero flag\n            // Also, / means, if condition. so if met, 12 cycles, otherwise 8 cycles\n            if (getZeroFlag$$1() === 0) {\n                // 4 cycles\n                relativeJump(getDataByteOne());\n                // Relative Jump Funciton handles program counter\n            }\n            else {\n                Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            }\n            return 8;\n        }\n        case 0x21: {\n            // LD HL,d16\n            // 3  12\n            // 8 cycles\n            var sixteenBitDataByte = getConcatenatedDataByte();\n            Cpu.registerH = splitHighByte(sixteenBitDataByte);\n            Cpu.registerL = splitLowByte(sixteenBitDataByte);\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 2);\n            return 4;\n        }\n        case 0x22: {\n            // LD (HL+),A\n            // 1 8\n            var registerHL2 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n            // 4 cycles\n            eightBitStoreSyncCycles(registerHL2, Cpu.registerA);\n            registerHL2 = u16Portable(registerHL2 + 1);\n            Cpu.registerH = splitHighByte(registerHL2);\n            Cpu.registerL = splitLowByte(registerHL2);\n            return 4;\n        }\n        case 0x23: {\n            // INC HL\n            // 1  8\n            var registerHL3 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n            registerHL3 = u16Portable(registerHL3 + 1);\n            Cpu.registerH = splitHighByte(registerHL3);\n            Cpu.registerL = splitLowByte(registerHL3);\n            return 8;\n        }\n        case 0x24: {\n            // INC H\n            // 1  4\n            // Z 0 H -\n            var registerH = Cpu.registerH;\n            checkAndSetEightBitHalfCarryFlag(registerH, 1);\n            registerH = u8Portable(registerH + 1);\n            Cpu.registerH = registerH;\n            setZeroFlag$$1((registerH === 0));\n            setSubtractFlag(0);\n            return 4;\n        }\n        case 0x25: {\n            // DEC H\n            // 1  4\n            // Z 1 H -\n            var registerH = Cpu.registerH;\n            checkAndSetEightBitHalfCarryFlag(registerH, -1);\n            registerH = u8Portable(registerH - 1);\n            Cpu.registerH = registerH;\n            setZeroFlag$$1((registerH === 0));\n            setSubtractFlag(1);\n            return 4;\n        }\n        case 0x26: {\n            // LD H,d8\n            // 2 8\n            // 4 cycles\n            Cpu.registerH = getDataByteOne();\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            return 4;\n        }\n        case 0x27: {\n            // DAA\n            // 1 4\n            // Z - 0 C\n            var adjustedRegister = 0;\n            var adjustment = 0;\n            if (getHalfCarryFlag() > 0) {\n                adjustment = adjustment | 0x06;\n            }\n            if (getCarryFlag$$1() > 0) {\n                adjustment = adjustment | 0x60;\n            }\n            var registerA = Cpu.registerA;\n            if (getSubtractFlag() > 0) {\n                adjustedRegister = u8Portable(registerA - adjustment);\n            }\n            else {\n                if ((registerA & 0x0f) > 0x09) {\n                    adjustment = adjustment | 0x06;\n                }\n                if (registerA > 0x99) {\n                    adjustment = adjustment | 0x60;\n                }\n                adjustedRegister = u8Portable(registerA + adjustment);\n            }\n            // Now set our flags to the correct values\n            setZeroFlag$$1((adjustedRegister === 0));\n            setCarryFlag(((adjustment & 0x60) !== 0));\n            setHalfCarryFlag(0);\n            Cpu.registerA = adjustedRegister;\n            return 4;\n        }\n        case 0x28: {\n            // JR Z,r8\n            // 2  12/8\n            if (getZeroFlag$$1() > 0) {\n                // 4 cycles\n                relativeJump(getDataByteOne());\n                // Relative Jump funciton handles pogram counter\n            }\n            else {\n                Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            }\n            return 8;\n        }\n        case 0x29: {\n            // ADD HL,HL\n            // 1  8\n            // - 0 H C\n            var registerHL9 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n            checkAndSetSixteenBitFlagsAddOverflow(registerHL9, registerHL9, false);\n            registerHL9 = u16Portable(registerHL9 * 2);\n            Cpu.registerH = splitHighByte(registerHL9);\n            Cpu.registerL = splitLowByte(registerHL9);\n            setSubtractFlag(0);\n            return 8;\n        }\n        case 0x2a: {\n            // LD A,(HL+)\n            // 1  8\n            var registerHLA = concatenateBytes(Cpu.registerH, Cpu.registerL);\n            // 4 cycles\n            Cpu.registerA = eightBitLoadSyncCycles(registerHLA);\n            registerHLA = u16Portable(registerHLA + 1);\n            Cpu.registerH = splitHighByte(registerHLA);\n            Cpu.registerL = splitLowByte(registerHLA);\n            return 4;\n        }\n        case 0x2b: {\n            // DEC HL\n            // 1 8\n            var registerHLB = concatenateBytes(Cpu.registerH, Cpu.registerL);\n            registerHLB = u16Portable(registerHLB - 1);\n            Cpu.registerH = splitHighByte(registerHLB);\n            Cpu.registerL = splitLowByte(registerHLB);\n            return 8;\n        }\n        case 0x2c: {\n            // INC L\n            // 1  4\n            // Z 0 H -\n            var registerL = Cpu.registerL;\n            checkAndSetEightBitHalfCarryFlag(registerL, 1);\n            registerL = u8Portable(registerL + 1);\n            Cpu.registerL = registerL;\n            setZeroFlag$$1((registerL === 0));\n            setSubtractFlag(0);\n            return 4;\n        }\n        case 0x2d: {\n            // DEC L\n            // 1  4\n            // Z 1 H -\n            var registerL = Cpu.registerL;\n            checkAndSetEightBitHalfCarryFlag(registerL, -1);\n            registerL = u8Portable(registerL - 1);\n            Cpu.registerL = registerL;\n            setZeroFlag$$1((registerL === 0));\n            setSubtractFlag(1);\n            return 4;\n        }\n        case 0x2e: {\n            // LD L,d8\n            // 2  8\n            // 4 cycles\n            Cpu.registerL = getDataByteOne();\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            return 4;\n        }\n        case 0x2f: {\n            // CPL\n            // 1 4\n            // - 1 1 -\n            Cpu.registerA = ~Cpu.registerA;\n            setSubtractFlag(1);\n            setHalfCarryFlag(1);\n            return 4;\n        }\n    }\n    return -1;\n}\nfunction handleOpcode3x(opcode) {\n    switch (opcode) {\n        case 0x30: {\n            // JR NC,r8\n            // 2 12 / 8\n            if (getCarryFlag$$1() === 0) {\n                // 4 cycles\n                relativeJump(getDataByteOne());\n                // Relative Jump function handles program counter\n            }\n            else {\n                Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            }\n            return 8;\n        }\n        case 0x31: {\n            // LD SP,d16\n            // 3 12\n            // 8 cycles\n            Cpu.stackPointer = getConcatenatedDataByte();\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 2);\n            return 4;\n        }\n        case 0x32: {\n            // LD (HL-),A\n            // 1 8\n            var registerHL2 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n            // 4 cycles\n            eightBitStoreSyncCycles(registerHL2, Cpu.registerA);\n            registerHL2 = u16Portable(registerHL2 - 1);\n            Cpu.registerH = splitHighByte(registerHL2);\n            Cpu.registerL = splitLowByte(registerHL2);\n            return 4;\n        }\n        case 0x33: {\n            // INC SP\n            // 1 8\n            Cpu.stackPointer = u16Portable(Cpu.stackPointer + 1);\n            return 8;\n        }\n        case 0x34: {\n            // INC (HL)\n            // 1  12\n            // Z 0 H -\n            var registerHL4 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n            // 4 cycles\n            var valueAtHL4 = eightBitLoadSyncCycles(registerHL4);\n            // Creating a varible for this to fix assemblyscript overflow bug\n            // Requires explicit casting\n            // https://github.com/AssemblyScript/assemblyscript/issues/26\n            var incrementer = 1;\n            checkAndSetEightBitHalfCarryFlag(valueAtHL4, incrementer);\n            valueAtHL4 = u8Portable(valueAtHL4 + incrementer);\n            setZeroFlag$$1((valueAtHL4 === 0));\n            setSubtractFlag(0);\n            // 4 cycles\n            eightBitStoreSyncCycles(registerHL4, valueAtHL4);\n            return 4;\n        }\n        case 0x35: {\n            // DEC (HL)\n            // 1  12\n            // Z 1 H -\n            var registerHL5 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n            // 4 cycles\n            var valueAtHL5 = eightBitLoadSyncCycles(registerHL5);\n            // NOTE: This opcode may not overflow correctly,\n            // Please see previous opcode\n            checkAndSetEightBitHalfCarryFlag(valueAtHL5, -1);\n            valueAtHL5 = u8Portable(valueAtHL5 - 1);\n            setZeroFlag$$1((valueAtHL5 === 0));\n            setSubtractFlag(1);\n            // 4 cycles\n            eightBitStoreSyncCycles(registerHL5, valueAtHL5);\n            return 4;\n        }\n        case 0x36: {\n            // LD (HL),d8\n            // 2  12\n            // 8 cycles, 4 from store, 4 from data byte\n            eightBitStoreSyncCycles(concatenateBytes(Cpu.registerH, Cpu.registerL), getDataByteOne());\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            return 4;\n        }\n        case 0x37: {\n            // SCF\n            // 1  4\n            // - 0 0 1\n            // Simply set the carry flag\n            setSubtractFlag(0);\n            setHalfCarryFlag(0);\n            setCarryFlag(1);\n            return 4;\n        }\n        case 0x38: {\n            // JR C,r8\n            // 2 12/8\n            if (getCarryFlag$$1() === 1) {\n                // 4 cycles\n                relativeJump(getDataByteOne());\n                // Relative Jump Funciton handles program counter\n            }\n            else {\n                Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            }\n            return 8;\n        }\n        case 0x39: {\n            // ADD HL,SP\n            // 1 8\n            // - 0 H C\n            var registerHL9 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n            checkAndSetSixteenBitFlagsAddOverflow(registerHL9, Cpu.stackPointer, false);\n            var result = u16Portable((registerHL9 + Cpu.stackPointer));\n            Cpu.registerH = splitHighByte(result);\n            Cpu.registerL = splitLowByte(result);\n            setSubtractFlag(0);\n            return 8;\n        }\n        case 0x3a: {\n            // LD A,(HL-)\n            // 1 8\n            var registerHLA = concatenateBytes(Cpu.registerH, Cpu.registerL);\n            // 4 cycles\n            Cpu.registerA = eightBitLoadSyncCycles(registerHLA);\n            registerHLA = u16Portable(registerHLA - 1);\n            Cpu.registerH = splitHighByte(registerHLA);\n            Cpu.registerL = splitLowByte(registerHLA);\n            return 4;\n        }\n        case 0x3b: {\n            // DEC SP\n            // 1 8\n            Cpu.stackPointer = u16Portable(Cpu.stackPointer - 1);\n            return 8;\n        }\n        case 0x3c: {\n            // INC A\n            // 1  4\n            // Z 0 H -\n            var registerA = Cpu.registerA;\n            checkAndSetEightBitHalfCarryFlag(registerA, 1);\n            registerA = u8Portable(registerA + 1);\n            Cpu.registerA = registerA;\n            setZeroFlag$$1((registerA === 0));\n            setSubtractFlag(0);\n            return 4;\n        }\n        case 0x3d: {\n            // DEC A\n            // 1  4\n            // Z 1 H -\n            var registerA = Cpu.registerA;\n            checkAndSetEightBitHalfCarryFlag(registerA, -1);\n            registerA = u8Portable(registerA - 1);\n            Cpu.registerA = registerA;\n            setZeroFlag$$1((registerA === 0));\n            setSubtractFlag(1);\n            return 4;\n        }\n        case 0x3e: {\n            // LD A,d8\n            // 2 8\n            // 4 cycles\n            Cpu.registerA = getDataByteOne();\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            return 4;\n        }\n        case 0x3f: {\n            // CCF\n            // 1 4\n            // - 0 0 C\n            setSubtractFlag(0);\n            setHalfCarryFlag(0);\n            setCarryFlag((getCarryFlag$$1() <= 0));\n            return 4;\n        }\n    }\n    return -1;\n}\nfunction handleOpcode4x(opcode) {\n    switch (opcode) {\n        case 0x40:\n            // LD B,B\n            // 1 4\n            // Load B into B, Do nothing\n            return 4;\n        case 0x41:\n            // LD B,C\n            // 1 4\n            Cpu.registerB = Cpu.registerC;\n            return 4;\n        case 0x42:\n            // LD B,D\n            // 1 4\n            Cpu.registerB = Cpu.registerD;\n            return 4;\n        case 0x43:\n            // LD B,E\n            // 1 4\n            Cpu.registerB = Cpu.registerE;\n            return 4;\n        case 0x44:\n            // LD B,H\n            // 1 4\n            Cpu.registerB = Cpu.registerH;\n            return 4;\n        case 0x45:\n            // LD B,L\n            // 1 4\n            Cpu.registerB = Cpu.registerL;\n            return 4;\n        case 0x46:\n            // LD B,(HL)\n            // 1 8\n            // 4 cycles\n            Cpu.registerB = eightBitLoadSyncCycles(concatenateBytes(Cpu.registerH, Cpu.registerL));\n            return 4;\n        case 0x47:\n            // LD B,A\n            // 1 4\n            Cpu.registerB = Cpu.registerA;\n            return 4;\n        case 0x48:\n            // LD C,B\n            // 1 4\n            Cpu.registerC = Cpu.registerB;\n            return 4;\n        case 0x49:\n            // LD C,C\n            // 1 4\n            // Do nothing\n            return 4;\n        case 0x4a:\n            // LD C,D\n            // 1 4\n            Cpu.registerC = Cpu.registerD;\n            return 4;\n        case 0x4b:\n            // LD C,E\n            // 1 4\n            Cpu.registerC = Cpu.registerE;\n            return 4;\n        case 0x4c:\n            // LD C,H\n            // 1 4\n            Cpu.registerC = Cpu.registerH;\n            return 4;\n        case 0x4d:\n            // LD C,L\n            // 1 4\n            Cpu.registerC = Cpu.registerL;\n            return 4;\n        case 0x4e:\n            // LD C,(HL)\n            // 1 8\n            // 4 cycles\n            Cpu.registerC = eightBitLoadSyncCycles(concatenateBytes(Cpu.registerH, Cpu.registerL));\n            return 4;\n        case 0x4f:\n            // LD C,A\n            // 1 4\n            Cpu.registerC = Cpu.registerA;\n            return 4;\n    }\n    return -1;\n}\nfunction handleOpcode5x(opcode) {\n    switch (opcode) {\n        case 0x50:\n            // LD D,B\n            // 1 4\n            Cpu.registerD = Cpu.registerB;\n            return 4;\n        case 0x51:\n            // LD D,C\n            // 1 4\n            Cpu.registerD = Cpu.registerC;\n            return 4;\n        case 0x52:\n            // LD D,D\n            // 1 4\n            // Do Nothing\n            return 4;\n        case 0x53:\n            // LD D,E\n            // 1 4\n            Cpu.registerD = Cpu.registerE;\n            return 4;\n        case 0x54:\n            // LD D,H\n            // 1 4\n            Cpu.registerD = Cpu.registerH;\n            return 4;\n        case 0x55:\n            // LD D,L\n            // 1 4\n            Cpu.registerD = Cpu.registerL;\n            return 4;\n        case 0x56:\n            // LD D,(HL)\n            // 1 8\n            // 4 cycles\n            Cpu.registerD = eightBitLoadSyncCycles(concatenateBytes(Cpu.registerH, Cpu.registerL));\n            return 4;\n        case 0x57:\n            // LD D,A\n            // 1 4\n            Cpu.registerD = Cpu.registerA;\n            return 4;\n        case 0x58:\n            // LD E,B\n            // 1 4\n            Cpu.registerE = Cpu.registerB;\n            return 4;\n        case 0x59:\n            // LD E,C\n            // 1 4\n            Cpu.registerE = Cpu.registerC;\n            return 4;\n        case 0x5a:\n            // LD E,D\n            // 1 4\n            Cpu.registerE = Cpu.registerD;\n            return 4;\n        case 0x5b:\n            // LD E,E\n            // 1 4\n            // Do Nothing\n            return 4;\n        case 0x5c:\n            // LD E,H\n            // 1 4\n            Cpu.registerE = Cpu.registerH;\n            return 4;\n        case 0x5d:\n            // LD E,L\n            // 1 4\n            Cpu.registerE = Cpu.registerL;\n            return 4;\n        case 0x5e:\n            // LD E,(HL)\n            // 1 8\n            // 4 cycles\n            Cpu.registerE = eightBitLoadSyncCycles(concatenateBytes(Cpu.registerH, Cpu.registerL));\n            return 4;\n        case 0x5f:\n            // LD E,A\n            // 1 4\n            Cpu.registerE = Cpu.registerA;\n            return 4;\n    }\n    return -1;\n}\nfunction handleOpcode6x(opcode) {\n    switch (opcode) {\n        case 0x60:\n            // LD H,B\n            // 1 4\n            Cpu.registerH = Cpu.registerB;\n            return 4;\n        case 0x61:\n            // LD H,C\n            // 1 4\n            Cpu.registerH = Cpu.registerC;\n            return 4;\n        case 0x62:\n            // LD H,D\n            // 1 4\n            Cpu.registerH = Cpu.registerD;\n            return 4;\n        case 0x63:\n            // LD H,E\n            // 1 4\n            Cpu.registerH = Cpu.registerE;\n            return 4;\n        case 0x64:\n            // LD H,H\n            // 1 4\n            Cpu.registerH = Cpu.registerH;\n            return 4;\n        case 0x65:\n            // LD H,L\n            // 1 4\n            Cpu.registerH = Cpu.registerL;\n            return 4;\n        case 0x66:\n            // LD H,(HL)\n            // 1 8\n            // 4 cycles\n            Cpu.registerH = eightBitLoadSyncCycles(concatenateBytes(Cpu.registerH, Cpu.registerL));\n            return 4;\n        case 0x67:\n            // LD H,A\n            // 1 4\n            Cpu.registerH = Cpu.registerA;\n            return 4;\n        case 0x68:\n            // LD L,B\n            // 1 4\n            Cpu.registerL = Cpu.registerB;\n            return 4;\n        case 0x69:\n            // LD L,C\n            // 1 4\n            Cpu.registerL = Cpu.registerC;\n            return 4;\n        case 0x6a:\n            // LD L,D\n            // 1 4\n            Cpu.registerL = Cpu.registerD;\n            return 4;\n        case 0x6b:\n            // LD L,E\n            // 1 4\n            Cpu.registerL = Cpu.registerE;\n            return 4;\n        case 0x6c:\n            // LD L,H\n            // 1 4\n            Cpu.registerL = Cpu.registerH;\n            return 4;\n        case 0x6d:\n            // LD L,L\n            // 1 4\n            Cpu.registerL = Cpu.registerL;\n            return 4;\n        case 0x6e:\n            // LD L,(HL)\n            // 1 8\n            // 4 cycles\n            Cpu.registerL = eightBitLoadSyncCycles(concatenateBytes(Cpu.registerH, Cpu.registerL));\n            return 4;\n        case 0x6f:\n            // LD L,A\n            // 1 4\n            Cpu.registerL = Cpu.registerA;\n            return 4;\n    }\n    return -1;\n}\nfunction handleOpcode7x(opcode) {\n    switch (opcode) {\n        case 0x70:\n            // LD (HL),B\n            // 1 8\n            // 4 cycles\n            eightBitStoreSyncCycles(concatenateBytes(Cpu.registerH, Cpu.registerL), Cpu.registerB);\n            return 4;\n        case 0x71:\n            // LD (HL),C\n            // 1 8\n            // 4 cycles\n            eightBitStoreSyncCycles(concatenateBytes(Cpu.registerH, Cpu.registerL), Cpu.registerC);\n            return 4;\n        case 0x72:\n            // LD (HL),D\n            // 1 8\n            // 4 cycles\n            eightBitStoreSyncCycles(concatenateBytes(Cpu.registerH, Cpu.registerL), Cpu.registerD);\n            return 4;\n        case 0x73:\n            // LD (HL),E\n            // 1 8\n            // 4 cycles\n            eightBitStoreSyncCycles(concatenateBytes(Cpu.registerH, Cpu.registerL), Cpu.registerE);\n            return 4;\n        case 0x74:\n            // LD (HL),H\n            // 1 8\n            // 4 cycles\n            eightBitStoreSyncCycles(concatenateBytes(Cpu.registerH, Cpu.registerL), Cpu.registerH);\n            return 4;\n        case 0x75:\n            // LD (HL),L\n            // 1 8\n            // 4 cycles\n            eightBitStoreSyncCycles(concatenateBytes(Cpu.registerH, Cpu.registerL), Cpu.registerL);\n            return 4;\n        case 0x76:\n            // HALT\n            // 1 4\n            // Enter CPU very low power mode\n            // Meaning Don't Decode anymore opcodes until an interrupt occurs\n            // Still need to do timers and things\n            // Can't Halt during an HDMA\n            // https://gist.github.com/drhelius/3394856\n            if (!Memory.isHblankHdmaActive) {\n                Cpu.enableHalt();\n            }\n            return 4;\n        case 0x77:\n            // LD (HL),A\n            // 1 8\n            // 4 cycles\n            eightBitStoreSyncCycles(concatenateBytes(Cpu.registerH, Cpu.registerL), Cpu.registerA);\n            return 4;\n        case 0x78:\n            // LD A,B\n            // 1 4\n            Cpu.registerA = Cpu.registerB;\n            return 4;\n        case 0x79:\n            // LD A,C\n            // 1 4\n            Cpu.registerA = Cpu.registerC;\n            return 4;\n        case 0x7a:\n            // LD A,D\n            // 1 4\n            Cpu.registerA = Cpu.registerD;\n            return 4;\n        case 0x7b:\n            // LD A,E\n            // 1 4\n            Cpu.registerA = Cpu.registerE;\n            return 4;\n        case 0x7c:\n            // LD A,H\n            // 1 4\n            Cpu.registerA = Cpu.registerH;\n            return 4;\n        case 0x7d:\n            // LD A,L\n            // 1 4\n            Cpu.registerA = Cpu.registerL;\n            return 4;\n        case 0x7e:\n            // LD A,(HL)\n            // 1 8\n            // NOTE: Thanks to @binji for catching that this should be 8 cycles, not 4\n            // 4 cycles\n            Cpu.registerA = eightBitLoadSyncCycles(concatenateBytes(Cpu.registerH, Cpu.registerL));\n            return 4;\n        case 0x7f:\n            // LD A,A\n            // 1 4\n            // Do Nothing\n            return 4;\n    }\n    return -1;\n}\nfunction handleOpcode8x(opcode) {\n    switch (opcode) {\n        case 0x80:\n            // ADD A,B\n            // 1 4\n            // Z 0 H C\n            addARegister(Cpu.registerB);\n            return 4;\n        case 0x81:\n            // ADD A,C\n            // 1 4\n            // Z 0 H C\n            addARegister(Cpu.registerC);\n            return 4;\n        case 0x82:\n            // ADD A,D\n            // 1 4\n            // Z 0 H C\n            addARegister(Cpu.registerD);\n            return 4;\n        case 0x83:\n            // ADD A,E\n            // 1 4\n            // Z 0 H C\n            addARegister(Cpu.registerE);\n            return 4;\n        case 0x84:\n            // ADD A,H\n            // 1 4\n            // Z 0 H C\n            addARegister(Cpu.registerH);\n            return 4;\n        case 0x85:\n            // ADD A,L\n            // 1 4\n            // Z 0 H C\n            addARegister(Cpu.registerL);\n            return 4;\n        case 0x86:\n            // ADD A,(HL)\n            // 1 8\n            // Z 0 H C\n            // 4 cycles\n            var valueAtHL6 = eightBitLoadSyncCycles(concatenateBytes(Cpu.registerH, Cpu.registerL));\n            addARegister(valueAtHL6);\n            return 4;\n        case 0x87:\n            // ADD A,A\n            // 1 4\n            // Z 0 H C\n            addARegister(Cpu.registerA);\n            return 4;\n        case 0x88:\n            // ADC A,B\n            // 1 4\n            // Z 0 H C\n            addAThroughCarryRegister(Cpu.registerB);\n            return 4;\n        case 0x89:\n            // ADC A,C\n            // 1 4\n            // Z 0 H C\n            addAThroughCarryRegister(Cpu.registerC);\n            return 4;\n        case 0x8a:\n            // ADC A,D\n            // 1 4\n            // Z 0 H C\n            addAThroughCarryRegister(Cpu.registerD);\n            return 4;\n        case 0x8b:\n            // ADC A,E\n            // 1 4\n            // Z 0 H C\n            addAThroughCarryRegister(Cpu.registerE);\n            return 4;\n        case 0x8c:\n            // ADC A,H\n            // 1 4\n            // Z 0 H C\n            addAThroughCarryRegister(Cpu.registerH);\n            return 4;\n        case 0x8d:\n            // ADC A,L\n            // 1 4\n            // Z 0 H C\n            addAThroughCarryRegister(Cpu.registerL);\n            return 4;\n        case 0x8e:\n            // ADC A,(HL)\n            // 1 8\n            // Z 0 H C\n            // 4 cycles\n            var valueAtHLE = eightBitLoadSyncCycles(concatenateBytes(Cpu.registerH, Cpu.registerL));\n            addAThroughCarryRegister(valueAtHLE);\n            return 4;\n        case 0x8f:\n            // ADC A,A\n            // 1 4\n            // Z 0 H C\n            addAThroughCarryRegister(Cpu.registerA);\n            return 4;\n    }\n    return -1;\n}\nfunction handleOpcode9x(opcode) {\n    switch (opcode) {\n        case 0x90:\n            // SUB B\n            // 1  4\n            // Z 1 H C\n            subARegister(Cpu.registerB);\n            return 4;\n        case 0x91:\n            // SUB C\n            // 1  4\n            // Z 1 H C\n            subARegister(Cpu.registerC);\n            return 4;\n        case 0x92:\n            // SUB D\n            // 1  4\n            // Z 1 H C\n            subARegister(Cpu.registerD);\n            return 4;\n        case 0x93:\n            // SUB E\n            // 1  4\n            // Z 1 H C\n            subARegister(Cpu.registerE);\n            return 4;\n        case 0x94:\n            // SUB H\n            // 1  4\n            // Z 1 H C\n            subARegister(Cpu.registerH);\n            return 4;\n        case 0x95:\n            // SUB L\n            // 1  4\n            // Z 1 H C\n            subARegister(Cpu.registerL);\n            return 4;\n        case 0x96:\n            // SUB (HL)\n            // 1  8\n            // Z 1 H C\n            // 4 cycles\n            var valueAtHL6 = eightBitLoadSyncCycles(concatenateBytes(Cpu.registerH, Cpu.registerL));\n            subARegister(valueAtHL6);\n            return 4;\n        case 0x97:\n            // SUB A\n            // 1  4\n            // Z 1 H C\n            subARegister(Cpu.registerA);\n            return 4;\n        case 0x98:\n            // SBC A,B\n            // 1  4\n            // Z 1 H C\n            subAThroughCarryRegister(Cpu.registerB);\n            return 4;\n        case 0x99:\n            // SBC A,C\n            // 1  4\n            // Z 1 H C\n            subAThroughCarryRegister(Cpu.registerC);\n            return 4;\n        case 0x9a:\n            // SBC A,D\n            // 1  4\n            // Z 1 H C\n            subAThroughCarryRegister(Cpu.registerD);\n            return 4;\n        case 0x9b:\n            // SBC A,E\n            // 1  4\n            // Z 1 H C\n            subAThroughCarryRegister(Cpu.registerE);\n            return 4;\n        case 0x9c:\n            // SBC A,H\n            // 1  4\n            // Z 1 H C\n            subAThroughCarryRegister(Cpu.registerH);\n            return 4;\n        case 0x9d:\n            // SBC A,L\n            // 1  4\n            // Z 1 H C\n            subAThroughCarryRegister(Cpu.registerL);\n            return 4;\n        case 0x9e:\n            // SBC A,(HL)\n            // 1  8\n            // Z 1 H C\n            // 4 cycles\n            var valueAtHLE = eightBitLoadSyncCycles(concatenateBytes(Cpu.registerH, Cpu.registerL));\n            subAThroughCarryRegister(valueAtHLE);\n            return 4;\n        case 0x9f:\n            // SBC A,A\n            // 1  4\n            // Z 1 H C\n            subAThroughCarryRegister(Cpu.registerA);\n            return 4;\n    }\n    return -1;\n}\nfunction handleOpcodeAx(opcode) {\n    switch (opcode) {\n        case 0xa0:\n            // AND B\n            // 1  4\n            // Z 0 1 0\n            andARegister(Cpu.registerB);\n            return 4;\n        case 0xa1:\n            // AND C\n            // 1  4\n            // Z 0 1 0\n            andARegister(Cpu.registerC);\n            return 4;\n        case 0xa2:\n            // AND D\n            // 1  4\n            // Z 0 1 0\n            andARegister(Cpu.registerD);\n            return 4;\n        case 0xa3:\n            // AND E\n            // 1  4\n            // Z 0 1 0\n            andARegister(Cpu.registerE);\n            return 4;\n        case 0xa4:\n            // AND H\n            // 1  4\n            // Z 0 1 0\n            andARegister(Cpu.registerH);\n            return 4;\n        case 0xa5:\n            // AND L\n            // 1  4\n            // Z 0 1 0\n            andARegister(Cpu.registerL);\n            return 4;\n        case 0xa6:\n            // AND (HL)\n            // 1  8\n            // Z 0 1 0\n            // 4 cycles\n            var valueAtHL6 = eightBitLoadSyncCycles(concatenateBytes(Cpu.registerH, Cpu.registerL));\n            andARegister(valueAtHL6);\n            return 4;\n        case 0xa7:\n            // AND A\n            // 1  4\n            // Z 0 1 0\n            // NOTE: & Yourself, does nothing\n            andARegister(Cpu.registerA);\n            return 4;\n        case 0xa8:\n            // XOR B\n            // 1  4\n            // Z 0 0 0\n            xorARegister(Cpu.registerB);\n            return 4;\n        case 0xa9:\n            // XOR C\n            // 1  4\n            // Z 0 0 0\n            xorARegister(Cpu.registerC);\n            return 4;\n        case 0xaa:\n            // XOR D\n            // 1  4\n            // Z 0 0 0\n            xorARegister(Cpu.registerD);\n            return 4;\n        case 0xab:\n            // XOR E\n            // 1  4\n            // Z 0 0 0\n            xorARegister(Cpu.registerE);\n            return 4;\n        case 0xac:\n            // XOR H\n            // 1  4\n            // Z 0 0 0\n            xorARegister(Cpu.registerH);\n            return 4;\n        case 0xad:\n            // XOR L\n            // 1  4\n            // Z 0 0 0\n            xorARegister(Cpu.registerL);\n            return 4;\n        case 0xae:\n            // XOR (HL)\n            // 1  8\n            // Z 0 0 0\n            // 4 cycles\n            var valueAtHLE = eightBitLoadSyncCycles(concatenateBytes(Cpu.registerH, Cpu.registerL));\n            xorARegister(valueAtHLE);\n            return 4;\n        case 0xaf:\n            // XOR A\n            // 1  4\n            // Z 0 0 0\n            xorARegister(Cpu.registerA);\n            return 4;\n    }\n    return -1;\n}\nfunction handleOpcodeBx(opcode) {\n    switch (opcode) {\n        case 0xb0:\n            // OR B\n            // 1  4\n            // Z 0 0 0\n            orARegister(Cpu.registerB);\n            return 4;\n        case 0xb1:\n            // OR C\n            // 1  4\n            // Z 0 0 0\n            orARegister(Cpu.registerC);\n            return 4;\n        case 0xb2:\n            // OR D\n            // 1  4\n            // Z 0 0 0\n            orARegister(Cpu.registerD);\n            return 4;\n        case 0xb3:\n            // OR E\n            // 1  4\n            // Z 0 0 0\n            orARegister(Cpu.registerE);\n            return 4;\n        case 0xb4:\n            // OR H\n            // 1  4\n            // Z 0 0 0\n            orARegister(Cpu.registerH);\n            return 4;\n        case 0xb5:\n            // OR L\n            // 1  4\n            // Z 0 0 0\n            orARegister(Cpu.registerL);\n            return 4;\n        case 0xb6:\n            // OR (HL)\n            // 1  8\n            // Z 0 0 0\n            // 4 cycles\n            var valueAtHL6 = eightBitLoadSyncCycles(concatenateBytes(Cpu.registerH, Cpu.registerL));\n            orARegister(valueAtHL6);\n            return 4;\n        case 0xb7:\n            // OR A\n            // 1  4\n            // Z 0 0 0\n            orARegister(Cpu.registerA);\n            return 4;\n        case 0xb8:\n            // CP B\n            // 1  4\n            // Z 1 H C\n            cpARegister(Cpu.registerB);\n            return 4;\n        case 0xb9:\n            // CP C\n            // 1  4\n            // Z 1 H C\n            cpARegister(Cpu.registerC);\n            return 4;\n        case 0xba:\n            // CP D\n            // 1  4\n            // Z 1 H C\n            cpARegister(Cpu.registerD);\n            return 4;\n        case 0xbb:\n            // CP E\n            // 1  4\n            // Z 1 H C\n            cpARegister(Cpu.registerE);\n            return 4;\n        case 0xbc:\n            // CP H\n            // 1  4\n            // Z 1 H C\n            cpARegister(Cpu.registerH);\n            return 4;\n        case 0xbd:\n            // CP L\n            // 1  4\n            // Z 1 H C\n            cpARegister(Cpu.registerL);\n            return 4;\n        case 0xbe:\n            // CP (HL)\n            // 1  8\n            // Z 1 H C\n            // 4 cycles\n            var valueAtHLE = eightBitLoadSyncCycles(concatenateBytes(Cpu.registerH, Cpu.registerL));\n            cpARegister(valueAtHLE);\n            return 4;\n        case 0xbf:\n            // CP A\n            // 1  4\n            // Z 1 H C\n            cpARegister(Cpu.registerA);\n            return 4;\n    }\n    return -1;\n}\nfunction handleOpcodeCx(opcode) {\n    switch (opcode) {\n        case 0xc0: {\n            // RET NZ\n            // 1  20/8\n            if (getZeroFlag$$1() === 0) {\n                // 8 cycles\n                var stackPointer = Cpu.stackPointer;\n                Cpu.programCounter = sixteenBitLoadSyncCycles(stackPointer);\n                Cpu.stackPointer = u16Portable(stackPointer + 2);\n                return 12;\n            }\n            else {\n                return 8;\n            }\n        }\n        case 0xc1: {\n            // POP BC\n            // 1  12\n            // 8 cycles\n            var registerBC1 = sixteenBitLoadSyncCycles(Cpu.stackPointer);\n            Cpu.stackPointer = u16Portable(Cpu.stackPointer + 2);\n            Cpu.registerB = splitHighByte(registerBC1);\n            Cpu.registerC = splitLowByte(registerBC1);\n            return 4;\n        }\n        case 0xc2: {\n            // JP NZ,a16\n            // 3  16/12\n            if (getZeroFlag$$1() === 0) {\n                // 8 cycles\n                Cpu.programCounter = getConcatenatedDataByte();\n                return 8;\n            }\n            else {\n                Cpu.programCounter = u16Portable(Cpu.programCounter + 2);\n                return 12;\n            }\n        }\n        case 0xc3: {\n            // JP a16\n            // 3  16\n            // 8 cycles\n            Cpu.programCounter = getConcatenatedDataByte();\n            return 8;\n        }\n        case 0xc4: {\n            // CALL NZ,a16\n            // 3  24/12\n            if (getZeroFlag$$1() === 0) {\n                var stackPointer = u16Portable(Cpu.stackPointer - 2);\n                Cpu.stackPointer = stackPointer;\n                // 8 cycles\n                sixteenBitStoreSyncCycles(stackPointer, u16Portable(Cpu.programCounter + 2));\n                // 8 cycles\n                Cpu.programCounter = getConcatenatedDataByte();\n                return 8;\n            }\n            else {\n                Cpu.programCounter = u16Portable(Cpu.programCounter + 2);\n                return 12;\n            }\n        }\n        case 0xc5: {\n            // PUSH BC\n            // 1  16\n            var stackPointer = u16Portable(Cpu.stackPointer - 2);\n            Cpu.stackPointer = stackPointer;\n            // 8 cycles\n            sixteenBitStoreSyncCycles(stackPointer, concatenateBytes(Cpu.registerB, Cpu.registerC));\n            return 8;\n        }\n        case 0xc6: {\n            // ADD A,d8\n            // 2 8\n            // Z 0 H C\n            // 4 cycles\n            addARegister(getDataByteOne());\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            return 4;\n        }\n        case 0xc7: {\n            // RST 00H\n            // 1 16\n            var stackPointer = u16Portable(Cpu.stackPointer - 2);\n            Cpu.stackPointer = stackPointer;\n            // 8 cycles\n            sixteenBitStoreSyncCycles(stackPointer, Cpu.programCounter);\n            Cpu.programCounter = 0x00;\n            return 8;\n        }\n        case 0xc8: {\n            // RET Z\n            // 1  20/8\n            if (getZeroFlag$$1() === 1) {\n                // 8 cycles\n                var stackPointer = Cpu.stackPointer;\n                Cpu.programCounter = sixteenBitLoadSyncCycles(stackPointer);\n                Cpu.stackPointer = u16Portable(stackPointer + 2);\n                return 12;\n            }\n            else {\n                return 8;\n            }\n        }\n        case 0xc9: {\n            // RET\n            // 1 16\n            // 8 cycles\n            var stackPointer = Cpu.stackPointer;\n            Cpu.programCounter = sixteenBitLoadSyncCycles(stackPointer);\n            Cpu.stackPointer = u16Portable(stackPointer + 2);\n            return 8;\n        }\n        case 0xca: {\n            // JP Z,a16\n            // 3 16/12\n            if (getZeroFlag$$1() === 1) {\n                // 8 cycles\n                Cpu.programCounter = getConcatenatedDataByte();\n                return 8;\n            }\n            else {\n                Cpu.programCounter = u16Portable(Cpu.programCounter + 2);\n                return 12;\n            }\n        }\n        case 0xcb: {\n            // PREFIX CB\n            // 1  4\n            // 4 cycles\n            var cbCycles = handleCbOpcode(getDataByteOne());\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            return cbCycles;\n        }\n        case 0xcc: {\n            // CALL Z,a16\n            // 3  24/12\n            if (getZeroFlag$$1() === 1) {\n                var stackPointer = u16Portable(Cpu.stackPointer - 2);\n                Cpu.stackPointer = stackPointer;\n                // 8 cycles\n                sixteenBitStoreSyncCycles(stackPointer, Cpu.programCounter + 2);\n                // 8 cycles\n                Cpu.programCounter = getConcatenatedDataByte();\n                return 8;\n            }\n            else {\n                Cpu.programCounter = u16Portable(Cpu.programCounter + 2);\n                return 12;\n            }\n        }\n        case 0xcd: {\n            // CALL a16\n            // 3  24\n            var stackPointer = u16Portable(Cpu.stackPointer - 2);\n            Cpu.stackPointer = stackPointer;\n            // 8 cycles\n            sixteenBitStoreSyncCycles(stackPointer, u16Portable(Cpu.programCounter + 2));\n            // 8 cycles\n            Cpu.programCounter = getConcatenatedDataByte();\n            return 8;\n        }\n        case 0xce: {\n            // ADC A,d8\n            // 2  8\n            // Z 0 H C\n            // 4 cycles\n            addAThroughCarryRegister(getDataByteOne());\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            return 4;\n        }\n        case 0xcf: {\n            // RST 08H\n            // 1 16\n            var stackPointer = u16Portable(Cpu.stackPointer - 2);\n            Cpu.stackPointer = stackPointer;\n            // 8 cycles\n            sixteenBitStoreSyncCycles(stackPointer, Cpu.programCounter);\n            Cpu.programCounter = 0x08;\n            return 8;\n        }\n    }\n    return -1;\n}\nfunction handleOpcodeDx(opcode) {\n    switch (opcode) {\n        case 0xd0: {\n            // RET NC\n            // 1  20/8\n            if (getCarryFlag$$1() === 0) {\n                // 8 cycles\n                var stackPointer = Cpu.stackPointer;\n                Cpu.programCounter = sixteenBitLoadSyncCycles(stackPointer);\n                Cpu.stackPointer = u16Portable(stackPointer + 2);\n                return 12;\n            }\n            else {\n                return 8;\n            }\n        }\n        case 0xd1: {\n            // POP DE\n            // 1  12\n            // 8 cycles\n            var stackPointer = Cpu.stackPointer;\n            var registerDE1 = sixteenBitLoadSyncCycles(stackPointer);\n            Cpu.stackPointer = u16Portable(stackPointer + 2);\n            Cpu.registerD = splitHighByte(registerDE1);\n            Cpu.registerE = splitLowByte(registerDE1);\n            return 4;\n        }\n        case 0xd2: {\n            // JP NC,a16\n            // 3  16/12\n            if (getCarryFlag$$1() === 0) {\n                // 8 cycles\n                Cpu.programCounter = getConcatenatedDataByte();\n                return 8;\n            }\n            else {\n                Cpu.programCounter = u16Portable(Cpu.programCounter + 2);\n                return 12;\n            }\n        }\n        /* No Opcode for: 0xD3 */\n        case 0xd4: {\n            // CALL NC,a16\n            // 3  24/12\n            if (getCarryFlag$$1() === 0) {\n                var stackPointer = u16Portable(Cpu.stackPointer - 2);\n                Cpu.stackPointer = stackPointer;\n                // 8 cycles\n                sixteenBitStoreSyncCycles(stackPointer, Cpu.programCounter + 2);\n                // 8 cycles\n                Cpu.programCounter = getConcatenatedDataByte();\n                return 8;\n            }\n            else {\n                Cpu.programCounter = u16Portable(Cpu.programCounter + 2);\n                return 12;\n            }\n        }\n        case 0xd5: {\n            // PUSH DE\n            // 1 16\n            var stackPointer = u16Portable(Cpu.stackPointer - 2);\n            Cpu.stackPointer = stackPointer;\n            // 8 cycles\n            sixteenBitStoreSyncCycles(stackPointer, concatenateBytes(Cpu.registerD, Cpu.registerE));\n            return 8;\n        }\n        case 0xd6: {\n            // SUB d8\n            // 2  8\n            // Z 1 H C\n            // 4 cycles\n            subARegister(getDataByteOne());\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            return 4;\n        }\n        case 0xd7: {\n            // RST 10H\n            // 1 16\n            var stackPointer = u16Portable(Cpu.stackPointer - 2);\n            Cpu.stackPointer = stackPointer;\n            // 8 cycles\n            sixteenBitStoreSyncCycles(stackPointer, Cpu.programCounter);\n            Cpu.programCounter = 0x10;\n            return 8;\n        }\n        case 0xd8: {\n            // RET C\n            // 1  20/8\n            if (getCarryFlag$$1() === 1) {\n                var stackPointer = Cpu.stackPointer;\n                // 8 cycles\n                Cpu.programCounter = sixteenBitLoadSyncCycles(stackPointer);\n                Cpu.stackPointer = u16Portable(stackPointer + 2);\n                return 12;\n            }\n            else {\n                return 8;\n            }\n        }\n        case 0xd9: {\n            // RETI\n            // 1  16\n            var stackPointer = Cpu.stackPointer;\n            // 8 cycles\n            Cpu.programCounter = sixteenBitLoadSyncCycles(stackPointer);\n            // Enable interrupts\n            setInterrupts(true);\n            Cpu.stackPointer = u16Portable(stackPointer + 2);\n            return 8;\n        }\n        case 0xda: {\n            // JP C,a16\n            // 3 16/12\n            if (getCarryFlag$$1() === 1) {\n                // 8 cycles\n                Cpu.programCounter = getConcatenatedDataByte();\n                return 8;\n            }\n            else {\n                Cpu.programCounter = u16Portable(Cpu.programCounter + 2);\n                return 12;\n            }\n        }\n        /* No Opcode for: 0xDB */\n        case 0xdc: {\n            // CALL C,a16\n            // 3  24/12\n            if (getCarryFlag$$1() === 1) {\n                var stackPointer = u16Portable(Cpu.stackPointer - 2);\n                Cpu.stackPointer = stackPointer;\n                // 8 cycles\n                sixteenBitStoreSyncCycles(stackPointer, u16Portable(Cpu.programCounter + 2));\n                // 8 cycles\n                Cpu.programCounter = getConcatenatedDataByte();\n                return 8;\n            }\n            else {\n                Cpu.programCounter = u16Portable(Cpu.programCounter + 2);\n                return 12;\n            }\n        }\n        /* No Opcode for: 0xDD */\n        case 0xde: {\n            // SBC A,d8\n            // 2 8\n            // Z 1 H C\n            // 4 cycles\n            subAThroughCarryRegister(getDataByteOne());\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            return 4;\n        }\n        case 0xdf: {\n            // RST 18H\n            // 1 16\n            var stackPointer = u16Portable(Cpu.stackPointer - 2);\n            Cpu.stackPointer = stackPointer;\n            // 8 cycles\n            sixteenBitStoreSyncCycles(stackPointer, Cpu.programCounter);\n            Cpu.programCounter = 0x18;\n            return 8;\n        }\n    }\n    return -1;\n}\nfunction handleOpcodeEx(opcode) {\n    switch (opcode) {\n        case 0xe0: {\n            // LDH (a8),A\n            // 2  12\n            // Store value in high RAM ($FF00 + a8)\n            // 4 cycles\n            var largeDataByteOne = getDataByteOne();\n            // 4 cycles\n            eightBitStoreSyncCycles(0xff00 + largeDataByteOne, Cpu.registerA);\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            return 4;\n        }\n        case 0xe1: {\n            // POP HL\n            // 1  12\n            // 8 cycles\n            var stackPointer = Cpu.stackPointer;\n            var registerHL1 = sixteenBitLoadSyncCycles(stackPointer);\n            Cpu.stackPointer = u16Portable(stackPointer + 2);\n            Cpu.registerH = splitHighByte(registerHL1);\n            Cpu.registerL = splitLowByte(registerHL1);\n            return 4;\n        }\n        case 0xe2: {\n            // LD (C),A\n            // 1  8\n            // NOTE: Table says 2 Program counter,\n            // But stepping through the boot rom, should be one\n            // Also should change 0xF2\n            // Store value in high RAM ($FF00 + register c)\n            // 4 cycles\n            eightBitStoreSyncCycles(0xff00 + Cpu.registerC, Cpu.registerA);\n            return 4;\n        }\n        /* No Opcode for: 0xE3, 0xE4 */\n        case 0xe5: {\n            // PUSH HL\n            // 1 16\n            var stackPointer = u16Portable(Cpu.stackPointer - 2);\n            Cpu.stackPointer = stackPointer;\n            // 8 cycles\n            sixteenBitStoreSyncCycles(stackPointer, concatenateBytes(Cpu.registerH, Cpu.registerL));\n            return 8;\n        }\n        case 0xe6: {\n            // AND d8\n            // 2  8\n            // Z 0 1 0\n            // 4 cycles\n            andARegister(getDataByteOne());\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            return 4;\n        }\n        case 0xe7: {\n            // RST 20H\n            // 1 16\n            var stackPointer = u16Portable(Cpu.stackPointer - 2);\n            Cpu.stackPointer = stackPointer;\n            // 8 cycles\n            sixteenBitStoreSyncCycles(stackPointer, Cpu.programCounter);\n            Cpu.programCounter = 0x20;\n            return 8;\n        }\n        case 0xe8: {\n            // ADD SP, r8\n            // 2 16\n            // 0 0 H C\n            // NOTE: Discoved dataByte is signed\n            // 4 cycles\n            var signedDataByteOne = i8Portable(getDataByteOne());\n            checkAndSetSixteenBitFlagsAddOverflow(Cpu.stackPointer, signedDataByteOne, true);\n            Cpu.stackPointer = u16Portable(Cpu.stackPointer + signedDataByteOne);\n            setZeroFlag$$1(0);\n            setSubtractFlag(0);\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            return 12;\n        }\n        case 0xe9: {\n            // JP HL\n            // 1 4\n            Cpu.programCounter = concatenateBytes(Cpu.registerH, Cpu.registerL);\n            return 4;\n        }\n        case 0xea: {\n            // LD (a16),A\n            // 3 16\n            // 12 cycles, 4 from store, 8 from concatenated data byte\n            eightBitStoreSyncCycles(getConcatenatedDataByte(), Cpu.registerA);\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 2);\n            return 4;\n        }\n        /* No Opcode for: 0xEB, 0xEC, 0xED */\n        case 0xee: {\n            // XOR d8\n            // 2 8\n            // Z 0 0 0\n            // 4 cycles\n            xorARegister(getDataByteOne());\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            return 4;\n        }\n        case 0xef: {\n            // RST 28H\n            // 1 16\n            var stackPointer = u16Portable(Cpu.stackPointer - 2);\n            Cpu.stackPointer = stackPointer;\n            // 8 cycles\n            sixteenBitStoreSyncCycles(stackPointer, Cpu.programCounter);\n            Cpu.programCounter = 0x28;\n            return 8;\n        }\n    }\n    return -1;\n}\nfunction handleOpcodeFx(opcode) {\n    switch (opcode) {\n        case 0xf0: {\n            // LDH A,(a8)\n            // 2 12\n            // 4 cycles\n            var largeDataByteOne = getDataByteOne();\n            // 4 cycles\n            Cpu.registerA = u8Portable(eightBitLoadSyncCycles(0xff00 + largeDataByteOne));\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            return 4;\n        }\n        case 0xf1: {\n            // POP AF\n            // 1 12\n            // Z N H C (But No work require, flags are already set)\n            // 8 cycles\n            var stackPointer = Cpu.stackPointer;\n            var registerAF1 = sixteenBitLoadSyncCycles(stackPointer);\n            Cpu.stackPointer = u16Portable(stackPointer + 2);\n            Cpu.registerA = splitHighByte(registerAF1);\n            Cpu.registerF = splitLowByte(registerAF1);\n            return 4;\n        }\n        case 0xf2: {\n            // LD A,(C)\n            // 1 8\n            // 4 cycles\n            Cpu.registerA = u8Portable(eightBitLoadSyncCycles(0xff00 + Cpu.registerC));\n            return 4;\n        }\n        case 0xf3: {\n            // DI\n            // 1 4\n            setInterrupts(false);\n            return 4;\n        }\n        /* No Opcode for: 0xF4 */\n        case 0xf5: {\n            // PUSH AF\n            // 1 16\n            var stackPointer = u16Portable(Cpu.stackPointer - 2);\n            Cpu.stackPointer = stackPointer;\n            // 8 cycles\n            sixteenBitStoreSyncCycles(stackPointer, concatenateBytes(Cpu.registerA, Cpu.registerF));\n            return 8;\n        }\n        case 0xf6: {\n            // OR d8\n            // 2 8\n            // Z 0 0 0\n            // 4 cycles\n            orARegister(getDataByteOne());\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            return 4;\n        }\n        case 0xf7: {\n            // RST 30H\n            // 1 16\n            var stackPointer = u16Portable(Cpu.stackPointer - 2);\n            Cpu.stackPointer = stackPointer;\n            // 8 cycles\n            sixteenBitStoreSyncCycles(stackPointer, Cpu.programCounter);\n            Cpu.programCounter = 0x30;\n            return 8;\n        }\n        case 0xf8: {\n            // LD HL,SP+r8\n            // 2 12\n            // 0 0 H C\n            // NOTE: Discoved dataByte is signed\n            // 4 cycles\n            var signedDataByteOne = i8Portable(getDataByteOne());\n            var stackPointer = Cpu.stackPointer;\n            // First, let's handle flags\n            setZeroFlag$$1(0);\n            setSubtractFlag(0);\n            checkAndSetSixteenBitFlagsAddOverflow(stackPointer, signedDataByteOne, true);\n            var registerHL = u16Portable(stackPointer + signedDataByteOne);\n            Cpu.registerH = splitHighByte(registerHL);\n            Cpu.registerL = splitLowByte(registerHL);\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            return 8;\n        }\n        case 0xf9: {\n            // LD SP,HL\n            // 1 8\n            Cpu.stackPointer = concatenateBytes(Cpu.registerH, Cpu.registerL);\n            return 8;\n        }\n        case 0xfa: {\n            // LD A,(a16)\n            // 3 16\n            // 12 cycles, 4 from load, 8 from concatenated data byte\n            Cpu.registerA = eightBitLoadSyncCycles(getConcatenatedDataByte());\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 2);\n            return 4;\n        }\n        case 0xfb: {\n            // EI\n            // 1 4\n            setInterrupts(true);\n            return 4;\n        }\n        /* No Opcode for: 0xFC, 0xFD */\n        case 0xfe: {\n            // CP d8\n            // 2 8\n            // Z 1 H C\n            // 4 cycles\n            cpARegister(getDataByteOne());\n            Cpu.programCounter = u16Portable(Cpu.programCounter + 1);\n            return 4;\n        }\n        case 0xff: {\n            // RST 38H\n            // 1 16\n            var stackPointer = u16Portable(Cpu.stackPointer - 2);\n            Cpu.stackPointer = stackPointer;\n            // 8 cycles\n            sixteenBitStoreSyncCycles(stackPointer, Cpu.programCounter);\n            Cpu.programCounter = 0x38;\n            return 8;\n        }\n    }\n    return -1;\n}\n\n// NOTE: Code is very verbose, and will have some copy pasta'd lines.\n\n// Syncing and Tracking executed cycles\nvar Cycles = /** @class */ (function () {\n    function Cycles() {\n    }\n    // An even number below the max 32 bit integer\n    Cycles.cyclesPerCycleSet = 2000000000;\n    Cycles.cycleSets = 0;\n    Cycles.cycles = 0;\n    return Cycles;\n}());\nfunction getCyclesPerCycleSet() {\n    return Cycles.cyclesPerCycleSet;\n}\nfunction getCycleSets() {\n    return Cycles.cycleSets;\n}\nfunction getCycles() {\n    return Cycles.cycles;\n}\n// Inlined because closure compiler inlines\nfunction trackCyclesRan(numberOfCycles) {\n    var cycles = Cycles.cycles;\n    cycles += numberOfCycles;\n    if (cycles >= Cycles.cyclesPerCycleSet) {\n        Cycles.cycleSets += 1;\n        cycles -= Cycles.cyclesPerCycleSet;\n    }\n    Cycles.cycles = cycles;\n}\n// Inlined because closure compiler inlines\nfunction resetCycles() {\n    Cycles.cyclesPerCycleSet = 2000000000;\n    Cycles.cycleSets = 0;\n    Cycles.cycles = 0;\n}\n// Sync other GB Components with the number of cycles\nfunction syncCycles(numberOfCycles) {\n    // Check if we did a DMA TRansfer, if we did add the cycles\n    if (Memory.DMACycles > 0) {\n        numberOfCycles += Memory.DMACycles;\n        Memory.DMACycles = 0;\n    }\n    // Finally, Add our number of cycles to the CPU Cycles\n    Cpu.currentCycles += numberOfCycles;\n    // Check other Gameboy components\n    if (!Cpu.isStopped) {\n        if (Config.graphicsBatchProcessing) {\n            // Need to do this, since a lot of things depend on the scanline\n            // Batch processing will simply return if the number of cycles is too low\n            Graphics.currentCycles += numberOfCycles;\n            batchProcessGraphics();\n        }\n        else {\n            updateGraphics(numberOfCycles);\n        }\n        if (Config.audioBatchProcessing) {\n            Sound.currentCycles += numberOfCycles;\n            batchProcessAudio();\n        }\n        else {\n            updateSound(numberOfCycles);\n        }\n        updateSerial(numberOfCycles);\n    }\n    if (Config.timersBatchProcessing) {\n        // Batch processing will simply return if the number of cycles is too low\n        Timers.currentCycles += numberOfCycles;\n        batchProcessTimers();\n    }\n    else {\n        updateTimers(numberOfCycles);\n    }\n    trackCyclesRan(numberOfCycles);\n}\n\n// Functions involving executing/running the emulator after initializtion\nvar Execute = /** @class */ (function () {\n    function Execute() {\n    }\n    // An even number bewlow the max 32 bit integer\n    Execute.stepsPerStepSet = 2000000000;\n    Execute.stepSets = 0;\n    Execute.steps = 0;\n    // Response Codes from Execute Conditions\n    Execute.RESPONSE_CONDITION_ERROR = -1;\n    Execute.RESPONSE_CONDITION_FRAME = 0;\n    Execute.RESPONSE_CONDITION_AUDIO = 1;\n    Execute.RESPONSE_CONDITION_BREAKPOINT = 2;\n    return Execute;\n}());\nfunction getStepsPerStepSet() {\n    return Execute.stepsPerStepSet;\n}\nfunction getStepSets() {\n    return Execute.stepSets;\n}\nfunction getSteps() {\n    return Execute.steps;\n}\n// Inlined because closure compiler inlines\nfunction trackStepsRan(steps) {\n    var esteps = Execute.steps;\n    esteps += steps;\n    if (esteps >= Execute.stepsPerStepSet) {\n        Execute.stepSets += 1;\n        esteps -= Execute.stepsPerStepSet;\n    }\n    Execute.steps = esteps;\n}\n// Inlined because closure compiler inlines\nfunction resetSteps() {\n    Execute.stepsPerStepSet = 2000000000;\n    Execute.stepSets = 0;\n    Execute.steps = 0;\n}\n// // Public funciton to run frames until,\n// the specified number of frames have run or error.\n// Return values:\n// -1 = error\n// 0 = render a frame\nfunction executeMultipleFrames(numberOfFrames) {\n    var frameResponse = 0;\n    var framesRun = 0;\n    while (framesRun < numberOfFrames && frameResponse >= 0) {\n        frameResponse = executeFrame();\n        framesRun += 1;\n    }\n    if (frameResponse < 0) {\n        return frameResponse;\n    }\n    return 0;\n}\n// Public funciton to run opcodes until,\n// a frame is ready, or error.\n// Return values:\n// -1 = error\n// 0 = render a frame\nfunction executeFrame() {\n    return executeUntilCondition(true, -1);\n}\n// Public Function to run opcodes until,\n// a frame is ready, audio bufer is filled, or error\nfunction executeFrameAndCheckAudio(maxAudioBuffer) {\n    if (maxAudioBuffer === void 0) { maxAudioBuffer = 0; }\n    return executeUntilCondition(true, maxAudioBuffer);\n}\n// Base function that executes steps, and checks conditions\n// Return values:\nfunction executeUntilCondition(checkMaxCyclesPerFrame, maxAudioBuffer) {\n    if (checkMaxCyclesPerFrame === void 0) { checkMaxCyclesPerFrame = true; }\n    if (maxAudioBuffer === void 0) { maxAudioBuffer = -1; }\n    // Common tracking variables\n    var numberOfCycles = -1;\n    var audioBufferSize = 1024;\n    if (maxAudioBuffer > 0) {\n        audioBufferSize = maxAudioBuffer;\n    }\n    else if (maxAudioBuffer < 0) {\n        audioBufferSize = -1;\n    }\n    var errorCondition = false;\n    var frameCondition = false;\n    var audioBufferCondition = false;\n    while (!errorCondition && !frameCondition && !audioBufferCondition && !Breakpoints.reachedBreakpoint) {\n        numberOfCycles = executeStep();\n        // Error Condition\n        if (numberOfCycles < 0) {\n            errorCondition = true;\n        }\n        else if (Cpu.currentCycles >= Cpu.MAX_CYCLES_PER_FRAME()) {\n            frameCondition = true;\n        }\n        else if (audioBufferSize > -1 && getNumberOfSamplesInAudioBuffer() >= audioBufferSize) {\n            audioBufferCondition = true;\n        }\n    }\n    // Find our exit reason\n    if (frameCondition) {\n        // Render a frame\n        // Reset our currentCycles\n        Cpu.currentCycles -= Cpu.MAX_CYCLES_PER_FRAME();\n        return Execute.RESPONSE_CONDITION_FRAME;\n    }\n    if (audioBufferCondition) {\n        return Execute.RESPONSE_CONDITION_AUDIO;\n    }\n    if (Breakpoints.reachedBreakpoint) {\n        Breakpoints.reachedBreakpoint = false;\n        return Execute.RESPONSE_CONDITION_BREAKPOINT;\n    }\n    // TODO: Boot ROM handling\n    // There was an error, return -1, and push the program counter back to grab the error opcode\n    Cpu.programCounter = u16Portable(Cpu.programCounter - 1);\n    return -1;\n}\n// Function to execute an opcode, and update other gameboy hardware.\n// http://www.codeslinger.co.uk/pages/projects/gameboy/beginning.html\nfunction executeStep() {\n    // Set has started to 1 since we ran a emulation step\n    setHasCoreStarted(true);\n    // Check if we are in the halt bug\n    if (Cpu.isHaltBug) {\n        // Need to not increment program counter,\n        // thus, running the next opcode twice\n        // E.g\n        // 0x76 - halt\n        // FA 34 12 - ld a,(1234)\n        // Becomes\n        // FA FA 34 ld a,(34FA)\n        // 12 ld (de),a\n        var haltBugOpcode = eightBitLoadFromGBMemory(Cpu.programCounter);\n        // Execute opcode will handle the actual PC behavior\n        var haltBugCycles = executeOpcode$$1(haltBugOpcode);\n        syncCycles(haltBugCycles);\n        Cpu.exitHaltAndStop();\n    }\n    // Interrupts should be handled before reading an opcode\n    // https://github.com/Gekkio/mooneye-gb/blob/master/docs/accuracy.markdown#what-is-the-exact-timing-of-cpu-servicing-an-interrupt\n    var interruptCycles = checkInterrupts();\n    if (interruptCycles > 0) {\n        syncCycles(interruptCycles);\n    }\n    // Get the opcode, and additional bytes to be handled\n    // Number of cycles defaults to 4, because while we're halted, we run 4 cycles (according to matt :))\n    var numberOfCycles = 4;\n    var opcode = 0;\n    // If we are not halted or stopped, run instructions\n    // If we are halted, this will be skipped and just sync the 4 cycles\n    if (!Cpu.isHalted() && !Cpu.isStopped) {\n        opcode = eightBitLoadFromGBMemory(Cpu.programCounter);\n        numberOfCycles = executeOpcode$$1(opcode);\n    }\n    // blarggFixes, don't allow register F to have the bottom nibble\n    Cpu.registerF = Cpu.registerF & 0xf0;\n    // Check if there was an error decoding the opcode\n    if (numberOfCycles <= 0) {\n        return numberOfCycles;\n    }\n    // Sync other GB Components with the number of cycles\n    syncCycles(numberOfCycles);\n    // Update our steps\n    trackStepsRan(1);\n    // Check if we reached the CPU breakpoint\n    if (Cpu.programCounter === Breakpoints.programCounter) {\n        Breakpoints.reachedBreakpoint = true;\n    }\n    return numberOfCycles;\n}\n\n// Imports\n// Grow our memory to the specified size\nif (memory.size() < WASMBOY_WASM_PAGES) {\n    memory.grow(WASMBOY_WASM_PAGES - memory.size());\n}\n// Function to track if the core has started\nvar hasStarted = false;\nfunction setHasCoreStarted(value) {\n    hasStarted = value;\n}\nfunction hasCoreStarted() {\n    return hasStarted;\n}\n// Function to configure & initialize wasmboy\nfunction config(enableBootRom, useGbcWhenAvailable, audioBatchProcessing, graphicsBatchProcessing, timersBatchProcessing, graphicsDisableScanlineRendering, audioAccumulateSamples, tileRendering, tileCaching, enableAudioDebugging) {\n    // TODO: depending on the boot rom, initialization may be different\n    // From: http://www.codeslinger.co.uk/pages/projects/gameboy/hardware.html\n    // All values default to zero in memory, so not setting them yet\n    // log('initializing (includeBootRom=$0)', 1, enableBootRom);\n    Config.enableBootRom = enableBootRom > 0;\n    Config.useGbcWhenAvailable = useGbcWhenAvailable > 0;\n    Config.audioBatchProcessing = audioBatchProcessing > 0;\n    Config.graphicsBatchProcessing = graphicsBatchProcessing > 0;\n    Config.timersBatchProcessing = timersBatchProcessing > 0;\n    Config.graphicsDisableScanlineRendering = graphicsDisableScanlineRendering > 0;\n    Config.audioAccumulateSamples = audioAccumulateSamples > 0;\n    Config.tileRendering = tileRendering > 0;\n    Config.tileCaching = tileCaching > 0;\n    Config.enableAudioDebugging = enableAudioDebugging > 0;\n    initialize();\n}\n// Function to initiialize the core\nfunction initialize() {\n    // Initialization variables from BGB\n    // First, try to switch to Gameboy Color Mode\n    // Get our GBC support from the cartridge header\n    // http://gbdev.gg8.se/wiki/articles/The_Cartridge_Header\n    var gbcType = eightBitLoadFromGBMemory(0x0143);\n    // Detecting GBC http://bgb.bircd.org/pandocs.htm#cgbregisters\n    if (gbcType === 0xc0 || (Config.useGbcWhenAvailable && gbcType === 0x80)) {\n        Cpu.GBCEnabled = true;\n    }\n    else {\n        Cpu.GBCEnabled = false;\n    }\n    // Reset hasStarted, since we are now reset\n    setHasCoreStarted(false);\n    // Reset our cycles ran\n    resetCycles();\n    resetSteps();\n    if (Config.enableBootRom) {\n        Cpu.BootROMEnabled = true;\n    }\n    else {\n        Cpu.BootROMEnabled = false;\n    }\n    // Call our respective classes intialization\n    // NOTE: Boot ROM Only handles some initialization, thus we need to check in each one\n    // respecitvely :p\n    initializeCpu();\n    initializeCartridge();\n    initializeDma();\n    initializeGraphics();\n    initializePalette();\n    initializeSound();\n    initializeInterrupts();\n    initializeTimers();\n    initializeSerial();\n    initializeVarious();\n}\nfunction initializeVarious() {\n    // Various Other Registers\n    if (Cpu.GBCEnabled) {\n        // Various other registers\n        eightBitStoreIntoGBMemory(0xff70, 0xf8);\n        eightBitStoreIntoGBMemory(0xff4f, 0xfe);\n        eightBitStoreIntoGBMemory(0xff4d, 0x7e);\n        eightBitStoreIntoGBMemory(0xff00, 0xcf);\n        eightBitStoreIntoGBMemory(0xff0f, 0xe1);\n        // 0xFFFF = 0x00\n        // Undocumented from Pandocs\n        eightBitStoreIntoGBMemory(0xff6c, 0xfe);\n        eightBitStoreIntoGBMemory(0xff75, 0x8f);\n    }\n    else {\n        eightBitStoreIntoGBMemory(0xff70, 0xff);\n        eightBitStoreIntoGBMemory(0xff4f, 0xff);\n        eightBitStoreIntoGBMemory(0xff4d, 0xff);\n        eightBitStoreIntoGBMemory(0xff00, 0xcf);\n        eightBitStoreIntoGBMemory(0xff0f, 0xe1);\n        // 0xFFFF = 0x00\n    }\n}\n// Function to return if we are currently playing a GBC ROM\nfunction isGBC() {\n    return Cpu.GBCEnabled;\n}\n// Function to return an address to store into save state memory\n// this is to regulate our 20 slots\n// https://docs.google.com/spreadsheets/d/17xrEzJk5-sCB9J2mMJcVnzhbE-XH_NvczVSQH9OHvRk/edit?usp=sharing\n// Inlined because closure compiler inlines\nfunction getSaveStateMemoryOffset(offset, saveStateSlot) {\n    // 50 bytes per save state memory partiton sli32\n    return WASMBOY_STATE_LOCATION + offset + 50 * saveStateSlot;\n}\n// Function to save state to memory for all of our classes\nfunction saveState() {\n    Cpu.saveState();\n    Graphics.saveState();\n    Interrupts.saveState();\n    Joypad.saveState();\n    Memory.saveState();\n    Timers.saveState();\n    Sound.saveState();\n    Channel1.saveState();\n    Channel2.saveState();\n    Channel3.saveState();\n    Channel4.saveState();\n    // Reset hasStarted, since we are now reset\n    setHasCoreStarted(false);\n    // Don't want to reset cycles here, as this does not reset the emulator\n}\n// Function to load state from memory for all of our classes\nfunction loadState() {\n    Cpu.loadState();\n    Graphics.loadState();\n    Interrupts.loadState();\n    Joypad.loadState();\n    Memory.loadState();\n    Timers.loadState();\n    Sound.loadState();\n    Channel1.loadState();\n    Channel2.loadState();\n    Channel3.loadState();\n    Channel4.loadState();\n    // Reset hasStarted, since we are now reset\n    setHasCoreStarted(false);\n    // Reset our cycles ran\n    resetCycles();\n    resetSteps();\n}\n\n// Functions to get information about the emulator for debugging purposes\nfunction getRegisterA() {\n    return Cpu.registerA;\n}\nfunction getRegisterB() {\n    return Cpu.registerB;\n}\nfunction getRegisterC() {\n    return Cpu.registerC;\n}\nfunction getRegisterD() {\n    return Cpu.registerD;\n}\nfunction getRegisterE() {\n    return Cpu.registerE;\n}\nfunction getRegisterH() {\n    return Cpu.registerH;\n}\nfunction getRegisterL() {\n    return Cpu.registerL;\n}\nfunction getRegisterF() {\n    return Cpu.registerF;\n}\nfunction getProgramCounter() {\n    return Cpu.programCounter;\n}\nfunction getStackPointer() {\n    return Cpu.stackPointer;\n}\nfunction getOpcodeAtProgramCounter() {\n    return eightBitLoadFromGBMemory(Cpu.programCounter);\n}\n\n// Functions to debug graphical output\n// Some Simple internal getters\nfunction getLY() {\n    return Graphics.scanlineRegister;\n}\nfunction getScrollX() {\n    return Graphics.scrollX;\n}\nfunction getScrollY() {\n    return Graphics.scrollY;\n}\nfunction getWindowX() {\n    return Graphics.windowX;\n}\nfunction getWindowY() {\n    return Graphics.windowY;\n}\n// TODO: Render by tile, rather than by pixel\nfunction drawBackgroundMapToWasmMemory(showColor) {\n    // http://www.codeslinger.co.uk/pages/projects/gameboy/graphics.html\n    // Bit 7 - LCD Display Enable (0=Off, 1=On)\n    // Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)\n    // Bit 5 - Window Display Enable (0=Off, 1=On)\n    // Bit 4 - BG & Window Tile Data Select (0=8800-97FF, 1=8000-8FFF)\n    // Bit 3 - BG Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)\n    // Bit 2 - OBJ (Sprite) Size (0=8x8, 1=8x16)\n    // Bit 1 - OBJ (Sprite) Display Enable (0=Off, 1=On)\n    // Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)\n    // Get our seleted tile data memory location\n    var tileDataMemoryLocation = Graphics.memoryLocationTileDataSelectZeroStart;\n    if (Lcd.bgWindowTileDataSelect) {\n        tileDataMemoryLocation = Graphics.memoryLocationTileDataSelectOneStart;\n    }\n    var tileMapMemoryLocation = Graphics.memoryLocationTileMapSelectZeroStart;\n    if (Lcd.bgTileMapDisplaySelect) {\n        tileMapMemoryLocation = Graphics.memoryLocationTileMapSelectOneStart;\n    }\n    for (var y = 0; y < 256; y++) {\n        for (var x = 0; x < 256; x++) {\n            // Get our current Y\n            var pixelYPositionInMap = y;\n            // Get our Current X position of our pixel on the on the 160x144 camera\n            // this is done by getting the current scroll X position,\n            // and adding it do what X Value the scanline is drawing on the camera.\n            var pixelXPositionInMap = x;\n            // Divide our pixel position by 8 to get our tile.\n            // Since, there are 256x256 pixels, and 32x32 tiles.\n            // 256 / 8 = 32.\n            // Also, bitshifting by 3, do do a division by 8\n            // Need to use u16s, as they will be used to compute an address, which will cause weird errors and overflows\n            var tileXPositionInMap = pixelXPositionInMap >> 3;\n            var tileYPositionInMap = pixelYPositionInMap >> 3;\n            // Get our tile address on the tileMap\n            // NOTE: (tileMap represents where each tile is displayed on the screen)\n            // NOTE: (tile map represents the entire map, now just what is within the \"camera\")\n            // For instance, if we have y pixel 144. 144 / 8 = 18. 18 * 32 = line address in map memory.\n            // And we have x pixel 160. 160 / 8 = 20.\n            // * 32, because remember, this is NOT only for the camera, the actual map is 32x32. Therefore, the next tile line of the map, is 32 byte offset.\n            // Think like indexing a 2d array, as a 1d array and it make sense :)\n            var tileMapAddress = tileMapMemoryLocation + tileYPositionInMap * 32 + tileXPositionInMap;\n            // Get the tile Id on the Tile Map\n            var tileIdFromTileMap = loadFromVramBank(tileMapAddress, 0);\n            // Now get our tileDataAddress for the corresponding tileID we found in the map\n            // Read the comments in _getTileDataAddress() to see what's going on.\n            // tl;dr if we had the tile map of \"a b c d\", and wanted tileId 2.\n            // This funcitons returns the start of memory locaiton for the tile 'c'.\n            var tileDataAddress = getTileDataAddress(tileDataMemoryLocation, tileIdFromTileMap);\n            // Now we can process the the individual bytes that represent the pixel on a tile\n            // Get the y pixel of the 8 by 8 tile.\n            // Simply modulo the scanline.\n            // For instance, let's say we are printing the first line of pixels on our camera,\n            // And the first line of pixels on our tile.\n            // yPixel = 1. 1 % 8 = 1.\n            // And for the last line\n            // yPixel = 144. 144 % 8 = 0.\n            // 0 Represents last line of pixels in a tile, 1 represents first. 1 2 3 4 5 6 7 0.\n            // Because remember, we are counting lines on the display NOT including zero\n            var pixelYInTile = pixelYPositionInMap % 8;\n            // Same logic as pixelYInTile.\n            // However, We need to reverse our byte,\n            // As pixel 0 is on byte 7, and pixel 1 is on byte 6, etc...\n            // Therefore, is pixelX was 2, then really is need to be 5\n            // So 2 - 7 = -5, * 1 = 5\n            // Or to simplify, 7 - 2 = 5 haha!\n            var pixelXInTile = pixelXPositionInMap % 8;\n            pixelXInTile = 7 - pixelXInTile;\n            // Get the GB Map Attributes\n            // Bit 0-2  Background Palette number  (BGP0-7)\n            // Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)\n            // Bit 4    Not used\n            // Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)\n            // Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)\n            // Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)\n            var bgMapAttributes = 0;\n            if (Cpu.GBCEnabled && showColor > 0) {\n                bgMapAttributes = loadFromVramBank(tileMapAddress, 1);\n            }\n            if (checkBitOnByte(6, bgMapAttributes)) {\n                // We are mirroring the tile, therefore, we need to opposite byte\n                // So if our pizel was 0 our of 8, it wild become 7 :)\n                // TODO: This may be wrong :p\n                pixelYInTile = 7 - pixelYInTile;\n            }\n            // Remember to represent a single line of 8 pixels on a tile, we need two bytes.\n            // Therefore, we need to times our modulo by 2, to get the correct line of pixels on the tile.\n            // But we need to load the time from a specific Vram bank\n            var vramBankId = 0;\n            if (checkBitOnByte(3, bgMapAttributes)) {\n                vramBankId = 1;\n            }\n            // Remember to represent a single line of 8 pixels on a tile, we need two bytes.\n            // Therefore, we need to times our modulo by 2, to get the correct line of pixels on the tile.\n            // Again, think like you had to map a 2d array as a 1d.\n            var byteOneForLineOfTilePixels = loadFromVramBank(tileDataAddress + pixelYInTile * 2, vramBankId);\n            var byteTwoForLineOfTilePixels = loadFromVramBank(tileDataAddress + pixelYInTile * 2 + 1, vramBankId);\n            // Now we can get the color for that pixel\n            // Colors are represented by getting X position of ByteTwo, and X positon of Byte One\n            // To Get the color Id.\n            // For example, the result of the color id is 0000 00[xPixelByteTwo][xPixelByteOne]\n            // See: How to draw a tile/sprite from memory: http://www.codeslinger.co.uk/pages/projects/gameboy/graphics.html\n            var paletteColorId = 0;\n            if (checkBitOnByte(pixelXInTile, byteTwoForLineOfTilePixels)) {\n                // Byte one represents the second bit in our color id, so bit shift\n                paletteColorId += 1;\n                paletteColorId = paletteColorId << 1;\n            }\n            if (checkBitOnByte(pixelXInTile, byteOneForLineOfTilePixels)) {\n                paletteColorId += 1;\n            }\n            // FINALLY, RENDER THAT PIXEL!\n            var pixelStart = (y * 256 + x) * 3;\n            if (Cpu.GBCEnabled && showColor > 0) {\n                // Finally lets add some, C O L O R\n                // Want the botom 3 bits\n                var bgPalette = bgMapAttributes & 0x07;\n                // Call the helper function to grab the correct color from the palette\n                var rgbColorPalette = getRgbColorFromPalette(bgPalette, paletteColorId, false);\n                // Split off into red green and blue\n                var red = getColorComponentFromRgb(0, rgbColorPalette);\n                var green = getColorComponentFromRgb(1, rgbColorPalette);\n                var blue = getColorComponentFromRgb(2, rgbColorPalette);\n                var offset = BACKGROUND_MAP_LOCATION + pixelStart;\n                store(offset, red);\n                store(offset + 1, green);\n                store(offset + 2, blue);\n            }\n            else {\n                // Only rendering camera for now, so coordinates are for the camera.\n                // Get the rgb value for the color Id, will be repeated into R, G, B (if not colorized)\n                var hexColor = getColorizedGbHexColorFromPalette(paletteColorId, Graphics.memoryLocationBackgroundPalette);\n                var offset = BACKGROUND_MAP_LOCATION + pixelStart;\n                // Red\n                store(offset + 0, getRedFromHexColor(hexColor));\n                // Green\n                store(offset + 1, getGreenFromHexColor(hexColor));\n                // Blue\n                store(offset + 2, getBlueFromHexColor(hexColor));\n            }\n        }\n    }\n}\nfunction drawTileDataToWasmMemory() {\n    for (var tileDataMapGridY = 0; tileDataMapGridY < 0x17; tileDataMapGridY++) {\n        for (var tileDataMapGridX = 0; tileDataMapGridX < 0x1f; tileDataMapGridX++) {\n            // Get Our VramBankID\n            var vramBankId = 0;\n            if (tileDataMapGridX > 0x0f) {\n                vramBankId = 1;\n            }\n            // Get our tile ID\n            var tileId = tileDataMapGridY;\n            if (tileDataMapGridY > 0x0f) {\n                tileId -= 0x0f;\n            }\n            tileId = tileId << 4;\n            if (tileDataMapGridX > 0x0f) {\n                tileId = tileId + (tileDataMapGridX - 0x0f);\n            }\n            else {\n                tileId = tileId + tileDataMapGridX;\n            }\n            // Finally get our tile Data location\n            var tileDataMemoryLocation = Graphics.memoryLocationTileDataSelectOneStart;\n            if (tileDataMapGridY > 0x0f) {\n                tileDataMemoryLocation = Graphics.memoryLocationTileDataSelectZeroStart;\n            }\n            // Let's see if we have C O L O R\n            // Set the map and sprite attributes to -1\n            // Meaning, we will draw monochrome\n            var paletteLocation = Graphics.memoryLocationBackgroundPalette;\n            var bgMapAttributes = -1;\n            var spriteAttributes = -1;\n            // Let's see if the tile is being used by a sprite\n            for (var spriteRow = 0; spriteRow < 8; spriteRow++) {\n                for (var spriteColumn = 0; spriteColumn < 5; spriteColumn++) {\n                    var spriteIndex = spriteColumn * 8 + spriteRow;\n                    // Sprites occupy 4 bytes in the sprite attribute table\n                    var spriteTableIndex = spriteIndex * 4;\n                    var spriteTileId = eightBitLoadFromGBMemory(Graphics.memoryLocationSpriteAttributesTable + spriteTableIndex + 2);\n                    if (tileId === spriteTileId) {\n                        var currentSpriteAttributes = eightBitLoadFromGBMemory(Graphics.memoryLocationSpriteAttributesTable + spriteTableIndex + 3);\n                        var spriteVramBankId = 0;\n                        if (Cpu.GBCEnabled && checkBitOnByte(3, currentSpriteAttributes)) {\n                            spriteVramBankId = 1;\n                        }\n                        if (spriteVramBankId === vramBankId) {\n                            spriteAttributes = currentSpriteAttributes;\n                            spriteRow = 8;\n                            spriteColumn = 5;\n                            // Set our paletteLocation\n                            paletteLocation = Graphics.memoryLocationSpritePaletteOne;\n                            if (checkBitOnByte(4, spriteAttributes)) {\n                                paletteLocation = Graphics.memoryLocationSpritePaletteTwo;\n                            }\n                        }\n                    }\n                }\n            }\n            // If we didn't find a sprite,\n            // Let's see if the tile is on the bg tile map\n            // If so, use that bg map for attributes\n            if (Cpu.GBCEnabled && spriteAttributes < 0) {\n                var tileMapMemoryLocation = Graphics.memoryLocationTileMapSelectZeroStart;\n                if (Lcd.bgTileMapDisplaySelect) {\n                    tileMapMemoryLocation = Graphics.memoryLocationTileMapSelectOneStart;\n                }\n                // Loop through the tileMap, and find if we have our current ID\n                var foundTileMapAddress = -1;\n                for (var x = 0; x < 32; x++) {\n                    for (var y = 0; y < 32; y++) {\n                        var tileMapAddress = tileMapMemoryLocation + y * 32 + x;\n                        var tileIdFromTileMap = loadFromVramBank(tileMapAddress, 0);\n                        // Check if we found our tileId\n                        if (tileId === tileIdFromTileMap) {\n                            foundTileMapAddress = tileMapAddress;\n                            x = 32;\n                            y = 32;\n                        }\n                    }\n                }\n                if (foundTileMapAddress >= 0) {\n                    bgMapAttributes = loadFromVramBank(foundTileMapAddress, 1);\n                }\n            }\n            // Draw each Y line of the tile\n            for (var tileLineY = 0; tileLineY < 8; tileLineY++) {\n                drawPixelsFromLineOfTile(tileId, // tileId\n                tileDataMemoryLocation, // Graphics.memoryLocationTileDataSelect\n                vramBankId, // Vram Bank\n                0, // Tile Line X Start\n                7, // Tile Line X End\n                tileLineY, // Tile Line Y\n                tileDataMapGridX * 8, // Output line X\n                tileDataMapGridY * 8 + tileLineY, // Output line Y\n                0x1f * 8, // Output Width\n                TILE_DATA_LOCATION, // Wasm Memory Start\n                false, // shouldRepresentMonochromeColorByColorId\n                paletteLocation, // paletteLocation\n                bgMapAttributes, // bgMapAttributes\n                spriteAttributes // spriteAttributes\n                );\n            }\n        }\n    }\n}\nfunction drawOamToWasmMemory() {\n    // Draw all 40 sprites\n    // Going to be like BGB and do 8 x 5 sprites\n    for (var spriteRow = 0; spriteRow < 8; spriteRow++) {\n        for (var spriteColumn = 0; spriteColumn < 5; spriteColumn++) {\n            var spriteIndex = spriteColumn * 8 + spriteRow;\n            // Sprites occupy 4 bytes in the sprite attribute table\n            var spriteTableIndex = spriteIndex * 4;\n            // Y positon is offset by 16, X position is offset by 8\n            var spriteYPosition = eightBitLoadFromGBMemory(Graphics.memoryLocationSpriteAttributesTable + spriteTableIndex);\n            var spriteXPosition = eightBitLoadFromGBMemory(Graphics.memoryLocationSpriteAttributesTable + spriteTableIndex + 1);\n            var spriteTileId = eightBitLoadFromGBMemory(Graphics.memoryLocationSpriteAttributesTable + spriteTableIndex + 2);\n            var tilesToDraw = 1;\n            if (Lcd.tallSpriteSize) {\n                // @binji says in 8x16 mode, even tileId always drawn first\n                // This will fix shantae sprites which always uses odd numbered indexes\n                // TODO: Do the actual Pandocs thing:\n                // \"In 8x16 mode, the lower bit of the tile number is ignored. Ie. the upper 8x8 tile is \"NN AND FEh\", and the lower 8x8 tile is \"NN OR 01h\".\"\n                // So just knock off the last bit? :)\n                if (spriteTileId % 2 === 1) {\n                    spriteTileId -= 1;\n                }\n                tilesToDraw += 1;\n            }\n            // Get our sprite attributes since we know we shall be drawing the tile\n            var spriteAttributes = eightBitLoadFromGBMemory(Graphics.memoryLocationSpriteAttributesTable + spriteTableIndex + 3);\n            // Find which VRAM Bank to load from\n            var vramBankId = 0;\n            if (Cpu.GBCEnabled && checkBitOnByte(3, spriteAttributes)) {\n                vramBankId = 1;\n            }\n            // Find which monochrome palette we should use\n            var paletteLocation = Graphics.memoryLocationSpritePaletteOne;\n            if (checkBitOnByte(4, spriteAttributes)) {\n                paletteLocation = Graphics.memoryLocationSpritePaletteTwo;\n            }\n            // Start Drawing our tiles\n            for (var i = 0; i < tilesToDraw; i++) {\n                // Draw each Y line of the tile\n                for (var tileLineY = 0; tileLineY < 8; tileLineY++) {\n                    drawPixelsFromLineOfTile(spriteTileId + i, // tileId\n                    Graphics.memoryLocationTileDataSelectOneStart, // Graphics.memoryLocationTileDataSelect\n                    vramBankId, // VRAM Bank\n                    0, // Tile Line X Start\n                    7, // Tile Line X End\n                    tileLineY, // Tile Line Y\n                    spriteRow * 8, // Output line X\n                    spriteColumn * 16 + tileLineY + i * 8, // Output line Y\n                    8 * 8, // Output Width\n                    OAM_TILES_LOCATION, // Wasm Memory Start\n                    false, // shouldRepresentMonochromeColorByColorId\n                    paletteLocation, // paletteLocation\n                    -1, // bgMapAttributes\n                    spriteAttributes // spriteAttributes\n                    );\n                }\n            }\n        }\n    }\n}\n\nfunction getDIV() {\n    return Timers.dividerRegister;\n}\nfunction getTIMA() {\n    return Timers.timerCounter;\n}\nfunction getTMA() {\n    return Timers.timerModulo;\n}\nfunction getTAC() {\n    var response = Timers.timerInputClock;\n    if (Timers.timerEnabled) {\n        response = setBitOnByte(2, response);\n    }\n    return response;\n}\n\n// Functions to debug internal gameboy memory\nfunction updateDebugGBMemory() {\n    for (var i = 0; i < DEBUG_GAMEBOY_MEMORY_SIZE; i++) {\n        store(DEBUG_GAMEBOY_MEMORY_LOCATION + i, eightBitLoadFromGBMemoryWithTraps(i));\n    }\n    // Since we are debugging, we don't want to be responsible for tripping the breakpoints\n    Breakpoints.reachedBreakpoint = false;\n}\n\n// Public Exports\n\nexport { config, hasCoreStarted, saveState, loadState, isGBC, getStepsPerStepSet, getStepSets, getSteps, executeMultipleFrames, executeFrame, executeFrameAndCheckAudio, executeUntilCondition, executeStep, getCyclesPerCycleSet, getCycleSets, getCycles, setJoypadState, getNumberOfSamplesInAudioBuffer, clearAudioBuffer, setManualColorizationPalette, WASMBOY_MEMORY_LOCATION, WASMBOY_MEMORY_SIZE, WASMBOY_WASM_PAGES, ASSEMBLYSCRIPT_MEMORY_LOCATION, ASSEMBLYSCRIPT_MEMORY_SIZE, WASMBOY_STATE_LOCATION, WASMBOY_STATE_SIZE, GAMEBOY_INTERNAL_MEMORY_LOCATION, GAMEBOY_INTERNAL_MEMORY_SIZE, VIDEO_RAM_LOCATION, VIDEO_RAM_SIZE, WORK_RAM_LOCATION, WORK_RAM_SIZE, OTHER_GAMEBOY_INTERNAL_MEMORY_LOCATION, OTHER_GAMEBOY_INTERNAL_MEMORY_SIZE, GRAPHICS_OUTPUT_LOCATION, GRAPHICS_OUTPUT_SIZE, GBC_PALETTE_LOCATION, GBC_PALETTE_SIZE, BG_PRIORITY_MAP_LOCATION, BG_PRIORITY_MAP_SIZE, FRAME_LOCATION, FRAME_SIZE, BACKGROUND_MAP_LOCATION, BACKGROUND_MAP_SIZE, TILE_DATA_LOCATION, TILE_DATA_SIZE, OAM_TILES_LOCATION, OAM_TILES_SIZE, AUDIO_BUFFER_LOCATION, AUDIO_BUFFER_SIZE, CHANNEL_1_BUFFER_LOCATION, CHANNEL_1_BUFFER_SIZE, CHANNEL_2_BUFFER_LOCATION, CHANNEL_2_BUFFER_SIZE, CHANNEL_3_BUFFER_LOCATION, CHANNEL_3_BUFFER_SIZE, CHANNEL_4_BUFFER_LOCATION, CHANNEL_4_BUFFER_SIZE, CARTRIDGE_RAM_LOCATION, CARTRIDGE_RAM_SIZE, BOOT_ROM_LOCATION, BOOT_ROM_SIZE, CARTRIDGE_ROM_LOCATION, CARTRIDGE_ROM_SIZE, DEBUG_GAMEBOY_MEMORY_LOCATION, DEBUG_GAMEBOY_MEMORY_SIZE, getWasmBoyOffsetFromGameBoyOffset, setProgramCounterBreakpoint, resetProgramCounterBreakpoint, setReadGbMemoryBreakpoint, resetReadGbMemoryBreakpoint, setWriteGbMemoryBreakpoint, resetWriteGbMemoryBreakpoint, getRegisterA, getRegisterB, getRegisterC, getRegisterD, getRegisterE, getRegisterH, getRegisterL, getRegisterF, getProgramCounter, getStackPointer, getOpcodeAtProgramCounter, getLY, getScrollX, getScrollY, getWindowX, getWindowY, drawBackgroundMapToWasmMemory, drawTileDataToWasmMemory, drawOamToWasmMemory, getDIV, getTIMA, getTMA, getTAC, updateDebugGBMemory };\n","import * as WasmBoyCore from '../../dist/core/core.esm';\n\nconst getWasmBoyTsCore = async () => {\n  const response = {\n    instance: {\n      exports: WasmBoyCore\n    },\n    byteMemory: WasmBoyCore.memory.wasmByteMemory,\n    type: 'TypeScript'\n  };\n  return response;\n};\n\nexport default getWasmBoyTsCore;\n"],"names":["setFlagBit","flagBit","flagValue","bitwiseOperand","Cpu","setZeroFlag$$1","value","setSubtractFlag","setHalfCarryFlag","setCarryFlag","getZeroFlag$$1","getCarryFlag$$1","checkAndSetEightBitHalfCarryFlag","amountToAdd","Math","checkAndSetEightBitCarryFlag","checkAndSetSixteenBitFlagsAddOverflow","valueOne","valueTwo","useStackPointerBits","flagXor","result","setManualColorizationPalette","colorizationId","Colors","WasmBoyGBColors","BrownColors","RedColors","DarkBrownColors","GreenColors","DarkGreenColors","InvertedColors","PastelMixColors","OrangeColors","YellowColors","BlueColors","DarkBlueColors","GrayscaleColors","concatenateBytes","highByte","lowByte","splitHighByte","groupedByte","resetBitOnByte","bitPosition","byte","checkBitOnByte","getColorizedGbHexColorFromPalette","colorId","paletteMemoryLocation","color","eightBitLoadFromGBMemory","Palette","hexColor","getRgbColorFromPalette","paletteId","isSprite","paletteIndex","paletteHighByte","loadPaletteByteFromWasmMemory","paletteLowByte","getColorComponentFromRgb","colorRgb","paletteIndexByte","wasmByteMemory","GBC_PALETTE_LOCATION","addPriorityforPixel","x","y","hasGbcBgPriority","bgPriorityByte","BG_PRIORITY_MAP_LOCATION","drawPixelsFromLineOfTile","tileId","tileDataMemoryLocation","vramBankId","tileLineXStart","tileLineXEnd","tileLineY","outputLineX","outputLineY","outputWidth","wasmMemoryStart","shouldRepresentMonochromeColorByColorId","paletteLocation","bgMapAttributes","spriteAttributes","pixelsDrawn","tileDataAddress","getTileDataAddress","byteOneForLineOfTilePixels","loadFromVramBank","byteTwoForLineOfTilePixels","iteratedOutputX","pixelXInTile","paletteColorId","bgPalette","rgbColorPalette","red","green","blue","Graphics","shouldRepresentColorByColorId","rgbColor","pixelStart","gbcBgPriority","tileIdFromTileMap","isDutyCycleClockPositiveOrNegativeForWaveform","channelDuty","waveFormPositionOnDuty","calculateSweep","oldFrequency","Channel1","newFrequency","didChannelDacChange","channelNumber","isDacEnabled","channel1EnabledChanged","SoundAccumulator","Channel2","channel2EnabledChanged","Channel3","channel3EnabledChanged","Channel4","channel4EnabledChanged","batchProcessAudio","batchProcessCycles","Sound","currentCycles","updateSound","numberOfCycles","maxFrameSequenceCycles","frameSequenceCycleCounter","frameSequencer","Config","frameSequencerUpdated","channel1WillUpdate","channel2WillUpdate","channel3WillUpdate","channel4WillUpdate","downSampleCycleCounter","maxDownSampleCycles","mixChannelSamples","setLeftAndRightOutputForAudioQueue","AUDIO_BUFFER_LOCATION","audioQueueIndex","channel1Sample","channel2Sample","channel3Sample","channel4Sample","mixedSample","leftChannelSampleUnsignedByte","CHANNEL_1_BUFFER_LOCATION","CHANNEL_2_BUFFER_LOCATION","CHANNEL_3_BUFFER_LOCATION","CHANNEL_4_BUFFER_LOCATION","getNumberOfSamplesInAudioBuffer","clearAudioBuffer","leftChannelSample","rightChannelSample","getSampleAsUnsignedByte","rightChannelSampleUnsignedByte","sample","mixerVolume","convertedSample","precision","leftVolume","rightVolume","bufferLocation","audioQueueOffset","SoundRegisterReadTraps","offset","register","registerNR52","_handleInterrupt","setInterrupts","interruptRequest","Interrupts","eightBitStoreIntoGBMemory","_requestInterrupt","updateTimers","cyclesIncreased","oldDividerRegister","Timers","curDividerRegister","timerCounterWasReset","_checkDividerRegisterFallingEdgeDetector","_incrementTimerCounter","counter","newDividerRegister","timerCounterMaskBit","_getTimerCounterMaskBit","timerInputClock","_pressJoypadButton","buttonId","isButtonStateChanging","_getJoypadButtonStateFromButtonId","_setJoypadButtonStateFromButtonId","isDpadTypeButton","shouldRequestInterrupt","Joypad","isPressed","hdmaTransfer","hdmaSource","hdmaDestination","transferLength","i","sourceByte","eightBitLoadFromGBMemoryWithTraps","hdmaDestinationWithWrapping","eightBitStoreIntoGBMemoryWithTraps","Memory","checkWriteTraps","videoRamLocation","spriteInformationTableLocation","isMBC1","isMBC2","romEnableByte","isMBC5","currentRomBank","romBankLowerBits","ramBankBits","Lcd","Serial","wasNR52Enabled","SoundRegisterWriteTraps","sourceAddress","spriteInformationByte","hdmaTriggerByte","hdmaSourceHigh","hdmaSourceLow","hdmaDestinationHigh","hdmaDestinationLow","hblankHdmaSource","memoryLocationSpritePaletteData","getWasmBoyOffsetFromGameBoyOffset","gameboyOffset","BOOT_ROM_LOCATION","CARTRIDGE_ROM_LOCATION","WASMBOY_STATE_LOCATION","CARTRIDGE_RAM_LOCATION","VIDEO_RAM_LOCATION","wramBankId","WORK_RAM_LOCATION","Breakpoints","resetLcd","shouldBlankScreen","lcdStatus","FRAME_SIZE","FRAME_LOCATION","checkCoincidence","lcdMode","drawBackgroundWindowScanline","scanlineRegister","tileMapMemoryLocation","pixelYPositionInMap","iStart","xOffset","tileYPositionInMap","pixelXPositionInMap","tileMapAddress","usedTileCache","nextXIndexToPerformCacheCheck","TileCache","yPixel","xPixel","wasLastTileHorizontallyFlipped","isCurrentTileHorizontallyFlipped","tileCacheIndex","xPos","previousXPixel","previousTilePixelLocation","setPixelOnFrame","pixelPriority","xOffsetTileWidthRemainder","tileXStart","tileXEnd","pixelYInTile","updateGraphics","graphicsDisableScanlineRendering","_drawScanline","newLcdMode","scanlineCycleCounter","MIN_CYCLES_SPRITES_LCD_MODE","bytesToTransfer","hblankHdmaTransferLengthRemaining","memoryLocationHdmaTrigger","windowX","windowY","param","spriteTableIndex","index","spriteYPosition","spriteXPosition","spriteTileId","spriteHeight","useLargerSprites","isSpritePriorityBehindWindowAndBackground","flipSpriteY","flipSpriteX","currentSpriteLine","spriteTileAddressStart","spriteDataByteOneForLineOfTilePixels","spriteTileAddress","spriteDataByteTwoForLineOfTilePixels","tilePixel","spritePixelXInTile","spriteColorId","spriteXPixelLocationInCameraView","shouldShowFromLcdcPriority","shouldHideFromOamPriority","shouldHideFromBgPriority","bgColorFromPriorityByte","spritePaletteLocation","checkReadTraps","response","currentSpeedSwitchRegister","upperDividerRegisterBits","joypadRegister","readTrapResult","loadBooleanDirectlyFromWasmMemory","addARegister","registerA","addAThroughCarryRegister","overflowedResult","subARegister","negativeRegister","subAThroughCarryRegister","andARegister","xorARegister","orARegister","cpARegister","testBitOnRegister","setBitOnRegister","bitValue","setByte","relativeJump","programCounter","executeOpcode$$1","opcode","handleOpcode0x","handleOpcode1x","handleOpcode2x","handleOpcode3x","handleOpcode4x","handleOpcode5x","handleOpcode6x","handleOpcode7x","handleOpcode8x","handleOpcode9x","handleOpcodeAx","handleOpcodeBx","handleOpcodeCx","handleOpcodeDx","handleOpcodeEx","handleOpcodeFx","eightBitLoadSyncCycles","syncCycles","eightBitStoreSyncCycles","sixteenBitLoadSyncCycles","lowByteReadTrapResult","nextOffset","highByteReadTrapResult","sixteenBitStoreSyncCycles","getDataByteOne","getConcatenatedDataByte","getDataByteTwo","concatenatedDataByte","registerBC3","registerB","registerHL","registerBC9","registerBCB","registerC","speedSwitch","registerDE3","registerD","hasHighbit","registerDE9","registerDEA","registerDEB","registerE","hasLowBit","sixteenBitDataByte","registerHL2","registerHL3","registerH","adjustment","adjustedRegister","registerHL9","registerHLA","registerHLB","registerL","registerHL4","valueAtHL4","incrementer","registerHL5","valueAtHL5","valueAtHL6","valueAtHLE","stackPointer","registerBC1","handledOpcode","instructionRegisterValue","instructionRegisterResult","registerNumber","cbOpcode","opcodeHighNibble","hasLowbit","registerDE1","largeDataByteOne","registerHL1","signedDataByteOne","registerAF1","oldCycles","curCycles","maskBit","newCycles","memoryLocationSerialTransferData","transferData","numberOfBitsTransferred","memoryLocationSerialTransferControl","transferControl","cycles","Cycles","executeFrame","executeUntilCondition","checkMaxCyclesPerFrame","maxAudioBuffer","audioBufferSize","errorCondition","frameCondition","audioBufferCondition","executeStep","Execute","hasStarted","haltBugOpcode","haltBugCycles","wasInterruptHandled","interuptHandlerCycles","interruptCycles","esteps","steps","size","grow","GAMEBOY_INTERNAL_MEMORY_SIZE","OTHER_GAMEBOY_INTERNAL_MEMORY_LOCATION","GBC_PALETTE_SIZE","BG_PRIORITY_MAP_SIZE","BACKGROUND_MAP_LOCATION","TILE_DATA_LOCATION","BACKGROUND_MAP_SIZE","OAM_TILES_LOCATION","TILE_DATA_SIZE","GRAPHICS_OUTPUT_LOCATION","GRAPHICS_OUTPUT_SIZE","OAM_TILES_SIZE","CHANNEL_1_BUFFER_SIZE","CHANNEL_2_BUFFER_SIZE","CHANNEL_3_BUFFER_SIZE","CHANNEL_4_BUFFER_SIZE","AUDIO_BUFFER_SIZE","CARTRIDGE_RAM_SIZE","BOOT_ROM_SIZE","DEBUG_GAMEBOY_MEMORY_LOCATION","CARTRIDGE_ROM_SIZE","WASMBOY_MEMORY_SIZE","DEBUG_GAMEBOY_MEMORY_SIZE","WASMBOY_WASM_PAGES","Table00Entry08Colors","Table01Entry0BColors","Table01Entry10Colors","Table03Entry0AColors","Table05Entry00Colors","Table05Entry01Colors","Table05Entry02Colors","Table05Entry08Colors","Table05Entry09Colors","Table05Entry11Colors","Table05Entry14Colors","Table05Entry15Colors","Channel1.updateNRx0","oldSweepNegate","Channel1.updateNRx1","Channel1.updateNRx2","Channel1.updateNRx3","Channel1.updateNRx4","frequencyMSB","doesNextFrameSequencerUpdateLength","isBeingLengthEnabled","Channel1.saveState","Channel1.loadState","Channel1.initialize","Channel1.getSampleFromCycleCounter","accumulatedCycles","Channel1.resetTimer","frequencyTimer","Channel1.getSample","overflowAmount","outputVolume","Channel1.trigger","didCalculatedSweepOverflow","Channel1.willChannelUpdate","cycleCounter","Channel1.updateSweep","sweepCounter","Channel1.updateLength","lengthCounter","Channel1.updateEnvelope","envelopeCounter","volume","Channel1.setFrequency","frequency","passedFrequencyHighBits","passedFrequencyLowBits","newRegister4","Channel2.updateNRx1","Channel2.updateNRx2","Channel2.updateNRx3","Channel2.updateNRx4","Channel2.saveState","Channel2.loadState","Channel2.initialize","Channel2.getSampleFromCycleCounter","Channel2.resetTimer","Channel2.getSample","Channel2.trigger","Channel2.willChannelUpdate","Channel2.updateLength","Channel2.updateEnvelope","Channel2.setFrequency","Channel3.updateNRx0","Channel3.updateNRx1","Channel3.updateNRx2","Channel3.updateNRx3","Channel3.updateNRx4","Channel3.saveState","Channel3.loadState","Channel3.handleWaveRamRead","Channel3.handleWaveRamWrite","Channel3.initialize","Channel3.getSampleFromCycleCounter","Channel3.resetTimer","Channel3.getSample","volumeCode","waveTablePosition","Channel3.trigger","Channel3.willChannelUpdate","Channel3.updateLength","Channel4.updateNRx1","Channel4.updateNRx2","Channel4.updateNRx3","divisorCode","Channel4.updateNRx4","Channel4.saveState","Channel4.loadState","Channel4.initialize","Channel4.getSampleFromCycleCounter","Channel4.getSample","linearFeedbackShiftRegister","xorLfsrBitZeroOne","Channel4.trigger","Channel4.willChannelUpdate","Channel4.getNoiseChannelFrequencyPeriod","Channel4.updateLength","Channel4.updateEnvelope","Sound.batchProcessCycles","Sound.updateNR50","Sound.updateNR51","Sound.updateNR52","Sound.maxFrameSequenceCycles","Sound.maxDownSampleCycles","Sound.saveState","Sound.loadState","Interrupts.updateInterruptEnabled","Interrupts.updateInterruptRequested","Interrupts.areInterruptsPending","Interrupts.saveState","Interrupts.loadState","Timers.batchProcessCycles","Timers.updateDividerRegister","Timers.updateTimerCounter","Timers.updateTimerModulo","Timers.updateTimerControl","oldTimerEnabled","newTimerInputClock","oldTimerCounterMaskBit","newTimerCounterMaskBit","dividerRegister","Timers.saveState","Timers.loadState","Serial.updateTransferControl","Joypad.updateJoypad","Joypad.saveState","Joypad.loadState","Lcd.updateLcdStatus","currentLcdStatus","Lcd.updateLcdControl","wasLcdEnabled","Graphics.batchProcessCycles","Graphics.MAX_CYCLES_PER_SCANLINE","Graphics.MIN_CYCLES_SPRITES_LCD_MODE","Graphics.MIN_CYCLES_TRANSFER_DATA_LCD_MODE","Graphics.saveState","Graphics.loadState","Memory.saveState","Memory.loadState","Cpu.CLOCK_SPEED","Cpu.MAX_CYCLES_PER_FRAME","Cpu.enableHalt","Cpu.exitHaltAndStop","Cpu.isHalted","Cpu.saveState","Cpu.loadState","memory","config","enableBootRom","useGbcWhenAvailable","audioBatchProcessing","graphicsBatchProcessing","timersBatchProcessing","audioAccumulateSamples","tileRendering","tileCaching","enableAudioDebugging","gbcType","cartridgeType","titleChecksum","hasCoreStarted","saveState","loadState","isGBC","getStepsPerStepSet","getStepSets","getSteps","executeMultipleFrames","numberOfFrames","frameResponse","framesRun","executeFrameAndCheckAudio","getCyclesPerCycleSet","getCycleSets","getCycles","setJoypadState","up","right","down","left","a","b","select","start","WASMBOY_MEMORY_LOCATION","ASSEMBLYSCRIPT_MEMORY_LOCATION","ASSEMBLYSCRIPT_MEMORY_SIZE","WASMBOY_STATE_SIZE","VIDEO_RAM_SIZE","WORK_RAM_SIZE","OTHER_GAMEBOY_INTERNAL_MEMORY_SIZE","setProgramCounterBreakpoint","breakpoint","resetProgramCounterBreakpoint","setReadGbMemoryBreakpoint","resetReadGbMemoryBreakpoint","setWriteGbMemoryBreakpoint","resetWriteGbMemoryBreakpoint","getRegisterA","getRegisterB","getRegisterC","getRegisterD","getRegisterE","getRegisterH","getRegisterL","getRegisterF","getProgramCounter","getStackPointer","getOpcodeAtProgramCounter","getLY","getScrollX","getScrollY","getWindowX","getWindowY","drawBackgroundMapToWasmMemory","showColor","drawTileDataToWasmMemory","tileDataMapGridY","tileDataMapGridX","spriteRow","spriteColumn","currentSpriteAttributes","spriteVramBankId","foundTileMapAddress","drawOamToWasmMemory","tilesToDraw","getDIV","getTIMA","getTMA","getTAC","updateDebugGBMemory","instance","exports","WasmBoyCore","byteMemory","type"],"mappings":"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"}